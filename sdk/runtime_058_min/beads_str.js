import{a_meas,a_path,a_image,a_tree,a_function,a_sound,a_gradient,ERR,T,F,U}from"./beads_std.js";import*as std from"./beads_std.js";const TRACE_SPLIT=!1,TRACE_CONV=!1,TRACE_JSON=!1,TRACE_JSTOR=!1,TRACE_FIND=!1,TRAP_U_SUBSCRIPTS=!0;export const SUBOP_REG_NOCASE=1;export const SUBOP_REG_MULTILINE=2;export const SUBOP_REG_GLOBAL=4;export const SUBOP_REG_STARTS=8;export const SUBOP_REG_ENDS=16;export const SUBOP_REG_LOG=32;export const ERROR_STRING="ERR";export const ascii_lowercase="abcdefghijklmnopqrstuvwxyz";export const ascii_uppercase="ABCDEFGHIJKLMNOPQRSTUVWXYZ";export const ascii_letters=ascii_lowercase+ascii_uppercase;export const digits="0123456789";export const hexdigits="0123456789abcdefABCDEF";export const octdigits="01234567";export const CR="\r";export const LF="\n";export const CODE_0="0".charCodeAt(0);export const CODE_9="9".charCodeAt(0);export const CODE_A="A".charCodeAt(0);export const CODE_TILDE="~".charCodeAt(0);export const CODE_SPACE=" ".charCodeAt(0);export const CODE_SLASH="/".charCodeAt(0);export const CODE_SQUOTE="'".charCodeAt(0);export const CODE_DQUOTE='"'.charCodeAt(0);export const CODE_CR="\r".charCodeAt(0);export const CODE_NL="\n".charCodeAt(0);export const CODE_TAB="\t".charCodeAt(0);export const CODE_BACKSLASH="\\".charCodeAt(0);const DELIM_CR="\r",DELIM_CRLF="\r\n",DELIM_LF="\n";export const BOM_UTF16_LE=65279;export const BOM_UTF16_BE=65534;const SS_DATE=0;export const PARSE_EOS="￿";export let parse_include_white;let gparse_pos,gparse_ss,gparse_errflag,gparse_errmsg;var gparse_len;export const BEADS_JSON_MARKER='{"$beads01":{';export const R_a_find=9007194157790523;export const F_find_len=9007192689371859;export const F_find_start=9007191603303728;export const R_a_find_repl=9007192534696881;export const F_find_patt=9007193956346111;export const F_repl_patt=9007194250103617;const _M=2;export function str_hash_fnv(t){let e,s,_,r,n,a=t.length;for(e=16777619,_=0;_<a;_++)r=(e^=s=t.charCodeAt(_))>>>16,n=65535&e,e=Math.imul(e,16777619)>>>0;return e};export function safe_for_html(t){let e,s,_="";for(e=0;e<t.length;e++)"<"===(s=t.charAt(e))?s="&lt;":">"===s?s="&gt;":"&"===s?s="&amp;":'"'===s?s="&quot;":"'"===s&&(s="&apos;"),_+=s;return _};export function filepath_get_folder(t){let e=t.lastIndexOf("/"),s=t.lastIndexOf("\\"),_=e>s?e:s;return t.substr(0,_)};export function filepath_get_name(t){let e=t.lastIndexOf("/"),s=t.lastIndexOf("\\"),_=e>s?e:s;return t.substr(_+1)};function weekday_to_short_str(t,e=U){switch(t){case 0:return std.s(SS_DATE,"Sun",e);case 1:return std.s(SS_DATE,"Mon",e);case 2:return std.s(SS_DATE,"Tue",e);case 3:return std.s(SS_DATE,"Wed",e);case 4:return std.s(SS_DATE,"Thu",e);case 5:return std.s(SS_DATE,"Fri",e);case 6:return std.s(SS_DATE,"Sat",e);default:return std.ERR_STR}}function weekday_to_long_str(t,e=U){switch(t){case 0:return std.s(SS_DATE,"Sunday",e);case 1:return std.s(SS_DATE,"Monday",e);case 2:return std.s(SS_DATE,"Tuesday",e);case 3:return std.s(SS_DATE,"Wednesday",e);case 4:return std.s(SS_DATE,"Thursday",e);case 5:return std.s(SS_DATE,"Friday",e);case 6:return std.s(SS_DATE,"Saturday",e);default:return std.ERR_STR}}function month_to_short_str(t,e=U){switch(t){case 1:return std.s(SS_DATE,"Jan",e);case 2:return std.s(SS_DATE,"Feb",e);case 3:return std.s(SS_DATE,"Mar",e);case 4:return std.s(SS_DATE,"Apr",e);case 5:return std.s(SS_DATE,"May",e);case 6:return std.s(SS_DATE,"Jun",e);case 7:return std.s(SS_DATE,"Jul",e);case 8:return std.s(SS_DATE,"Aug",e);case 9:return std.s(SS_DATE,"Sep",e);case 10:return std.s(SS_DATE,"Oct",e);case 11:return std.s(SS_DATE,"Nov",e);case 12:return std.s(SS_DATE,"Dec",e);default:return std.ERR_STR}}function month_to_long_str(t,e=U){switch(t){case 1:return std.s(SS_DATE,"January",e);case 2:return std.s(SS_DATE,"February",e);case 3:return std.s(SS_DATE,"March",e);case 4:return std.s(SS_DATE,"April",e);case 5:return std.s(SS_DATE,"May",e);case 6:return std.s(SS_DATE,"June",e);case 7:return std.s(SS_DATE,"July",e);case 8:return std.s(SS_DATE,"August",e);case 9:return std.s(SS_DATE,"September",e);case 10:return std.s(SS_DATE,"October",e);case 11:return std.s(SS_DATE,"November",e);case 12:return std.s(SS_DATE,"December",e);default:return std.ERR_STR}}function adjust_to_city(t,e,s){if(s==std.TIMEZONE_GMT||s==std.TIMEZONE_UTC){let s=60*t.getTimezoneOffset()*1e3;t.setTime(e+s)}else std.argument_err("adjust_to_city: arbitrary time zones not yet implemented")}export function time_to_str(t,e=null){var s,_,r,n,a,d,o,v,i,c,p,u,l,f,g,m=U,k=U,E=U;for(var S in e)switch(S){case"time":m=e.time;break;case"date":e.date instanceof std.a_path?f=e.date:std.argument_err("bad date parm in time_to_str");break;case"lang":k=e.lang;break;case"city":E=e.city;break;default:std.argument_err("bad option: "+S)}if(null==f){m==U&&(m=std.now);var h=new Date(1e3*m);E!=U&&adjust_to_city(h,m,E),g=std.seconds_to_date(m,{city:E}),f=std.adr(g)}for(n=0,l=t.length,a=0,_="",s="",n=0;n<l;n++)switch(r=t.charAt(n),a){case 0:"["!=r||0!=n&&"\\"==t.charAt(n-1)?_+=r:(s+=_,_="[",a=1);break;case 1:if("]"==r){switch(_+="]"){case"[sun]":_=weekday_to_short_str(dp_to_weekday(f));break;case"[sunday]":_=weekday_to_long_str(dp_to_weekday(f));break;case"[jan]":_=month_to_short_str(std.getn(f,std.F_dt_month));break;case"[january]":_=month_to_long_str(std.getn(f,std.F_dt_month));break;case"[day]":_=(u=std.getn(f,std.F_dt_day))>=1&&u<=31?to_str(u):std.ERR_STR;break;case"[day2]":_=(u=std.getn(f,std.F_dt_day))>=1&&u<=31?to_str(u,{min:2,zero_pad:T}):std.ERR_STR;break;case"[hour]":_=(i=std.getn(f,std.F_dt_hour))>=0&&i<=23?to_str(i,{min:2,zero_pad:T}):std.ERR_STR;break;case"[hour12]":_=(i=std.getn(f,std.F_dt_hour))>=0&&i<=12?to_str(i):i>12&&i<=23?to_str(i-12):std.ERR_STR;break;case"[julian]":d=std.getn(f,std.F_dt_year),o=std.getn(f,std.F_dt_month),v=std.getn(f,std.F_dt_day),_=(u=std.day_of_year(d,o,v))>=1&&u<=366?to_str(u):std.ERR_STR;break;case"[month]":_=(o=std.getn(f,std.F_dt_month))>=1&&o<=12?to_str(o):std.ERR_STR;break;case"[month2]":_=(o=std.getn(f,std.F_dt_month))>=1&&o<=12?to_str(o,{min:2,zero_pad:T}):std.ERR_STR;break;case"[minute]":_=(c=std.getn(f,std.F_dt_minute))>=0&&c<=60?to_str(c,{min:2,zero_pad:T}):std.ERR_STR;break;case"[am]":_=(i=std.getn(f,std.F_dt_hour))<=11?std.s(SS_DATE,"AM",k):std.s(SS_DATE,"PM",k);break;case"[second]":_=(p=std.getn(f,std.F_dt_second))>=0&&p<=61?to_str(p,{min:2,zero_pad:T,dig:0}):std.ERR_STR;break;case"[msec]":p=std.getn(f,std.F_dt_second),_=(c=Math.round(1e3*std.fract(p)))>=0&&c<=999?to_str(c,{min:3,zero_pad:T}):std.ERR_STR;break;case"[year]":_=(d=std.getn(f,std.F_dt_year))>=0&&d<=9999?to_str(d):std.ERR_STR;break;case"[year2]":_=(d=std.getn(f,std.F_dt_year))>=0&&d<=9999?to_str(d%100):std.ERR_STR;break;case"[date]":_=time_to_str("[jan] [day], [year]",e);break;case"[date time]":_=time_to_str("[jan] [day], [year] [hour12]:[minute] [am]",e);break;case"[iso date]":_=time_to_str("[year]-[month2]-[day2]",e);break;case"[iso time]":_=time_to_str("[hour]:[minute]:[second]",e);break;default:_=" bad:"+_}a=0,s+=_,_=""}else _+=r}return s+=_;function dp_to_weekday(t){var e=std.getn(f,std.F_dt_year),s=std.getn(f,std.F_dt_month),_=std.getn(f,std.F_dt_day);return std.day_of_week(e,s,_,{zero:T,monday:F})}};export function parse_init(t){gparse_ss=t,gparse_pos=0,parse_include_white=!1,gparse_errflag=!1,gparse_errmsg="",gparse_len=t.length};export function parse_get(){for(var t;t=gparse_pos<gparse_len?gparse_ss.charAt(gparse_pos):PARSE_EOS,gparse_pos++,!(parse_include_white||t>" "););return t};export function parse_unget(){gparse_pos-=1};export function parse_peek(){for(var t,e=gparse_pos;t=e<gparse_len?gparse_ss.charAt(e++):PARSE_EOS,!(parse_include_white||t>" "););return t};export function parse_err(t){gparse_errflag=!0,gparse_errmsg=conv("{str} at position {int}",t,gparse_pos),TRACE_JSON&&console.log("json error="+gparse_errmsg)};export function parse_match(t){let e=t.length;if(!parse_include_white)for(;gparse_pos<gparse_ss.length&&gparse_ss.charAt(gparse_pos)<=" ";)gparse_pos+=1;return gparse_ss.substr(gparse_pos,e)===t&&(gparse_pos+=e,!0)};export function parse_hexdigit(){let t;return(t=parse_get())>="0"&&t<="9"?t.charCodeAt(0)-"0".charCodeAt(0):t>="A"&&t<="F"?10+t.charCodeAt(0)-"A".charCodeAt(0):t>="a"&&t<="f"?10+t.charCodeAt(0)-"a".charCodeAt(0):(parse_err("Bad hex digit"),0)};export function parse_expect(t){return!!parse_match(t)||(parse_err(conv("Expected '{str}' but got '{str}'",t,parse_peek())),!1)};function json_hex4(){let t,e,s=0;for(e=0;e<4&&(t=parse_hexdigit(),!gparse_errflag);e++)s=16*s+t;return to_char(s)}function json_escape(){let t;return'"'===(t=parse_get())?'"':"\\"===t?"\\":"/"===t?"/":"b"===t?"\b":"f"===t?"\f":"n"===t?"\n":"r"===t?"\r":"t"===t?"\t":"u"===t?json_hex4():(parse_err("unexpected character after backslash")," ")}function p_json_string(){for(var t,e="";'"'!==(t=parse_get());){if(t===PARSE_EOS){parse_err("String not terminated, unbalanced double quotes");break}if("\\"===t&&(t=json_escape(),gparse_errflag))break;e+=t}return TRACE_JSON&&console.log("json string='"+e+"'"),e}function p_json_number(t){var e,s,_;if(s=gparse_pos-1,"-"===t&&(t=parse_get()),"0"===t)t=parse_get();else{if(!(t>="1"&&t<="9"))return parse_err(conv("bad character '{str}' in number",t)),parse_include_white=!1,ERR;for(;(t=parse_get())>="0"&&t<="9";);}if("."===t)for(_=0;(t=parse_get())>="0"&&t<="9";)_+=1;if("e"===t||"E"===t){for("+"!==(t=parse_get())&&"-"!==t||(t=parse_get()),_=0;t>="0"&&t<="9";)t=parse_get(),_+=1;if(0===_)return parse_err("missing exponent after 'e' in number"),parse_include_white=!1,ERR}return parse_unget(),e=Number(gparse_ss.substring(s,gparse_pos)),TRACE_JSON&&console.log("json substr="+gparse_ss.substring(s,gparse_pos)+", number="+String(e)),e}function key_to_index(t){let e;return e="^"===t.charAt(0)?to_num(t.substr(1)):to_num(t),Number.isNaN(e)&&(e=str_to_enum(t)),e}function p_beads_node(t,e,s){var _,r,n,a,d,o,v=0,i=0;function do_emit(){var _;if(0!==v){switch(TRACE_JSON&&console.log(conv("storing value of dtype={} at path={path}",v,s)),v){case std.TYPE_NUM:std.setv(t,e,s,a);break;case std.TYPE_STR:std.setv(t,e,s,d);break;case std.TYPE_MEAS:std.setv(t,e,s,o);break;case std.TYPE_FUNC:case std.TYPE_IMAGE:break;default:std.internal_err("not yet imp")}0!==i&&((_=std.path_to_pathx(s)).lev[_.lev.length-1].node.eflags|=i),v=0}else TRACE_JSON&&console.log(conv("no value to store at path={path}",s))}for(TRACE_JSON&&console.log(conv("p_beads_node, gparse_pos={int}",gparse_pos));!gparse_errflag;){if(parse_match(PARSE_EOS))return void parse_err("Unbalanced braces, missing right braces(or too many left braces)");if(parse_match("}")){do_emit();break}if(!parse_match(",")){if(!parse_expect('"'))break;if(_=p_json_string(),gparse_errflag)break;if(!parse_expect(":"))break;switch(_){case"e":if(n=p_json_number(r=parse_get()),gparse_errflag)break;switch(n){case 1:a=std.ERR;break;case 2:a=std.INFINITY;break;case 3:a=std.NEG_INFINITY;break;default:return void parse_err("bad e: value")}v=std.TYPE_NUM;break;case"n":r=parse_get(),a=p_json_number(r),v=std.TYPE_NUM;break;case"s":if(!parse_expect('"'))break;d=p_json_string(),v=std.TYPE_STR;break;case"c":if(do_emit(),!parse_expect("{"))return;p_beads_termlist(t,e,s);break;case"g":i=n>>>0;break;case"m":var c=n.split("~");o=std.meas(a,Number(c[0]),Number(c[1])),v=std.TYPE_MEAS;break;case"i":v=std.TYPE_IMAGE,std.internal_err("not yet");break;case"f":v=std.TYPE_FUNC,std.internal_err("not yet");break;case"p":v=std.TYPE_PTR,std.internal_err("not yet");break;default:parse_err(conv("Unexpected field {str}",_))}}}}function p_beads_termlist(t){let e,s;for(;;){if(TRACE_JSON&&console.log(conv("top of beads termlist, pos={int}, ss={str}",gparse_pos,gparse_ss.substr(0,100))),parse_match(PARSE_EOS)){parse_err("Unbalanced braces, missing right braces(or too many left braces)");break}if(parse_match("}"))break;if(parse_match(","))continue;if(!parse_expect('"'))break;if(e=p_json_string(),gparse_errflag)break;if(!parse_expect(":"))break;s=key_to_index(e);let _=std.addr_append(t,s);if(!parse_expect("{"))break;if(p_beads_node(_),gparse_errflag)break}}function p_json_termlist(t){let e,s,_,r,n;for(;;){if(TRACE_JSON&&console.log(conv("top of json termlist, pos={int}, ss={str}",gparse_pos,gparse_ss.substr(0,100))),parse_match(PARSE_EOS)){parse_err("Unbalanced braces, missing right braces(or too many left braces)");break}if(parse_match("}"))break;if(parse_match(","))continue;if(!parse_expect('"'))break;if(r=p_json_string(),gparse_errflag)break;if(!parse_expect(":"))break;n=key_to_index(r);let a=std.addr_append(t,n);if('"'==(e=parse_get())){if(s=p_json_string(),gparse_errflag)break;std.setv(0,0,a,s)}else if("{"==e)p_json_termlist(a);else if("["===e)std.internal_err("p_json_termlist: array not yet imp");else{if(_=p_json_number(e),gparse_errflag)break;std.setv(0,0,a,_)}}}export function json_to_tree(t,e,s,_){var r,n=_.clone();if(parse_init(s),parse_include_white=!0,parse_match(BEADS_JSON_MARKER))return 1===(r=p_json_number(parse_get()))?p_beads_termlist(t,e,_):parse_err(conv("Version error, we don't know how to convert Beads style JSON of version {int}",r)),gparse_errmsg;const a=3,d=4,o=1,v=2,i=3;var c,p,u,l=1,f=[],g=[];TRACE_JSON&&console.log(conv("=== JSON decode, buffer len={}",s.length));t:for(;p=get_token(),TRACE_JSON&&console.log(conv("top of loop, arrayx={}, adepth={}, token={}, dest={}",c,g.length,p.tval,n)),!gparse_errflag;)switch(l){case 1:if(l=2,p.tkind==i)switch(p.tval){case"[":push_state(d);continue t;case"{":push_state(a);continue t;case PARSE_EOS:break t;default:parse_err("Invalid starting character for JSON");break t}else TRACE_JSON&&console.log(conv(">> storing {} at {}",n,p.tval)),std.setv(t,e,n,p.tval);break;case 2:p.tkind==i&&p.tval==PARSE_EOS||parse_err(conv("Expected end of file, got {}",p.tval));break t;case d:if(n.key[n.key.length-1]=c,p.tkind==i)switch(p.tval){case"[":push_state(d);continue t;case"{":push_state(a);continue t;case"]":pop_state();continue t;case",":continue t;case PARSE_EOS:parse_err("Expected ] before end");break t;default:parse_err(conv("Unexpected token {} in array",p.tval));break t}else TRACE_JSTOR&&console.log(conv(">> storing at {}, val=[{}]",n,p.tval)),std.setv(t,e,n,p.tval),c++;break;case a:if(p.tkind!=v){if(p.tkind==i){switch(p.tval){case",":continue t;case"}":pop_state();continue t;case PARSE_EOS:parse_err("Expected } before end");break t}parse_err(conv("Unexpected token {} in object",p.tval));break t}parse_err(conv("Not expecting the number {} as a key in an object",p.tval));break t}if(u=p.tval,n.key[n.key.length-1]=u,(p=get_token()).tkind!=i||":"!=p.tval){parse_err(conv("Expected a ':' but got {}",p.tval));break t}if((p=get_token()).tkind==i)switch(p.tval){case"[":push_state(d);continue t;case"{":push_state(a);continue t;case"}":pop_state();continue t;case",":continue t;case PARSE_EOS:parse_err("Expected value before end");break t;default:parse_err(conv("Unexpected token {} in array",p.tval));break t}else TRACE_JSTOR&&console.log(conv(">> storing at {}, val=[{}]",n,p.tval)),std.setv(t,e,n,p.tval)}return gparse_errmsg;function push_state(t){f.push(l),g.push(c),l=t,c=1,t!=d&&t!=a||n.key.push(0)}function pop_state(){l!=d&&l!=a||n.key.pop(),l=f.pop(),c=g.pop(),l==d&&c++}function get_token(){for(var t,e,s,_,r,n,a;n=gparse_pos," "==(t=parse_get())||"\n"==t||"\r"==t||"\t"==t;);switch(t){case",":case":":case"[":case"]":case"{":case"}":case PARSE_EOS:return{tkind:i,tpos:n,tval:t};case'"':return t=p_json_string(),{tkind:v,tpos:n,tval:t};case"-":case"0":case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":return a=p_json_number(t),{tkind:o,tpos:n,tval:a};case"n":if(e=parse_get(),s=parse_get(),_=parse_get(),"u"==e&&"l"==s&&"l"==_)return{tkind:o,tpos:n,tval:U};parse_err("Was expecting null");break;case"t":if(e=parse_get(),s=parse_get(),_=parse_get(),"r"==e&&"u"==s&&"e"==_)return{tkind:o,tpos:n,tval:T};parse_err("Was expecting true");break;case"f":if(e=parse_get(),s=parse_get(),_=parse_get(),r=parse_get(),"a"==e&&"l"==s&&"s"==_&&"e"==r)return{tkind:o,tpos:n,tval:F};parse_err("Was expecting false");break;default:parse_err(conv("Unexpected character {}",t))}return{tkind:i,tpos:n,tval:PARSE_EOS}}};export function tree_to_json(t,e=null){let s,_,r,n,a,d="",o=std.INFINITY;function numval(t,e){return Number.isNaN(t)?'"@ERR"':t===U?"null":t===T?"true":t===F?"false":t===std.INFINITY?'"@INFINITY"':t===std.NEG_INFINITY?'"@NEG_INFINITY"':std.is_enum_b(t)?'"@'+enum_to_str(t)+'"':e?'"'+String(t)+'"':String(t)}if(t instanceof std.a_tree)s=t;else if(t instanceof std.a_path){if(null===t)return null;s=std.path_to_node(t)}else std.argument_err("expected path or tree");for(let t in e)switch(t){case"limit":o=e.limit;break;default:std.argument_err("bad option: "+t)}return _=0,d=BEADS_JSON_MARKER,function do_node(t,e){let s,v,i;if(!((_+=1)>=o))if(_%8==7&&(d+="\n"),d+=numval(t.sub,!0)+":",i=!0,null!=t.children){var c=!0;for(var p in d+="{",t.children)c?c=!1:d+=",",do_node(s=t.children[p],e+1);d+="}"}else e>0&&(t.eflags&std.EF_VAL_IS_NUM?d+=numval(t.val,!1):t.eflags&std.EF_VAL_IS_STR?d+=escape_to_json(t.val):t.eflags&std.EF_VAL_IS_ERR?d+="@ERR":t.eflags&std.EF_VAL_IS_IMAGE?(a=t.val,d+='"^i|'+String(a.naturalWidth)+"|"+String(a.naturalHeight)+'|"'):t.eflags&std.EF_VAL_IS_MEAS?(v=t.val,d+='"^m|'+numval(v.mag,!1)+"|"+numval(v.unit)+"|"+numval(v.family)+'"'):t.eflags&std.EF_VAL_IS_FUNC?(n=t.val,d+='"^f|'+n.name+'"'):t.eflags&std.EF_VAL_IS_PATH?(r=t.val,d+='"^p|',d+="|"):d+="@ERR")}(s,0),d+="}}"};export function str_to_enum(t){return str_hash_fnv(t)+std.FIRST_ENUM};export function enum_to_str(t,e=!1){let s;return std.CHECKS&&!is_enumb(t)&&std.halt(),s=void 0===std.ENUMS[t]?"ENUM:"+to_str(t-=std.FIRST_ENUM,{min:10,zero_pad:T}):std.ENUMS[t]};export function from_char(t){return null===t||""===t?ERR:t.charCodeAt(0)};export function to_char(t){return Number.isNaN(t)||t===U||t<=0?"":String.fromCodePoint(t)};function hexdig_to_num(t){switch(t){case"0":return 0;case"1":return 1;case"2":return 2;case"3":return 3;case"4":return 4;case"5":return 5;case"6":return 6;case"7":return 7;case"8":return 8;case"9":return 9;case"A":case"a":return 10;case"B":case"b":return 11;case"C":case"c":return 12;case"D":case"d":return 13;case"E":case"e":return 14;case"F":case"f":return 15;default:return ERR}}export function color_to_hex(t){return"#"+to_str(t,{base:16,min:6,zero_pad:T})};export function hex_to_color(t){if(null==t)return ERR;var e=0;if(7==t.length){if("#"!=t.charAt(0))return ERR;e=1}for(var s=0,_=0;_<6;_++)s=16*s+hexdig_to_num(t.charAt(e+_));return s};export function num_to_hex(t){let e=new ArrayBuffer(8),s=new Uint8Array(e);new Float64Array(e)[0]=t;for(var _="",r=0;r<8;r++)_+=("00"+s[r].toString(16)).slice(-2);return _};export function hex_to_num(t){if(16!=t.length)return ERR;let e=new ArrayBuffer(8),s=new Uint8Array(e),_=0;for(var r=0;r<16;r+=2){var n=parseInt(t.substring(r,r+2),16);s[_]=n,_+=1}return new Float64Array(e)[0]};export function real64_to_str(t,e=U,s=1,_=".",r=",",n=!1,a=!1){let d,o,v,i,c,p;if(e===U?(d=t.toString()).indexOf(".")<0&&(e=0):d=t.toFixed(e),"."!==_&&(v=/\./,d=d.replace(v,_)),""!==r)for(TRACE_CONV&&console.log("real64, before comma insertion, ss="+d),i=d.length-1,c=0===e?2:1,p=0;!(i<0);){switch(o=d.charAt(i),TRACE_CONV&&console.log("at top of loop, nd="+p+", state="+String(c)+", pos="+String(i)+", cc="+o),c){case 1:"."===o&&(c=2,p=0);break;case 2:o>="0"&&o<="9"&&4===(p+=1)&&(d=d.substr(0,i+1)+r+d.substr(i+1),p=1)}i-=1}for(t>0&&a&&(d="+"+d),n&&t<0&&(d="("+d.substr(1)+")");d.length<s;)d=" "+d;return d};function strip_trailing_zeros(t,e){let s,_,r,n=t.length-1;if(r=0,(s=t.indexOf(e))>=0)for(_=n;;){if("0"!==t.charAt(_)){t.charAt(_)===e&&(r+=1);break}r+=1,_-=1}return 0===r?t:t.slice(0,-r)}export function to_num(t){if(0==t.length)return 0;let e;return t===std.U_STR?U:t===std.ERR_STR?ERR:(e=Number(t),Number.isNaN(e)?ERR:e)};export function is_enumb(t){return t>=std.FIRST_ENUM&&t<=std.LAST_ENUM};export function angle_to_str(t){return to_str(std.to_unit(t,std.N_deg),{dig:1})};export function xy_to_str(t){var e=std.getn(t,std.F_x),s=std.getn(t,std.F_y);return"["+to_str(e,{dig:1})+", "+to_str(s,{dig:1})+"]"};export function rect_to_str(t){var e=std.getn(t,std.F_left),s=std.getn(t,std.F_top),_=std.getn(t,std.F_width),r=std.getn(t,std.F_height);return"["+to_str(e,{dig:1})+","+to_str(s,{dig:1})+" "+to_str(_,{dig:1})+"x"+to_str(r,{dig:1})+"]"};export function to_str(t,e=null){let s,_,r,n=10,a="$ ",d=".",o=U,v=!1,i=!1,c=!1,p=!1,u=!1,l=!1,f=!1,g=!1,m=!1,k=!0,E=!1,S="ENG",h=999,b=0,R=null,P="U",y=",",A=U;!std.CHECKS||null===e||e instanceof Object||std.argument_err("bad syntax, 2nd parm must be object");for(let t in e)switch(t){case"increase":i=e.increase==T;break;case"decrease":v=e.decrease==T;break;case"base":2!==(n=e.base)&&8!==n&&10!==n&&16!==n&&std.argument_err(`to_str:base ${n} not yet implemented`);break;case"currency":c=e.currency==T;break;case"currency_cc":a=e.currency_cc;break;case"decimal_cc":d=e.decimal_cc;break;case"human":p=e.human==T;break;case"k":u=e.k==T;break;case"lang":S=e.lang;break;case"max":h=e.max;break;case"min":b=e.min;break;case"neg_paren":l=e.neg_paren==T;break;case"pos_plus":g=e.pos_plus==T;break;case"percent":f=e.percent==T;break;case"dig":o=e.dig;break;case"u_cc":P=e.u_cc;break;case"thou":m=e.thou==T;break;case"thou_cc":y=e.thou_cc;break;case"units":A=e.units;break;case"zero_pad":E=e.zero_pad==T;break;case"zero_drop":k=e.zero_drop==T;break;default:std.argument_err("bad option: "+t)}if(std.CHECKS&&(i||v)&&o===U&&std.argument_err("conflicting parms, increase/decrease must have digits specified"),c&&(b-=a.length),g&&t>0&&(b-=1),t===U||null==t)r=P,E=!1;else if("string"==typeof t)r=t;else if(t instanceof std.a_meas){let s,_=t;Number.isNaN(A)||Number.isNaN(_.mag)?(r="ERR",E=!1):A===U?(s=_.family===U?null==_.unitss?"":" "+_.unitss.split(",").join("⋅"):" "+enum_to_str(A=std.getn(std.families,_.family,std.F_fam_base)),r=to_str(_.mag,e)+s):r=to_str(std.to_unit(_,A),e)+" "+enum_to_str(A)}else if(t instanceof std.a_path)r=conv_path(t);else if(t instanceof std.a_image){let e=t;r=e.url+" "+String(e.bits.width)+" x "+String(e.bits.height)}else if(t instanceof std.a_function){let e=t;r=std.MODULES[e.modnum]+":"+e.name}else if(t instanceof RegExp)r=t.toString();else if(t instanceof std.a_sound){r=to_str(t.id,e)}else if(t instanceof std.a_sys_gradient){r="gradient:"+t.grad_kind}else if(t===std.INFINITY)r="INFINITY",E=!1;else if(t===std.NEG_INFINITY)r="-INFINITY",E=!1;else if(t===T)r="Y",E=!1;else if(t===F)r="N",E=!1;else if(is_enumb(t))r=enum_to_str(t),E=!1;else if(Number.isNaN(t))r="ERR",E=!1;else{if(u&&(Math.abs(t)>=1e9?(o=Math.abs(t)>=1e10?0:1,t=std.round(t/1e9,-1),R="B"):Math.abs(t)>=1e6?(o=Math.abs(t)>=1e7?0:1,t=std.round(t/1e6,-1),R="M"):Math.abs(t)>=1e3&&(t=std.round(t/1e3),R="K")),v&&Math.abs(t)>=1e3&&(o=0),m||(y=""),10===n)f&&(t*=100,R="%"),r=real64_to_str(t,o,1,d,y,l);else if(16===n)for(r=t.toString(16).toUpperCase();r.length<b-2;)r=E?"0"+r:" "+r;else r=(t>>>0).toString(8===n?8:2);if(i&&/^0\.0+$/.test(r)&&o<4)return _=o,e.digits=o+1,r=to_str(t,e),e.digits=_,r;"."===r.charAt(0)&&(r="0"+r),v&&(r=strip_trailing_zeros(r,d)),k&&(r=strip_trailing_zeros(r,d)),null!==R&&(r+=R)}return(s=b-r.length)>0&&(r=E?str_repeat("0",s)+r:str_repeat(" ",s)+r),c&&(r=a+r),g&&t>0&&(r="+"+r),r.length>h&&(r=str_repeat("#",h)),r};function strip_module(t){return t.substring(0,t.indexOf(":"))}export function color_to_rgb_str(t){return t===std.U_COLOR?"rgb(U)":"rgb("+String(std.r255(t))+","+String(std.g255(t))+","+String(std.b255(t))+")"};export function node_to_str(t,e){let s,_,r;if(null!==t)if(t.eflags&std.EF_VAL_IS_U){if(!e)return"";_=":U",r=""}else if(t.eflags&std.EF_VAL_IS_ERR)_=":ERR",r="";else if(t.eflags&std.EF_VAL_IS_NUM)_=":num",r=to_str(t.val);else if(t.eflags&std.EF_VAL_IS_STR)_=":str",r='"'+t.val+'"';else if(t.eflags&std.EF_VAL_IS_IMAGE)_=":image",r="IMAGE";else if(t.eflags&std.EF_VAL_IS_FUNC){_=":func",r=t.val.name}else if(t.eflags&std.EF_VAL_IS_PATH)_=":path",r=conv_path(t.val);else if(t.eflags&std.EF_VAL_IS_MEAS)_=":meas",r="MEAS";else if(t.eflags&std.EF_VAL_IS_SOUND)_=":sound",r="SOUND";else if(t.eflags&std.EF_VAL_IS_GRAD)_=":grad",r="GRAD";else if(t.eflags&std.EF_VAL_IS_BYTES)_=":bytes",r="BYTES";else if(t.eflags&std.EF_VAL_IS_COLOR){_=":color",r=color_to_rgb_str(t.val)}else if(t.eflags&std.EF_VAL_IS_DATE){_=":date";t.val;r="DATE"}else t.eflags&std.EF_VAL_IS_VIDEO?(_=":video",r="VIDEO"):t.eflags&std.EF_VAL_IS_OBJECT?(_=":object",r="OBJECT"):std.argument_err("bad node");else _="<NULL>",r="";return s="",""!==r&&(s+="="+r),s};export function tree_to_str(t,e=null){let s,_,r="",n=!0,a=!0,d=std.INFINITY;for(let t in e)switch(t){case"prompt":r=e.prompt;break;case"showu":e.showu===T&&(n=!0);break;case"limit":d=e.limit;break;default:std.argument_err("bad option: "+t)}return r+="{",t instanceof std.a_tree?_=t:t instanceof std.a_path?_=std.path_to_node(t):std.argument_err("bad input type, must be tree or path"),function walk_nodes(t,e){let _,o,v;if(null!==t)for(var i in t.children){if(_=node_to_str(o=t.children[i],n),""!==(v=e)&&(v+=","),v+=to_str(o.sub),""!==_&&(a?a=!1:r+=", ",r+="["+v+"]",r+=_),(s+=1)>=d){r+="...";break}null!==o.children&&walk_nodes(o,v)}}(_,""),r+="}"};export function str_len(t){return t===std.U_STR?U:t===std.ERR_STR?ERR:t.length};export function to_upper(t){return t===std.U_STR||t===std.ERR_STR?t:t.toUpperCase()};export function to_lower(t){return t===std.U_STR||t===std.ERR_STR?t:t.toLowerCase()};export function str_repeat(t,e){let s;return t===std.U_STR||t===std.ERR_STR?t:std.is_numeric(e)!==T?std.ERR_STR:(s=Math.round(e))<=0?"":1===s?t:t.repeat(s)};export function str_reverse(t){if(t===std.U_STR||t===std.ERR_STR)return t;if(""===t)return"";let e=t.split("");return e.reverse(),e.join("")};export function str_begins(t,e){if(null===t||null===e)return U;let s=t.length,_=e.length;return _>s?F:t.substr(0,_)===e?T:F};export function str_ends(t,e){if(null===t||null===e)return U;let s=t.length,_=e.length;return _>s?F:t.substr(s-_,_)===e?T:F};export function str_strip_quotes(t){let e,s,_,r;return t===std.U_STR||t===std.ERR_STR?t:(_=!1,s=t.length,(r=t.charCodeAt(s-1))!==CODE_SQUOTE&&r!==CODE_DQUOTE||(s-=1,_=!0),e=0,(r=t.charCodeAt(0))!==CODE_SQUOTE&&r!==CODE_DQUOTE||(e=1,s-=1,_=!0),_?t.substr(e,s):t)};export function str_trim(t){return null==t?null:t.trim()};export function pad_left(t,e,s){if(t===std.U_STR||t===std.ERR_STR)return t;let _=" ";for(let t in s)switch(t){case"pad":_=s.pad.charAt(0);break;default:std.argument_err("bad option: "+t)}let r=e-t.length;for(;r>0;)t=_+t,r-=1;return t};export function pad_right(t,e,s){if(t===std.U_STR||t===std.ERR_STR)return t;let _=" ";for(let t in s)switch(t){case"pad":_=s.pad.charAt(0);break;default:std.argument_err("bad option: "+t)}let r=e-t.length;for(;r>0;)t+=_,r-=1;return t};export function subset(t,e){var s=!1,_=1,r=U,n=U;if(t===std.U_STR||t===std.ERR_STR)return t;for(var a in e)switch(a){case"rev":s=e.rev===T;break;case"from":(_=e.from)<1&&(_=1);break;case"to":n=e.to;break;case"len":r=e.len;break;default:std.argument_err("bad option: "+a)}if(std.is_err_enum(_)===T||std.is_err(r)===T||std.is_err(n)===T)return ERROR_STRING;var d=std.INFINITY;return r!=U?d=r:n!=U&&(d=n-_+1),s?d==std.INFINITY?t.substr(-_):t.substr(-(_+d-1),d):t.substr(_-1,d)};export function str_digit(t,e){let s,_,r=F,n=1;if(t===std.U_STR)return U;if(t===std.ERR_STR)return ERR;for(let t in e)switch(t){case"from":n=e.from;break;case"rev":r=e.rev;break;default:std.argument_err("bad option: "+t)}return(_=from_char(s=subset(t,{from:n,rev:r,len:1})))>=CODE_0&&_<=CODE_9?_-CODE_0:ERR};export function str_ins(t,e,s){if(t===std.U_STR||e==std.U_STR)return std.U_STR;if(t===std.ERR_STR||e==std.ERR_STR)return std.ERR_STR;let _=U,r=!1,n=0,a=t.length;for(let t in s)switch(t){case"del":if(n=s.del,std.is_numeric(n)!=T)return std.ERR_STR;n<0&&(n=0);break;case"to":if(_=s.to,std.is_numeric(_)!=T)return std.ERR_STR;_<1&&(_=1);break;case"rev":r=s.rev==T;break;default:std.argument_err("bad option: "+t)}return r&&(_=a+1-_),t.slice(0,_-1)+e+t.slice(_-1+n)};export function str_del(t,e){if(t===std.U_STR)return std.U_STR;if(t===std.ERR_STR)return std.ERR_STR;let s=1,_=U,r=U,n=!1,a=t.length;for(let t in e)switch(t){case"from":if(s=e.from,std.is_numeric(s)!=T)return std.ERR_STR;s<1&&(s=1);break;case"to":if(_=e.to,std.is_numeric(_)!=T)return std.ERR_STR;_<1&&(_=1);break;case"len":if(r=e.len,std.is_numeric(r)!=T)return std.ERR_STR;if(r<=0)return"";break;case"rev":n=e.rev==T;break;default:std.argument_err("bad option: "+t)}if(_!=U){if(_<s)return t}else r!=U?_=s+r-1:std.argument_err("must specify either to: or len:");if(n){let t=_;_=a+1-s,s=a+1-t}return t.slice(0,s-1)+t.slice(_)};export function escape_for_regexp(t){return t.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")};export function str_to_regexp(t,e){var s=!0,_=!1,r=!1;for(var n in e)switch(n){case"ignore_case":s=e.ignore_case==T;break;case"global":_=e.global==T;break;case"multiline":r=e.multiline==T;break;default:std.argument_err("bad option: "+n)}var a="";return s&&(a+="i"),_&&(a+="g"),r&&(a+="m"),new RegExp(t,a)};export function str_find(t,e,s,_,r,n){let a=!1,d=0,o=1;var v=T;let i,c,p,u,l,f,F,g=0;if(std.trunc_tree(t,e,r),null!==s&&""!==s&&s!==std.ERR_STR&&null!==_&&""!==_&&_!==std.ERR_STR){for(let t in n)switch(t){case"start":d=n.start-1;break;case"reps":o=std.numeric_arg(n.reps);break;case"wrap":n.wrap===T&&(a=!0);break;case"ignore_case":v=n.ignore_case;break;default:std.argument_err("bad option: "+t)}if("string"==typeof _)F=str_to_regexp(escape_for_regexp(_),{ignore_case:v,global:T});else{if(!(_ instanceof RegExp))return void(std.CHECKS&&std.argument_err("bad pattern"));F=_}for(c=!a,i=s.length,F.lastIndex=d;g<o;){if(null!==(p=F.exec(s))){if(u=p.index,l=F.lastIndex,TRACE_FIND&&console.log(conv("  MATCH, m_start={}, m_end={}",u,l)),g+=1,std.setv(t,e,r,g,F_find_start,u+1),f=l-u,std.setv(t,e,r,g,F_find_len,f),g>=o)break}else TRACE_FIND&&console.log("--not found"),F.lastIndex=i;if(F.lastIndex>=i){if(c)break;TRACE_FIND&&console.log(" doing wrap, starting at top"),c=!0,F.lastIndex=0,i=d}}}};export function str_pos(t,e,s){var _=1,r=T,n=new a_tree(_M,"str_pos");if(t===std.ERR_STR||e===std.ERR_STR)return ERR;if(null===t||""===t||null===e||""===e)return U;for(var a in s)switch(a){case"start":_=s.start;break;case"ignore_case":r=s.ignore_case;break;default:std.argument_err("bad option: "+a)}return str_find(_M,0,t,e,std.adr(n),{start:_,ignore_case:r}),std.getn(n,1,F_find_start)};export function str_replace(t,e,s){return t.replace(e,s)};export function str_replace_multiple(t,e,s){let _,r,n,a,d,o,v,i,c=t,p=0,u=!1;if(null===t||""===t)return t;for(let t in s)switch(t){case"trace":s.trace===T&&(u=!0);break;default:std.argument_err("bad option: "+t)}let l=new std.a_loop({across:e});for(;l.next();)for(a=l.path,_=l.index,r=std.get_generic(a,F_find_patt),n=std.gets(a,F_repl_patt),r.lastIndex=0;null!==(d=r.exec(c));){v=d.index,i=r.lastIndex;for(var f,F=[],g=0;;){if(!((f=n.indexOf("$",g))>=0&&(m=n.charAt(f+1),m>="0"&&m<="9"))||0!=f&&"\\"==n.charAt(f-1)){add_fragment(g,n.length);break}add_fragment(g,f),F.push(Number(n.charAt(f+1))),g=f+2}o=calc_replacement(F,d),u&&(p+=1,log_context(String(_),c,v,i,o)),c=c.substring(0,v)+o+c.substring(i),r.lastIndex+=v+o.length}var m;return u&&console.log("--- did "+String(p)+" replacements"),c;function add_fragment(t,e){if(e>t){let s=n.substring(t,e);F.push(s)}}};function calc_replacement(t,e){let s,_,r="";for(s of t)"string"==typeof s?r+=s:"number"==typeof s?(_=s)>=0&&_<e.length&&(r+=e[_]):std.argument_err("bad target");return r}function log_context(t,e,s,_,r){let n,a,d,o,v,i,c=e.length;for(d=s,o=0,n="《";!((d-=1)<0);){if("\n"===(i=e.charAt(d))||"\r"===i){n="¬"+n;break}if(n=(i=net_log_cc(i))+n,(o+=1)>17){n="..."+n;break}}for(d=_,a="》",v=0;!(d>=c);){if("\n"===(i=e.charAt(d))||"\r"===i){a+="¬";break}if(a+=i=net_log_cc(i),(v+=1)>40){a+="...";break}d+=1}console.log("\npattern "+t+", start="+String(s)),console.log("   "+n+net_log_ss(e.substring(s,_))+a),console.log("   "+n+net_log_ss(r)+a)}function net_log_ss(t){let e,s="",_=t.length;for(e=0;e<_;e++)s+=net_log_cc(t.charAt(e));return s}function net_log_cc(t){return"\t"===t?"▲":"\n"===t||"\r"===t?"¬":t<" "?"✪":t}export function str_inject(t,...e){let s,_=t;for(let t of e)s="$"+String(1),_=_.replaceAll(s,t);return _};export function join_words(t,e){for(var s="",_=!0,r=new std.a_loop({across:t});r.next();)"string"==typeof r.val&&(_?_=!1:s+=e,s+=r.val);return s};export function split_words(t,e,s,_,r){var n="\t";for(var a in r)switch(a){case"delim":n=r.delim;break;default:std.argument_err("bad option: "+a)}if(std.trunc_tree(t,e,_),null!=s&&s!=std.ERR_STR){var d,o=s.split(n),v=1;for(d of o)std.setv(t,e,_,v,d),v++}};export function split_lines(t,e,s,_){let r,n,a,d,o;function emit_fragment(r,n){let d;a+=1,d=n>r?s.substring(r,n):"",TRACE_SPLIT&&console.log(conv(" adding line {int} with ss={str}",a,d)),std.setv(t,e,_,a,d)}if(std.trunc_tree(t,e,_),null!=s&&s!=std.ERR_STR&&0!==(n=s.length))for(a=0,d=0,(o=s.charCodeAt(0))!==BOM_UTF16_LE&&o!==BOM_UTF16_BE||(d+=1),r=d;;){if(d>=n){d>r&&emit_fragment(r,d);break}o=s.charCodeAt(d),d+=1,o===CODE_CR?(emit_fragment(r,d-1),d<n&&s.charCodeAt(d)===CODE_NL&&(d+=1),r=d):o===CODE_NL&&(emit_fragment(r,d-1),r=d)}};export function split_lines_words(t,e,s,_,r){const n=!0;let a,d,o,v,i,c,p,u,l,f="\t",F=!0;function emit_token(){if(a.length>0){if(n){let t=0,e=a.length-1;for(;e>=0&&" "===a.charAt(e);)e-=1,t+=1;t>0&&(a=a.substring(0,e+1))}TRACE_SPLIT&&console.log(conv(" adding cell[{int},{int}] with ss=[{str}]",v,i,a)),std.setv(t,e,_,v,i,a)}a="",u=!0,l=!1}if(std.trunc_tree(t,e,_),null!=s&&s!=std.ERR_STR&&0!==(o=s.length)){for(let t in r)switch(t){case"quotes":F=r.quotes===T;break;case"delim":f=r.delim;break;default:std.argument_err("bad option: "+t)}for(v=1,i=1,c=0,l=!1,u=!0,a="",(p=s.charCodeAt(0))!==BOM_UTF16_LE&&p!==BOM_UTF16_BE||(c+=1);;){if(c>=o){emit_token();break}if(d=s.charAt(c),c+=1,'"'===d&&F){if(u){u=!1,l=!0;continue}if(c<o&&'"'===s.charAt(c)){a+='"',c+=1;continue}l=!1}else if(" "!==d||0!==a.length){if(l){if(d===CR){c<o&&s.charAt(c)===LF&&(c+=1),a+=LF,u=!1;continue}if(d===LF){a+=LF,u=!1;continue}}else{if(d===CR){c<o&&s.charAt(c)===LF&&(c+=1),emit_token(),v+=1,i=1;continue}if(d===LF){emit_token(),v+=1,i=1;continue}if(d===f){emit_token(),i+=1;continue}}a+=d,u=!1}else u=!1}}};export function escape_to_json(t){let e,s="",_=t.length;for(let r=0;r<_;r++)switch(e=t.charAt(r)){case'"':s+='\\"';break;case"\\":s+="\\\\";break;case"\b":s+="\\b";break;case"\f":s+="\\f";break;case"\n":s+="\\n";break;case"\r":s+="\\r";break;case"\t":s+="\\t";break;default:if(e<" "){let t=e.charCodeAt(0).toString(16);s+="\\u"+(2===t.length?"00":"000")+t}else s+=e}return'"'+s+'"'};export function str_range(t,e,s=99999999999999){return 0===t.length||std.is_numeric(e)!==T||std.is_numeric(s)!==T?"":(e<0&&(e=0),s>t.length&&(s=t.length),t.slice(e,s))};export function rgb_str(t){return"R:"+String(std.r255(t))+" G:"+String(std.g255(t))+" B:"+String(std.b255(t))};export function rgb_hex_str(t){return"0x"+to_str(t,{base:16,min:6,zero_pad:T})};export function rgb_html_str(t){return"#"+to_str(t,{base:16,min:6,zero_pad:T})};export function conv(t,...e){let s,_,r,n,a,d,o,v,i;for(n=0,o=0,d=t.length,a=0,_="",s="",n=0;n<d;n++)switch(r=t.charAt(n),a){case 0:"{"!==r||0!==n&&"\\"===t.charAt(n-1)?_+=r:(s+=_,_=r,a=1);break;case 1:if("}"===r){switch(_+="}"){case"{}":if(null===(i=e[o])||void 0==i)_="U";else if("number"==typeof i||"number"==typeof i)_=to_str(i,{dig:3,decrease:T});else if("string"==typeof i)_=i;else if("boolean"==typeof i)_=conv_bool(i);else if(i instanceof std.Rectangle)_=conv_rect(i);else if(i instanceof std.a_tree){_=i.sub}else if(i instanceof std.a_path)_=conv_path(i);else if(i instanceof std.a_pathx)_=conv_pathx(i);else if(i instanceof std.a_meas){_=to_str(i.mag,{dig:3,decrease:T})}else if(i instanceof std.a_image)_="image:"+i.alt;else if(i instanceof std.Bitmap){let t=i;_=conv("bitmap[{} x {}]",t.width,t.height)}else if(i instanceof Function)_="<function>";else if(i instanceof std.a_function){let t=i;_=std.MODULES[t.modnum]+":"+t.name}else _=i instanceof RegExp?i.toString():"<object>";break;case"{a_xy}":(i=e[o])instanceof std.a_tree||i instanceof std.a_path?_="["+to_str(std.getn(i,std.F_x))+" "+to_str(std.getn(i,std.F_y))+"]":std.argument_err("expecting a tree or path type");break;case"{array}":(i=e[o])instanceof Array?_=conv_array(i):std.argument_err("expecting a Array type");break;case"{bool}":"boolean"==typeof(i=e[o])?_=conv_bool(i):std.argument_err("expecting a Boolean type");break;case"{uri}":"string"==typeof(i=e[o])?_=conv_uri(i):std.argument_err("expecting a String type");break;case"{e}":_=to_str(std.elapsed,{dig:3}),o-=1;break;case"{hex}":"number"==typeof(i=e[o])?_=conv_num_to_hex(i):std.argument_err("expecting a number type");break;case"{int}":_=String(e[o]);break;case"{key}":e[o]instanceof Array?_=conv_vector_num(e[o]):std.argument_err("expecting a path key");break;case"{meas}":e[o]instanceof std.a_meas?_=to_str(e[o],{dig:3,decrease:T}):std.argument_err("expecting a meas type");break;case"{num}":"number"==typeof e[o]?_=real64_to_str(e[o],0,1,"",""):std.argument_err("expecting a num type");break;case"{n}":case"{n0}":case"{n,0}":"number"==typeof e[o]?_=to_str(e[o]):std.argument_err("expecting a num type");break;case"{n1}":case"{n2}":case"{n3}":case"{n4}":case"{n5}":case"{n6}":case"{n7}":case"{n8}":case"{n9}":"number"==typeof e[o]?(v=parseInt(_.charAt(2),10),_=to_str(e[o],{dig:v,zero_drop:F})):std.argument_err("expecting a num type");break;case"{n,1}":case"{n,2}":case"{n,3}":case"{n,4}":case"{n,5}":case"{n,6}":case"{n,7}":case"{n,8}":case"{n,9}":"number"==typeof e[o]?(v=parseInt(_.charAt(3),10),_=to_str(e[o],{dig:v})):std.argument_err("expecting a num type");break;case"{hpath}":null===e[o]?_="null":e[o]instanceof std.a_pathh?_=conv_pathh(e[o]):std.argument_err("expecting a pathh type");break;case"{path}":null===e[o]?_="null":e[o]instanceof std.a_path?_=conv_path(e[o]):std.argument_err("expecting a path type");break;case"{pathx}":null===e[o]?_="null":e[o]instanceof std.a_pathx?_=conv_pathx(e[o]):std.argument_err("expecting a pathx type");break;case"{rect}":null===e[o]?_="null":e[o]instanceof std.Rectangle?_=conv_rect(e[o]):e[o]instanceof std.a_tree||e[o]instanceof std.a_path?_=conv_tree_rect(e[o]):std.argument_err("expecting a Rectangle type");break;case"{rgb}":"number"==typeof e[o]?_=rgb_str(e[o]):std.argument_err("expecting a rgb color as uint type");break;case"{rgb_hex}":"number"==typeof e[o]||"number"==typeof e[o]?_=rgb_hex_str(e[o]):std.argument_err("expecting a rgb color as uint type");break;case"{rgb_html}":"number"==typeof e[o]||"number"==typeof e[o]?_=rgb_html_str(e[o]):std.argument_err("expecting a rgb color as numeric type");break;case"{str}":"string"==typeof e[o]?_=e[o]:std.argument_err("expecting a string type");break;case"{tree}":e[o]instanceof std.a_path||e[o]instanceof std.a_tree?_=tree_to_str(e[o]):std.argument_err("expecting a tree type");break;default:std.argument_err("unknown conversion type")}a=0,o+=1,s+=_,_=""}else _+=r}return o!==e.length&&std.argument_err("conv: parameter number mismatch"),s+=_};export function conv_pathx(t){var e,s;if(null===t)return"[null pathx]";e=t.basepath.base instanceof std.a_tree?t.basepath.base.label:"Ⓢ"+std.TREES[t.basepath.base].label,e+="[";for(var _=t.lev.length-1,r=1;r<=_;r++){s=t.lev[r],r>1&&(e+=", ");var n=s.sub;e+="string"==typeof n?n:to_str(n,{u_cc:"?"})}return e+="]"};export function conv_path(t){let e,s,_=!0;if(null===t)return"[null path]";for(s of(e=t.base instanceof std.a_tree?t.base.label:"Ⓢ"+std.TREES[t.base].label,e+="[",t.key))_?_=!1:e+=", ",e+="string"==typeof s?s:to_str(s,{u_cc:"U"});return e+="]"};export function conv_pathh(t){let e,s,_=!0;if(null===t)return"[null pathh]";for(s of(e=t.base.label+"[",t.key))_?_=!1:e+=", ",e+="string"==typeof s?s:to_str(s);return e+="]"};export function conv_bool(t){return t?"T":"F"};export function conv_num_to_hex(t){let e,s,_,r="",n=std.new_bytes(8,std.BIG_ENDIAN);for(std.bytes_put_num(n,t),n.position=0,s=0;s<8;s++)r+=e=conv_hex_byte(_=std.bytes_get_u8(n));return r};export function conv_hex_byte(t){let e;return(t<0||t>255)&&std.argument_err("above ascii characters not yet implemented"),1===(e=t.toString(16)).length&&(e="0"+e),e};export function conv_unicode_to_bytes(t){let e,s,_,r=std.new_bytes(10,std.BIG_ENDIAN),n="";for(std.bytes_put_str(t),_=r.position-1,r.position=1,s=0;s<_;s++)n+="%"+conv_hex_byte(e=std.bytes_get_u8(r));return t};export function conv_uri(t){let e,s,_,r="",n=t.length;for(e=0;e<n;e++)r+=(s=t.charAt(e))>="A"&&s<="Z"||s>="a"&&s<="z"||s>="0"&&s<="9"||"*"===s||"-"===s||"."===s||"/"===s||"_"===s?s:s<="~"?"%"+conv_hex_byte(_=from_char(s)):conv_unicode_to_bytes(s);return r};export function conv_dict(t){let e,s="[";for(e in t)s+=conv_num(e)+" ";return s+="]"};export function conv_vector_num(t){let e,s="[",_=!0;for(e of t)_?_=!1:s+=", ",s+=to_str(e);return s+="]"};export function conv_array(t){let e,s="[",_=!0;for(e=0;e<t.length;e++)_?_=!1:s+=", ","number"==typeof t[e]?s+=to_str(t[e]):s+=String(t[e]);return s+="]"};export function conv_num(t){return to_str(t)};export function conv_n(t){return to_str(t)};export function conv_tree_rect(t){return conv("[{n1},{n1} {n1}x{n1}]",std.getn(t,std.F_left),std.getn(t,std.F_top),std.getn(t,std.F_width),std.getn(t,std.F_height))};export function conv_rect(t){return conv("[{n1},{n1} {n1}x{n1}]",t.left,t.top,t.width,t.height)};const g_base64_encode=[65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,48,49,50,51,52,53,54,55,56,57,43,47],g_base64_decode=[-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,-1,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,-1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1];export function bytes_to_base64(t){let e,s=4*(2+t.length-(t.length+2)%3)/3,_=std.new_bytes(s),r=0,n=t.length%3,a=t.length-n,d=0;for(;r<a;)e=t[r++]<<16|t[r++]<<8|t[r++],_[d++]=g_base64_encode[e>>>18],_[d++]=g_base64_encode[e>>>12&63],_[d++]=g_base64_encode[e>>>6&63],_[d++]=g_base64_encode[63&e];return 1===n?(e=t[r],_[d++]=g_base64_encode[e>>>2],_[d++]=g_base64_encode[(3&e)<<4],_[d++]=61,_[d++]=61):2===n&&(e=t[r++]<<8|t[r],_[d++]=g_base64_encode[e>>>10],_[d++]=g_base64_encode[e>>>4&63],_[d++]=g_base64_encode[(15&e)<<2],_[d++]=61),_.readUTFBytes(_.length)};export function base64_to_bytes(t){let e,s,_,r,n=0,a=t.length,d=Math.ceil(3*a/4)+2,o=std.new_bytes(d);o.writeUTFBytes(t);let v=0;for(;n<a&&-1!==(e=g_base64_decode[o[n++]])&&-1!==(s=g_base64_decode[o[n++]])&&(o[v++]=e<<2|(48&s)>>4,61!==(_=o[n++]))&&-1!==(_=g_base64_decode[_])&&(o[v++]=(15&s)<<4|(60&_)>>2,61!==(r=o[n++]))&&-1!==(r=g_base64_decode[r]);)o[v++]=(3&_)<<6|r;return o.length=v,o.position=0,o};export function http_encodeURIComponent(t,e){var s=!1;for(let t in e)switch(t){case"plus":s=e.plus==T;break;default:std.argument_err("bad option: "+t)}var _=encodeURIComponent(t);return s&&(_=_.replace(/%20/g,"+")),_};export function http_decodeURIComponent(t,e){var s=!1;for(let t in e)switch(t){case"plus":s=e.plus==T;break;default:std.argument_err("bad option: "+t)}return s&&(t=t.replace(/\+/g," ")),decodeURIComponent(t)};const http_encodeURI=encodeURI,http_decodeURI=decodeURI;export function str_add_meta(){const t=std.VAL,e=std.POP;std.merge_lit(_M,0,std.META,"str",std.F_mod_const,"BOM_UTF16_BE",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,"BOM_UTF16_LE",std.F_vv_typek,1,t,std.TYPE_NUM),std.merge_lit(_M,0,std.META,"str",std.F_mod_funcs,"base64_to_bytes",std.F_vv_cat,t,"String conversions|Basic|convert a base64 string into bytes",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,21,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"s|string to convert",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_BYTES,e,e,"bytes_to_base64",std.F_vv_cat,t,"String conversions|Basic|convert from byte array to base64 string",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,44,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"buf|array of bytes to convert",std.F_vv_typek,1,t,std.TYPE_BYTES,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"color_to_hex",std.F_vv_cat,t,'String conversions|Basic|convert a color into a hex string: "#AABBCC"|HTML hex form: #AABBCC',std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,33,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"c|input color",std.F_vv_typek,1,t,std.TYPE_COLOR,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"escape_for_regexp",std.F_vv_cat,t,"String ops|Basic|put backslashes in front of RegExp special chars",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,9,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"input|input string",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"from_char",std.F_vv_cat,t,"String conversions|Basic|convert a character to its numeric value|numeric value (null string returns 0)",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,42,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"char|first character in string is used",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_NUM,e,e,"hex_to_color",std.F_vv_cat,t,'String conversions|Basic|convert a hex string "AABBCC" or "#AABBCC" into a color|resulting color value, ERR on invalid input',std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,3,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"ss|6 or 7 character hex string",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_COLOR,e,e,"hex_to_num",std.F_vv_cat,t,"String conversions|Basic|convert a 16 character hex string into a num|resulting num value, ERR on invalid input",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,30,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"ss|16 character string",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_NUM,e,e,"http_decodeURI",std.F_vv_cat,t,"URL encoding|Basic|",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,14,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"input",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"http_decodeURIComponent",std.F_vv_cat,t,"URL encoding|Basic|decode a URI component|resulting decoded string,",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,31,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"input|string to decode.",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_default,t,"F",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"plus|if T, then convert + to %20 in first pass",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"http_encodeURI",std.F_vv_cat,t,"URL encoding|Basic|",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,6,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"input",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"http_encodeURIComponent",std.F_vv_cat,t,"URL encoding|Basic|encode a URI component|resulting encoded string, converted to UTF8 with %xx notation",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,4,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"input|string to encode.",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_default,t,"F",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"plus|if T, then convert %20 to + in second pass",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"join_words",std.F_vv_cat,t,"String ops|Basic|join an array of words|list of words joined together, with delimiter between",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,43,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"list",std.F_vv_typek,1,t,std.TYPE_ARRAY,2,t,std.TYPE_STR,e,e,2,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"delim",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"json_to_tree",std.F_vv_cat,t,"String conversions|Basic|convert a JSON string back into a tree",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,23,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"json|JSON string to convert",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"t|where to store resulting tree",std.F_vv_typek,1,t,std.TYPE_TREE,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"markdown_to_html",std.F_vv_cat,t,"String conversions|Basic|decode a markdown block into plain HTML|plain HTML string",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,13,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"input|markdown text to convert",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"num_to_hex",std.F_vv_cat,t,'String conversions|Basic|convert a double precision floating point number into 16 character hex string|16 char hex string, e.g.: "ff332211ff332211"',std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,12,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"n|input number",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"pad_left",std.F_vv_cat,t,"String ops|Basic|pad a string on the left to a specified length|resulting string",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,38,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"ss|starting string",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"len|target length",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,3,std.F_vv_default,t," ",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"pad|character to pad with",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"pad_right",std.F_vv_cat,t,"String ops|Basic|pad a string on the right to a specified length|resulting string",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,28,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"ss|starting string",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"len|target length",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,3,std.F_vv_default,t," ",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"pad|character to pad with",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"safe_for_html",std.F_vv_cat,t,"String conversions|Basic|replace various metacharacters used in HTML|fixed up string",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,32,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"input",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"split_lines",std.F_vv_cat,t,"String ops|Basic|split a string into lines on each line break (\\r, \\n, \\r\\n)",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,41,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"buf|starting string",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"result|(OUT) array of lines",std.F_vv_typek,1,t,std.TYPE_ARRAY,2,t,std.TYPE_STR,e,e,e,e,"split_lines_words",std.F_vv_cat,t,"String ops|Basic|split a string into 2D array of strings, indexed [lines, words]",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,5,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"buf|starting string",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"result|(OUT) array of lines and words",std.F_vv_typek,1,t,std.TYPE_ARRAY,2,t,std.TYPE_ARRAY,3,t,std.TYPE_STR,e,e,3,std.F_vv_default,t,"\t",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"delim|single word break character like tab or comma",std.F_vv_typek,1,t,std.TYPE_STR,e,e,4,std.F_vv_default,t,"T",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"quotes|if true, then consider double quotes to allow embedding of LF, strip them",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,e,e,"split_words",std.F_vv_cat,t,"String ops|Basic|split a line into words",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,46,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"buf|starting string",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"result|(OUT) array of words",std.F_vv_typek,1,t,std.TYPE_ARRAY,2,t,std.TYPE_STR,e,e,3,std.F_vv_default,t,"\t",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"delim|word break character like tab or comma",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,e,"str_begins",std.F_vv_cat,t,"String ops|Basic|see if string begins with a pattern|T, F, U",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,18,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"haystack|big string to check against",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"needle|string to look for",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,"str_del",std.F_vv_cat,t,"String ops|Basic|remove characters from a string|modified string",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,34,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"ss|string to manipulate",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_default,t,"1",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"from|starting position to delete, 1=first",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,3,std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"to|ending position (inclusive) to delete",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,4,std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"len|number of characters to delete",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,5,std.F_vv_default,t,"F",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"rev|count from end?",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"str_digit",std.F_vv_cat,t,"String ops|Basic|get a numeric digit out of a string|character converted to a number 0-9, E if non-numeric",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,25,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"ss|string to extract from",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_default,t,"1",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"from|position of character, 1=first",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,3,std.F_vv_default,t,"F",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"rev|count from end?",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,e,std.F_vv_typek,1,t,std.TYPE_NUM,e,e,"str_ends",std.F_vv_cat,t,"String ops|Basic|see if string ends with a pattern|T, F, U",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,20,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"haystack|big string to check against",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"needle|string to look for",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,"str_find",std.F_vv_cat,t,"String ops|Basic|find a pattern in a string",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,39,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"haystack|haystack to search",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"needle|either regular expression or plain string to find",std.F_vv_typek,1,t,std.TYPE_ANY,e,e,3,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"list|(OUT) array of a_find, position/len of the matched string 1..F",std.F_vv_typek,1,t,std.TYPE_ARRAY,2,t,std.TYPE_RECORD,3,t,R_a_find,e,e,4,std.F_vv_default,t,"1",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"start|starting position, 1=first",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,5,std.F_vv_default,t,"1",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"reps|max repetitions",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,6,std.F_vv_default,t,"F",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"wrap|wrap around search",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,7,std.F_vv_default,t,"T",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"ignore_case|only used when needle is a plain string",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,e,e,"str_hash_fnv",std.F_vv_cat,t,"String ops|Basic|utility to hash strings|hashed string as unsigned 32 bit number",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,16,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"input|string to hash",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_NUM,e,e,"str_inject",std.F_vv_cat,t,"String ops|Basic|inject substrings into another, use $1, $2,.. $9 etc. for markers|new string",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,27,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"input",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_parmk,t,std.PK_REST,std.F_vv_parmn,t,"parms",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"str_ins",std.F_vv_cat,t,"String ops|Basic|insert characters into a string just once|modified string",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,36,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"ss|starting string",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"ins|string to insert",std.F_vv_typek,1,t,std.TYPE_STR,e,e,3,std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"to|position to insert in front of 1=first",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,4,std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"del|number of characters to delete while doing the insert",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,5,std.F_vv_default,t,"F",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"rev|count from end?",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"str_len",std.F_vv_cat,t,"String ops|Basic|string length|length of string",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,7,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"ss|string to count length of",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_NUM,e,e,"str_pos",std.F_vv_cat,t,"String ops|Basic|find the first occurance of a pattern in a string|if found, the starting position, otherwise U",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,35,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"haystack|haystack to search",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"needle|either regular expression or plain string to find",std.F_vv_typek,1,t,std.TYPE_ANY,e,e,3,std.F_vv_default,t,"1",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"start|starting position, 1=first char",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,4,std.F_vv_default,t,"T",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"ignore_case|only used when needle is a plain string",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,e,std.F_vv_typek,1,t,std.TYPE_NUM,e,e,"str_repeat",std.F_vv_cat,t,"String ops|Basic|repeat a string|repeated version",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,45,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"ss|string to repeat",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"ntimes|number of times to repeat",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"str_replace",std.F_vv_cat,t,"String ops|Basic|find and replace in a string|new string with replacements done",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,37,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"haystack|haystack to search",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"needle|either regular expression or plain string to find",std.F_vv_typek,1,t,std.TYPE_ANY,e,e,3,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"replace|replacement string ($1, $2, etc. refer to matched groups)",std.F_vv_typek,1,t,std.TYPE_STR,e,e,4,std.F_vv_default,t,"1",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"start|starting position, 1=first char",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"str_replace_multiple",std.F_vv_cat,t,"String ops|Basic|apply a series of changes to a string|new string with replacements done",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,19,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"haystack|haystack to search",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"changes|array of find/replace operations to perform",std.F_vv_typek,1,t,std.TYPE_ARRAY,2,t,std.TYPE_RECORD,3,t,R_a_find_repl,e,e,3,std.F_vv_default,t,"F",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"trace|write progress to log",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"str_reverse",std.F_vv_cat,t,"String ops|Basic|reverse a string|reversed version",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,29,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"ss|string to reverse",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"str_strip_quotes",std.F_vv_cat,t,"String ops|Basic|strip quotes around a string|stripped version",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,24,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"ss|string to process",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"str_to_enum",std.F_vv_cat,t,"String conversions|Basic|convert a string of an enum into its internal value|internal representation of that enum",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,8,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"s|enum string",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_NUM,e,e,"str_to_regexp",std.F_vv_cat,t,"String ops|Basic|convert a string to a regular expression|result",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,48,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,'s|regexp string like "[a-z]"',std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_default,t,"T",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"ignore_case",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,3,std.F_vv_default,t,"F",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"global",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,4,std.F_vv_default,t,"F",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"multiline",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,e,std.F_vv_typek,1,t,std.TYPE_REGEXP,e,e,"str_trim",std.F_vv_cat,t,"String ops|Basic|trim whitespace on either side of a string|resulting string",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,1,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"ss|starting string",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"subset",std.F_vv_cat,t,"String ops|Basic|string subset|extracted string, might be empty",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,47,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"ss|starting string",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_default,t,"1",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"from|starting position to take from, 1=first",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,3,std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"to|ending position (inclusive)",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,4,std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"len|number of characters to extract",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,5,std.F_vv_default,t,"F",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"rev|count from end?",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"time_to_str",std.F_vv_cat,t,"String conversions|Basic|convert a date/time to a string|output string",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,40,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"format|formatting string",std.F_vv_typek,1,t,std.TYPE_STR,e,e,2,std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"time|unix epoch time in seconds to convert, U uses now()",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,3,std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"date|date input",std.F_vv_typek,1,t,std.TYPE_RECORD,2,t,std.R_a_date,3,t,"std",e,e,4,std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"city|enum TIMEZONE_PARIS, TIMEZONE_GMT",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,5,std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"lang|language",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"to_char",std.F_vv_cat,t,"String conversions|Basic|convert a number into its character value|unicode character, null string if out of range",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,10,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"code|unicode code point",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"to_lower",std.F_vv_cat,t,"String conversions|Basic|convert to lowercase|lower case version",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,17,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"ss|string to convert",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"to_num",std.F_vv_cat,t,'String conversions|Basic|convert a string like "12.34" into a number, empty is 0|number form (ERR if bad string)',std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,26,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"s|string to convert",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_NUM,e,e,"to_str",std.F_vv_cat,t,"String conversions|Basic|convert a value into string form|string form of the input value",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,15,std.F_vv_parms,10,std.F_vv_default,t,"F",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"pos_plus|draw plus in front of positive quantities",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,11,std.F_vv_default,t,"F",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"percent|if T, add % as suffix, mult by 100",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,12,std.F_vv_default,t,"F",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"zero_pad|if T, pad with leading zeros to make min. width",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,13,std.F_vv_default,t,"T",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"zero_drop|if T, drop trailing zeros after decimal point 3.00 -> 3",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,14,std.F_vv_default,t,"$",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"currency_cc|override default currency of $",std.F_vv_typek,1,t,std.TYPE_STR,e,e,15,std.F_vv_default,t,".",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"decimal_cc|override default decimal point of .",std.F_vv_typek,1,t,std.TYPE_STR,e,e,16,std.F_vv_default,t,",",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"thou_cc|override default thousands symbol",std.F_vv_typek,1,t,std.TYPE_STR,e,e,17,std.F_vv_default,t,"U",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"u_cc|what to use when value is U",std.F_vv_typek,1,t,std.TYPE_STR,e,e,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"val|value to convert, usually a num type",std.F_vv_typek,1,t,std.TYPE_ANY,e,e,2,std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"dig|U: automatic number of digits after decimal",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,3,std.F_vv_default,t,"999",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"max|max number of characters in length",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,4,std.F_vv_default,t,"0",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"min|pad on left to this min. length",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,5,std.F_vv_default,t,"10",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"base|we support bases 2/8/10/16",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,6,std.F_vv_default,t,"F",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"currency|if T, then show currency character",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,7,std.F_vv_default,t,"F",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"thou|if T, then insert thousands marks",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,8,std.F_vv_default,t,"F",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"k|if T, then round to K (1000), M (million), B (billion)",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,9,std.F_vv_default,t,"F",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"neg_paren|draw parenthesis for negative values",std.F_vv_typek,1,t,std.TYPE_BOOL,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"to_upper",std.F_vv_cat,t,"String conversions|Basic|convert to uppercase|upper case version",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,11,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"ss|string to convert",std.F_vv_typek,1,t,std.TYPE_STR,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"tree_to_json",std.F_vv_cat,t,"String conversions|Basic|convert a tree into a JSON-compatible string|output JSON string",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,2,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"t|tree to convert",std.F_vv_typek,1,t,std.TYPE_TREE,e,e,2,std.F_vv_default,t,"INFINITY",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"limit|number of items to stop after",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR,e,e,"tree_to_str",std.F_vv_cat,t,"String conversions|Basic|convert a tree into a string|output BSON string",std.F_vv_funck,t,std.FK_CALC,std.F_vv_funcx,t,22,std.F_vv_parms,1,std.F_vv_parmk,t,std.PK_POS,std.F_vv_parmn,t,"t|tree to convert",std.F_vv_typek,1,t,std.TYPE_TREE,e,e,2,std.F_vv_default,t,"INFINITY",std.F_vv_parmk,t,std.PK_NAMED,std.F_vv_parmn,t,"limit|number of items to stop after",std.F_vv_typek,1,t,std.TYPE_NUM,e,e,e,std.F_vv_typek,1,t,std.TYPE_STR),std.merge_lit(_M,0,std.META,"str",std.F_mod_recs,R_a_find_repl,F_find_patt,1,t,std.TYPE_REGEXP,e,F_repl_patt,1,t,std.TYPE_STR,e,std.F_vv_cat,t,"String ops|Basic|",e,R_a_find,F_find_len,1,t,std.TYPE_NUM,e,F_find_start,1,t,std.TYPE_NUM,e,std.F_vv_cat,t,"String ops|Basic|")};