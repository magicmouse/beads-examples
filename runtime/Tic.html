<!DOCTYPE html>
<html lang="en"> 
<head>
<meta charset="utf-8"/>
<title>TicClient</title>
<style>
/*  this disables the annoying double click highlighting of DIV blocks  */
div { outline-style:none;}
/*  this customizes the default scrollbar appearance */
::-webkit-scrollbar { width: 12pt; }
::-webkit-scrollbar-track {
    box-shadow: inset 0 0 15px grey; 
    border-radius: 6pt; }
::-webkit-scrollbar-thumb {
    background: OliveDrab; 
    border-radius: 6pt; }
::-webkit-scrollbar-thumb:hover {
    background: Olive; }
</style>
</head>
<body style="margin:0; padding:0;">
<script type="module">
import * as std from './beads_std.js';
import * as str from './beads_str.js';
import * as k   from './beads_k.js';

export const CODE_HASH = 0x5a5da08f;
export const M_TicClient = 9007193903388826;  std.g_enum_ss[9007193903388826] = "TicClient";
const M = M_TicClient;
std.rtl_init();
std.aaaa.main_init = main_init;
std.aaaa.main_module = M;
std.aaaa.main_drawer = new std.a_function("TicClient", "main_draw", main_draw);
std.setv(0,0, std.META, M, "TicClient");
std.setv(0,0, std.META, M, std.F_mod_funcs, 91, "draw_games");
std.setv(0,0, std.META, M, std.F_mod_funcs, 354, "are_we_in_game");
std.setv(0,0, std.META, M, std.F_mod_funcs, 284, "d_board");
std.setv(0,0, std.META, M, std.F_mod_funcs, 247, "d_username");
std.setv(0,0, std.META, M, std.F_mod_funcs, 275, "d_board_outer");
std.setv(0,0, std.META, M, std.F_mod_funcs, 164, "d_status2");
std.setv(0,0, std.META, M, std.F_mod_funcs, 211, "d_exit");
std.setv(0,0, std.META, M, std.F_mod_funcs, 128, "d_game");
std.setv(0,0, std.META, M, std.F_mod_funcs, 118, "serv_join_game");
std.setv(0,0, std.META, M, std.F_mod_funcs, 146, "serv_take_square");
std.setv(0,0, std.META, M, std.F_mod_funcs, 360, "is_our_turn");
std.setv(0,0, std.META, M, std.F_mod_funcs, 223, "d_rematch");
std.setv(0,0, std.META, M, std.F_mod_funcs, 213, "serv_rematch");
std.setv(0,0, std.META, M, std.F_mod_funcs, 200, "d_timer_bar");
std.setv(0,0, std.META, M, std.F_mod_funcs, 190, "serv_leave_game");
std.setv(0,0, std.META, M, std.F_mod_funcs, 235, "d_join");
std.setv(0,0, std.META, M, std.F_mod_funcs, 156, "d_status");
std.setv(0,0, std.META, M, std.F_mod_funcs, 177, "d_middle_row");
std.setv(0,0, std.META, M, std.F_mod_funcs, 29, "main_init");
std.setv(0,0, std.META, M, std.F_mod_funcs, 73, "main_draw");
std.setv(0,0, std.META, M, std.F_mod_funcs, 345, "d_button");
//------- enums
export const F_name = 9007190800402099;  std.g_enum_ss[9007190800402099] = "name";
std.FIELDS[F_name] = true;
export const GAME_PLAYING = 9007194254392788;  std.g_enum_ss[9007194254392788] = "GAME_PLAYING";
export const TIC_TAC_TOE = 9007193099423021;  std.g_enum_ss[9007193099423021] = "TIC_TAC_TOE";
export const F_nmoves = 9007192354872428;  std.g_enum_ss[9007192354872428] = "nmoves";
std.FIELDS[F_nmoves] = true;
export const F_userid = 9007194247903518;  std.g_enum_ss[9007194247903518] = "userid";
std.FIELDS[F_userid] = true;
export const F_hilite_join1 = 9007193094295739;  std.g_enum_ss[9007193094295739] = "hilite_join1";
std.FIELDS[F_hilite_join1] = true;
export const F_busy = 9007193206867365;  std.g_enum_ss[9007193206867365] = "busy";
std.FIELDS[F_busy] = true;
export const F_board = 9007192136647888;  std.g_enum_ss[9007192136647888] = "board";
std.FIELDS[F_board] = true;
export const R_a_game = 9007190716200546;  std.g_enum_ss[9007190716200546] = "a_game";
export const F_side = 9007192069310235;  std.g_enum_ss[9007192069310235] = "side";
std.FIELDS[F_side] = true;
export const F_won = 9007191862969040;  std.g_enum_ss[9007191862969040] = "won";
std.FIELDS[F_won] = true;
export const F_winner = 9007193320334119;  std.g_enum_ss[9007193320334119] = "winner";
std.FIELDS[F_winner] = true;
export const GAME_OVER = 9007190135020664;  std.g_enum_ss[9007190135020664] = "GAME_OVER";
export const GAME_WAITING = 9007190541146425;  std.g_enum_ss[9007190541146425] = "GAME_WAITING";
export const F_hilite_rematch = 9007191262786266;  std.g_enum_ss[9007191262786266] = "hilite_rematch";
std.FIELDS[F_hilite_rematch] = true;
export const F_hilite_exit = 9007190761914728;  std.g_enum_ss[9007190761914728] = "hilite_exit";
std.FIELDS[F_hilite_exit] = true;
export const F_turn = 9007190401181855;  std.g_enum_ss[9007190401181855] = "turn";
std.FIELDS[F_turn] = true;
export const F_players = 9007191462603714;  std.g_enum_ss[9007191462603714] = "players";
std.FIELDS[F_players] = true;
export const R_a_player = 9007192680559157;  std.g_enum_ss[9007192680559157] = "a_player";
export const F_hilite_join2 = 9007193111073358;  std.g_enum_ss[9007193111073358] = "hilite_join2";
std.FIELDS[F_hilite_join2] = true;
export const F_gstate = 9007193387866726;  std.g_enum_ss[9007193387866726] = "gstate";
std.FIELDS[F_gstate] = true;
export const F_hints = 9007190902379630;  std.g_enum_ss[9007190902379630] = "hints";
std.FIELDS[F_hints] = true;
export const F_last_move = 9007192981743132;  std.g_enum_ss[9007192981743132] = "last_move";
std.FIELDS[F_last_move] = true;
//-------  remote const
const NGAMES = 12;
const SERV_PORT = 2000;
//-------  func const
const draw_games_F = new std.a_function("TicClient", "draw_games", draw_games, track_draw_games);
const draw_games_cell_F = new std.a_function("TicClient", "draw_games_cell", draw_games_cell);
const d_board_F = new std.a_function("TicClient", "d_board", d_board, track_d_board);
const d_board_cell_F = new std.a_function("TicClient", "d_board_cell", d_board_cell);
const d_username_F = new std.a_function("TicClient", "d_username", d_username);
const d_board_outer_F = new std.a_function("TicClient", "d_board_outer", d_board_outer);
const d_status2_F = new std.a_function("TicClient", "d_status2", d_status2);
const d_exit_F = new std.a_function("TicClient", "d_exit", d_exit, track_d_exit);
const d_rematch_F = new std.a_function("TicClient", "d_rematch", d_rematch, track_d_rematch);
const d_timer_bar_F = new std.a_function("TicClient", "d_timer_bar", d_timer_bar);
const d_join_F = new std.a_function("TicClient", "d_join", d_join, track_d_join);
const d_status_F = new std.a_function("TicClient", "d_status", d_status);
const d_middle_row_F = new std.a_function("TicClient", "d_middle_row", d_middle_row);
//-------  top nodes
const BEEP = new std.a_sound("art/beep.mp3");

const BUTT_BACK = 0x54938F;
const BUTT_EDGE = 0x497F7C;
const BUTT_TEXT = std.WHITE;
const MY_NAME = std.cat(std.random_word4(), "-", std.random_word4());
const MY_ID = std.getn(std.runtime, std.F_hardware_id);
const SCAFFOLDING = std.N;

let games = new std.a_tree("TicClient","games", std.NF_STATEFUL|std.NF_LOGGED);
const V_TicClient_games = 9007191881714439;  std.g_enum_ss[9007191881714439] = "games";
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_val, std.addr(games));
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_type, std.TYPE_TREE);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_dim, 1);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_rec, R_a_game);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_gstate, std.F_v_type, std.TYPE_NUM);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_turn, std.F_v_type, std.TYPE_NUM);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_winner, std.F_v_type, std.TYPE_NUM);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_nmoves, std.F_v_type, std.TYPE_NUM);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_last_move, std.F_v_type, std.TYPE_NUM);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_players, std.F_v_type, std.TYPE_TREE);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_players, std.F_v_dim, 1);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_players, std.F_v_rec, R_a_player);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_players, std.F_v_fields, F_userid, std.F_v_type, std.TYPE_NUM);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_players, std.F_v_fields, F_name, std.F_v_type, std.TYPE_STR);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_players, std.F_v_fields, F_won, std.F_v_type, std.TYPE_NUM);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_players, std.F_v_fields, F_side, std.F_v_type, std.TYPE_STR);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_board, std.F_v_type, std.TYPE_NUM);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_board, std.F_v_dim, 1);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_hints, std.F_v_type, std.TYPE_COLOR);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_hints, std.F_v_dim, 1);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_hilite_join1, std.F_v_type, std.TYPE_YESNO);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_hilite_join2, std.F_v_type, std.TYPE_YESNO);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_hilite_rematch, std.F_v_type, std.TYPE_YESNO);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_hilite_exit, std.F_v_type, std.TYPE_YESNO);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_games, std.F_v_fields, F_busy, std.F_v_type, std.TYPE_YESNO);
let con1 = new std.a_tree("TicClient","con1", std.NF_STATEFUL|std.NF_LOGGED);
const V_TicClient_con1 = 9007193029888851;  std.g_enum_ss[9007193029888851] = "con1";
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_con1, std.F_v_val, std.addr(con1));
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_con1, std.F_v_type, std.TYPE_TREE);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_con1, std.F_v_rec, std.R_a_client_conn);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_con1, std.F_v_fields, std.F_client_channel, std.F_v_type, std.TYPE_OBJECT);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_con1, std.F_v_fields, std.F_client_status, std.F_v_type, std.TYPE_NUM);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_con1, std.F_v_fields, std.F_client_bytes_in, std.F_v_type, std.TYPE_NUM);
std.setv(0,0, std.META, M, std.F_mod_vars, V_TicClient_con1, std.F_v_fields, std.F_client_bytes_out, std.F_v_type, std.TYPE_NUM);

//====================
//   d_board
//====================
function d_board(b, game) {
k.k_enter(b);
k.div_begin(b, true, false, false, false);
  k.div_add(b, std.U, 0, 100, std.al, d_board_cell_F, 0);
  k.div_spa(b, 0, 10, std.al);
  k.div_add(b, std.U, 0, 100, std.al, d_board_cell_F, 0);
  k.div_spa(b, 0, 10, std.al);
  k.div_add(b, std.U, 0, 100, std.al, d_board_cell_F, 0);
  k.div_add(b, std.U, 1, 100, std.al, d_board_cell_F, 0);
  k.div_spa(b, 1, 10, std.al);
  k.div_add(b, std.U, 1, 100, std.al, d_board_cell_F, 0);
  k.div_spa(b, 1, 10, std.al);
  k.div_add(b, std.U, 1, 100, std.al, d_board_cell_F, 0);
  k.div_end(b);
  //--under
  std.draw_rect(b, std.addr(b.extra, std.F_box), { color:0xBDF7FF });
  k.draw_grid(b, game);
  //--over
  let indent = std.div(b.bounds.width, 20);
  let length = std.sub(std.sub(b.bounds.width, indent), indent);
  let thickness = std.div(std.mul(b.bounds.width, 12), 320);
  let linec = are_we_in_game(std.addr(game)) === std.Y ? BUTT_BACK : std.GRAY4;
  std.draw_line(b, { color:linec, x1:indent, y1:std.div(std.mul(b.bounds.height, 1), 3), dx:length, dy:0, thick:thickness });
  std.draw_line(b, { color:linec, x1:indent, y1:std.div(std.mul(b.bounds.height, 2), 3), dx:length, dy:0, thick:thickness });
  std.draw_line(b, { color:linec, x1:std.div(std.mul(b.bounds.width, 1), 3), y1:indent, dy:length, dx:0, thick:thickness });
  std.draw_line(b, { color:linec, x1:std.div(std.mul(b.bounds.width, 2), 3), y1:indent, dy:length, dx:0, thick:thickness });
k.k_leave(b);
}


//====================
//   d_board_cell
//====================
function d_board_cell(b, game) {
  k.k_enter(b);
  let color = std.getn(game, F_hints, std.getn(b.extra, std.F_cell_seq));
  if (color !== std.U) {
    std.draw_rect(b, std.addr(b.extra, std.F_box), { fill:color });
  }
  let playerx = std.getn(game, F_board, std.getn(b.extra, std.F_cell_seq));
  if (playerx !== std.U) {
    std.draw_str(b, std.addr(b.extra, std.F_box), std.gets(game, F_players, playerx, F_side), { size:std.mul(b.bounds.height, 0.95), color:std.CRIMSON });
  }
  k.k_leave(b);
}

//====================
//   track_d_board
//====================
function track_d_board(b, e, game) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    if (std.getn(game, F_busy) !== std.Y && std.eq2(std.getn(game, F_gstate), GAME_PLAYING) && is_our_turn(std.addr(game)) === std.Y && std.getn(game, F_board, std.getn(b.extra
    , std.F_cell_seq)) === std.U) {
      std.remote_call(std.addr(con1), "serv_take_square", 4177323367, [std.addr(game), std.getn(b.extra, std.F_cell_seq)]);
    } else {
      std.log(std.cat("rejected tap, in_game=", str.to_str(are_we_in_game(std.addr(game))), ", our_turn=", str.to_str(is_our_turn(std.addr(game))), ", board=", str.to_str(std.getn(
      game, F_board, std.getn(b.extra, std.F_cell_seq)))));
      std.sound_play(BEEP);
    }
  return std.Y;
  }
  return std.N;
}

//====================
//   d_board_outer
//====================
function d_board_outer(b, game) {
k.k_enter(b);
  let r = new std.a_tree("TicClient","r"); std.merge_tree(M, 278, std.solve_rect({ basis:std.addr(b.extra, std.F_box), pin:5, aspect:1, inset:std.div(b.bounds.height, 24) })
  , std.addr(r));
  var b3 = k.k_create_layer(b,{ area:r });
  k.k_enter(b3);
    k.k_isolate(b3, b3.bounds, "d_board", d_board_F, [std.addr(game)]);
  k.k_leave(b3);
k.k_leave(b);
}


//====================
//   d_button
//====================
function d_button(b, mybox, label) {
k.k_enter(b);
  let netbox = new std.a_tree("TicClient","netbox"); std.merge_tree(M, 349, std.solve_rect({ basis:std.addr(mybox), pin:5, width:std.min(std.getn(mybox, std.F_width), std.pt_to_dots(
  b, 120)) }), std.addr(netbox));
  std.draw_rect(b, std.addr(netbox), { fill:BUTT_BACK, thick:std.pt_to_dots(b, 2), color:BUTT_EDGE, corner:std.mul(std.getn(netbox, std.F_height), 0.4) });
  std.draw_str(b, std.addr(netbox), label, { color:BUTT_TEXT, size:std.mul(std.getn(netbox, std.F_height), 0.6) });
k.k_leave(b);
}


//====================
//   d_exit
//====================
function d_exit(b, game) {
k.k_enter(b);
  d_button(b, std.addr(b.extra, std.F_box), "Exit");
k.k_leave(b);
}


//====================
//   track_d_exit
//====================
function track_d_exit(b, e, game) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    if (std.getn(game, F_busy) === std.Y) {
      std.sound_play(BEEP);
    } else {
      std.remote_call(std.addr(con1), "serv_leave_game", 1682659926, [std.addr(game), MY_ID]);
    }
  return std.Y;
  }
  return std.N;
}

//====================
//   d_game
//====================
function d_game(b, game) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  let mythick = std.pt_to_dots(b, 2);
  let myfill = std.BEIGE;
  let border = 0xF7CF8F;
  if (are_we_in_game(std.addr(game)) === std.Y) {
    myfill = 0xB3C5A1;
    border = 0x96A587;
    mythick = std.pt_to_dots(b, 3);
  } else if (std.ne2(std.getn(game, F_gstate), GAME_WAITING)) {
    myfill = std.GRAY2;
    border = 0xA59F97;
  }
  std.draw_rect(b, std.addr(b.extra, std.F_box), { fill:myfill, corner:std.pt_to_dots(b, 8), thick:mythick, color:border, pos:0 });
  k.div_spa(b, 1, 4, std.pt);
  k.div_add(b, std.U, 1, 20, std.al, d_status_F, 0, [std.addr(game)]);
  k.div_add(b, std.U, 1, 40, std.al, d_board_outer_F, 0, [std.addr(game)]);
  k.div_spa(b, 1, 4, std.pt);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_join
//====================
function d_join(b, game) {
k.k_enter(b);
  d_button(b, std.addr(b.extra, std.F_box), "Join");
k.k_leave(b);
}


//====================
//   track_d_join
//====================
function track_d_join(b, e, game) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    if (std.getn(game, F_busy) === std.Y) {
      std.sound_play(BEEP);
    } else {
      std.remote_call(std.addr(con1), "serv_join_game", 3261992235, [std.addr(game), MY_NAME, MY_ID]);
    }
  return std.Y;
  }
  return std.N;
}

//====================
//   d_middle_row
//====================
function d_middle_row(b, game) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  if (std.eq2(std.getn(game, F_gstate), GAME_WAITING)) {
    k.div_add(b, std.U, 0, 50, std.al, d_join_F, 0, [std.addr(game)]);
  }
  if (are_we_in_game(std.addr(game)) === std.Y) {
    if (std.eq2(std.getn(game, F_gstate), GAME_OVER)) {
      k.div_add(b, std.U, 0, 50, std.al, d_rematch_F, 0, [std.addr(game)]);
    } else if (std.eq2(std.getn(game, F_gstate), GAME_PLAYING)) {
      k.div_add(b, std.U, 0, 50, std.al, d_timer_bar_F, 0, [std.addr(game)]);
    }
    k.div_spa(b, 0, 6, std.pt);
    k.div_add(b, std.U, 0, 50, std.al, d_exit_F, 0, [std.addr(game)]);
  }
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_rematch
//====================
function d_rematch(b, game) {
k.k_enter(b);
  d_button(b, std.addr(b.extra, std.F_box), "Rematch");
k.k_leave(b);
}


//====================
//   track_d_rematch
//====================
function track_d_rematch(b, e, game) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    if (std.getn(game, F_busy) === std.Y) {
      std.sound_play(BEEP);
    } else {
      std.remote_call(std.addr(con1), "serv_rematch", 2944720694, [std.addr(game)]);
    }
  return std.Y;
  }
  return std.N;
}

//====================
//   d_status
//====================
function d_status(b, game) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 10, std.al);
  k.div_add(b, std.U, 0, 100, std.al, d_status2_F, 0, [std.addr(game)]);
  k.div_spa(b, 0, 10, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_status2
//====================
function d_status2(b, game) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 1, 5, std.al);
  k.div_add(b, std.U, 1, 20, std.al, d_username_F, 0, [std.addr(game), 1]);
  k.div_spa(b, 1, 5, std.al);
  k.div_add(b, std.U, 1, 20, std.al, d_middle_row_F, 0, [std.addr(game)]);
  k.div_spa(b, 1, 5, std.al);
  k.div_add(b, std.U, 1, 20, std.al, d_username_F, 0, [std.addr(game), 2]);
  k.div_spa(b, 1, 5, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_timer_bar
//====================
function d_timer_bar(b, game) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_username
//====================
function d_username(b, game, playerx) {
k.k_enter(b);
  if (std.gets(game, F_players, playerx, F_name) !== null) {
    let arrow = "   ";
    let suffix = "";
    let mycolor = std.BLACK;
    var case10 = std.getn(game, F_gstate);
    if (case10 === GAME_PLAYING) {
      if (std.eq2(std.getn(game, F_turn), playerx)) {
        arrow = "âž½";
        mycolor = std.DARK_RED;
      }
    } else if (case10 === GAME_OVER) {
      if (std.eq2(std.getn(game, F_winner), playerx)) {
        suffix = "Won! ðŸŽ‰";
        mycolor = std.DARK_RED;
      }
    }
    std.draw_str(b, std.addr(b.extra, std.F_box), std.cat("", arrow, " ", std.gets(game, F_players, playerx, F_side), ": ", std.gets(game, F_players, playerx, F_name), " ", suffix
    ), { size:std.mul(b.bounds.height, 0.7), indent:std.pt_to_dots(b, 2), color:mycolor, just:std.LEFT });
  }
k.k_leave(b);
}


//====================
//   draw_games
//====================
function draw_games(b) {
k.k_enter(b);
k.div_begin(b, true, false, false, false);
  let ncol = std.U;
  let nrow = std.U;
  if (std.is_landscape(std.addr(b.extra, std.F_box)) === std.Y) {
    ncol = 6;
    nrow = 2;
  } else {
    ncol = 3;
    nrow = 4;
  }
  k.div_spa(b, 0, 6, std.pt);
  var loop11 = new std.a_loop({ limit:ncol });
  while (loop11.next()) {
    k.div_add(b, std.U, 0, 10, std.al, draw_games_cell_F, 0);
    k.div_spa(b, 0, 6, std.pt);
  }
  k.div_spa(b, 1, 6, std.pt);
  var loop12 = new std.a_loop({ limit:nrow });
  while (loop12.next()) {
    k.div_add(b, std.U, 1, 10, std.al, draw_games_cell_F, 0);
    k.div_spa(b, 1, 6, std.pt);
  }
  k.div_end(b);
  k.draw_grid(b);
k.k_leave(b);
}


//====================
//   draw_games_cell
//====================
function draw_games_cell(b) {
  k.k_enter(b);
  d_game(b, std.addr(games, std.getn(b.extra, std.F_cell_seq)));
  k.k_leave(b);
}

//====================
//   track_draw_games
//====================
function track_draw_games(b, e) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    if (std.getn(games, std.getn(b.extra, std.F_cell_seq), F_busy) !== std.Y && std.getn(games, std.getn(b.extra, std.F_cell_seq), F_players, 1, F_userid) === std.U || std.getn(
    games, std.getn(b.extra, std.F_cell_seq), F_players, 2, F_userid) === std.U) {
      std.remote_call(std.addr(con1), "serv_join_game", 3261992235, [std.addr(games, std.getn(b.extra, std.F_cell_seq)), MY_NAME, MY_ID]);
    } else {
      std.sound_play(BEEP);
    }
  return std.Y;
  }
  return std.N;
}

//====================
//   main_draw
//====================
export function main_draw(b) {
k.k_root2(b);
k.k_enter(b);
  var case13 = std.getn(con1, std.F_client_status);
  if (case13 === std.CSTATUS_WAITING) {
    std.draw_rect(b, std.addr(b.extra, std.F_box), { color:std.MEDIUM_PURPLE });
    std.draw_str(b, std.addr(b.extra, std.F_box), "âš› Connecting to server...", { size:std.pt_to_dots(b, 50), color:std.GRAY5 });
  } else if (case13 === std.CSTATUS_CONNECTED) {
    std.draw_rect(b, std.addr(b.extra, std.F_box), { color:0x4D3F50 });
    k.k_isolate(b, b.bounds, "draw_games", draw_games_F, []);
  } else {
    std.draw_rect(b, std.addr(b.extra, std.F_box), { color:std.GRAY5 });
    std.draw_str(b, std.addr(b.extra, std.F_box), "âšœ Could not reach server", { size:std.pt_to_dots(b, 50), color:std.GRAY5 });
  }
k.k_leave(b);
}


//====================
//   are_we_in_game
//====================
function are_we_in_game(game) {
  return std.or4(std.eq4(std.getn(game, F_players, 1, F_userid), MY_ID), std.eq4(std.getn(game, F_players, 2, F_userid), MY_ID));
}


//====================
//   is_our_turn
//====================
function is_our_turn(game) {
  var case14 = std.getn(game, F_turn);
  if (case14 === 1) {
    return std.eq4(std.getn(game, F_players, 1, F_userid), MY_ID);
  } else if (case14 === 2) {
    return std.eq4(std.getn(game, F_players, 2, F_userid), MY_ID);
  } else {
    return std.N;
  }
}


//====================
//   main_init
//====================
export function main_init() {
  if (SCAFFOLDING === std.Y) {
    var loop15 = new std.a_loop({ limit:NGAMES });
    while (loop15.next()) {
    var fx = loop15.count;
      std.path_setv(M, 35, std.addr(games, fx, F_gstate), GAME_WAITING);
    }
    std.path_setv(M, 36, std.addr(con1, std.F_client_status), std.CSTATUS_CONNECTED);
    std.merge_tree(M, 39, std.tree_litP(M, 39, F_gstate, GAME_PLAYING, F_turn, 1, F_nmoves, 2), std.addr(games, 1));
    std.merge_tree(M, 40, std.tree_litP(M, 40, F_userid, MY_ID, F_name, "Fred", F_won, 0, F_side, "X"), std.addr(games, 1, F_players, 1));
    std.merge_tree(M, 41, std.tree_litP(M, 41, F_userid, 101, F_name, "Penelope", F_won, 3, F_side, "O"), std.addr(games, 1, F_players, 2));
    std.merge_tree(M, 42, std.tree_litP(M, 42, 1, 1, 3, 2), std.addr(games, 1, F_board));
    std.merge_tree(M, 45, std.tree_litP(M, 45, F_gstate, GAME_PLAYING, F_turn, 2, F_nmoves, 3), std.addr(games, 3));
    std.merge_tree(M, 46, std.tree_litP(M, 46, F_userid, 101, F_name, "Penelope", F_won, 1, F_side, "X"), std.addr(games, 3, F_players, 1));
    std.merge_tree(M, 47, std.tree_litP(M, 47, F_userid, 102, F_name, "Sydney", F_won, 0, F_side, "O"), std.addr(games, 3, F_players, 2));
    std.merge_tree(M, 48, std.tree_litP(M, 48, 1, 1, 4, 2, 7, 1), std.addr(games, 3, F_board));
    std.merge_tree(M, 51, std.tree_litP(M, 51, F_gstate, GAME_OVER, F_turn, 2, F_nmoves, 9), std.addr(games, 7));
    std.merge_tree(M, 52, std.tree_litP(M, 52, F_userid, 111, F_name, "Joe", F_won, 1, F_side, "X"), std.addr(games, 7, F_players, 1));
    std.merge_tree(M, 53, std.tree_litP(M, 53, F_userid, 103, F_name, "Maxie", F_won, 0, F_side, "O"), std.addr(games, 7, F_players, 2));
    std.merge_tree(M, 54, std.tree_litP(M, 54, 1, 1, 2, 2, 3, 1, 4, 2, 5, 1, 6, 2, 7, 1, 8, 2, 9, 1), std.addr(games, 7, F_board));
    std.merge_tree(M, 57, std.tree_litP(M, 57, F_turn, 1, F_nmoves, 0), std.addr(games, 9));
    std.merge_tree(M, 58, std.tree_litP(M, 58, F_userid, MY_ID, F_name, "Fred", F_won, 1, F_side, "X"), std.addr(games, 9, F_players, 1));
    std.merge_tree(M, 61, std.tree_litP(M, 61, F_gstate, GAME_OVER, F_turn, 2, F_nmoves, 9, F_winner, 2), std.addr(games, 12));
    std.merge_tree(M, 62, std.tree_litP(M, 62, F_userid, 111, F_name, "Poindexter", F_won, 1, F_side, "X"), std.addr(games, 12, F_players, 1));
    std.merge_tree(M, 63, std.tree_litP(M, 63, F_userid, 103, F_name, "Robert", F_won, 0, F_side, "O"), std.addr(games, 12, F_players, 2));
    std.merge_tree(M, 64, std.tree_litP(M, 64, 1, 1, 2, 2, 3, 1, 4, 2, 5, 1, 6, 2, 7, 1, 8, 2, 9, 1), std.addr(games, 12, F_board));
  } else {
    std.subscribe_start(M, 70, TIC_TAC_TOE, "ws://192.168.1.67", SERV_PORT, std.U, std.addr(games), std.addr(con1), { echo:std.Y });
  }
}

main_init();
k.rebuild_all();

</script>
</body>
</html>
