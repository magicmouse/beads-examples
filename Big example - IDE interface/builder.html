<!DOCTYPE html>
<html lang="en"> 
<head>
<meta charset="utf-8"/>
<title>builder</title>
<link rel="shortcut icon" href="favicon.ico" />
<style>
/*  this disables the annoying double click highlighting of DIV blocks  */
div { outline-style:none;}
/*  this customizes the default scrollbar appearance */
::-webkit-scrollbar { width: 12pt; }
::-webkit-scrollbar-track {
    box-shadow: inset 0 0 15px grey; 
    border-radius: 6pt; }
::-webkit-scrollbar-thumb {
    background: OliveDrab; 
    border-radius: 6pt; }
::-webkit-scrollbar-thumb:hover {
    background: Olive; }
</style>
</head>
<body style="margin:0; padding:0;">
<script type="module">
import * as std from '../../runtime/beads_std.js';
import { U, Y, N, POP, VAL, VNP, setv, gets, getn, addr } from '../../runtime/beads_std.js';
import * as str from '../../runtime/beads_str.js';
import * as k   from '../../runtime/beads_k.js';
export const CODE_HASH= 0xb3b2432;
const _M = "builder";
std.rtl_init();
std.aaaa.main_init = main_init;
std.aaaa.main_module = "builder";
std.aaaa.main_drawer = new std.a_function("builder", "main_draw", main_draw);
//------- enums
const F_intf_corner1=9007192612903410; std.g_enum_ss[9007192612903410]="intf_corner1";
std.FIELDS[F_intf_corner1] = true;
const F_intf_line_p1=9007191903395510; std.g_enum_ss[9007191903395510]="intf_line_p1";
std.FIELDS[F_intf_line_p1] = true;
const F_grad=9007193319530264; std.g_enum_ss[9007193319530264]="grad";
std.FIELDS[F_grad] = true;
const F_work_color=9007191236676521; std.g_enum_ss[9007191236676521]="work_color";
std.FIELDS[F_work_color] = true;
const R_a_var_spec=9007191094782477; std.g_enum_ss[9007191094782477]="a_var_spec";
const F_line_joint_grid=9007192515708514; std.g_enum_ss[9007192515708514]="line_joint_grid";
std.FIELDS[F_line_joint_grid] = true;
const F_dtype_choices=9007190479478291; std.g_enum_ss[9007190479478291]="dtype_choices";
std.FIELDS[F_dtype_choices] = true;
const F_intf_text_leading=9007192328640828; std.g_enum_ss[9007192328640828]="intf_text_leading";
std.FIELDS[F_intf_text_leading] = true;
const F_intf_image_orgy=9007193283025961; std.g_enum_ss[9007193283025961]="intf_image_orgy";
std.FIELDS[F_intf_image_orgy] = true;
const F_key3=9007192047265844; std.g_enum_ss[9007192047265844]="key3";
std.FIELDS[F_key3] = true;
const F_is_modal_dtype=9007190619777373; std.g_enum_ss[9007190619777373]="is_modal_dtype";
std.FIELDS[F_is_modal_dtype] = true;
const SUNIT_POINTS=9007190256942184; std.g_enum_ss[9007190256942184]="SUNIT_POINTS";
const F_intf_line_dx=9007193260411173; std.g_enum_ss[9007193260411173]="intf_line_dx";
std.FIELDS[F_intf_line_dx] = true;
const F_remote=9007190765531558; std.g_enum_ss[9007190765531558]="remote";
std.FIELDS[F_remote] = true;
const F_div_gradients=9007193884007141; std.g_enum_ss[9007193884007141]="div_gradients";
std.FIELDS[F_div_gradients] = true;
const F_prog_ver1_in=9007193927942481; std.g_enum_ss[9007193927942481]="prog_ver1_in";
std.FIELDS[F_prog_ver1_in] = true;
const F_mode_tabs=9007191324805040; std.g_enum_ss[9007191324805040]="mode_tabs";
std.FIELDS[F_mode_tabs] = true;
const F_intf_text_str=9007191483769433; std.g_enum_ss[9007191483769433]="intf_text_str";
std.FIELDS[F_intf_text_str] = true;
const F_timer_group=9007191966149517; std.g_enum_ss[9007191966149517]="timer_group";
std.FIELDS[F_timer_group] = true;
const F_work_grad=9007191710185302; std.g_enum_ss[9007191710185302]="work_grad";
std.FIELDS[F_work_grad] = true;
const FORMAT_BEADS=9007193714185134; std.g_enum_ss[9007193714185134]="FORMAT_BEADS";
const F_intf_text_html=9007190483692555; std.g_enum_ss[9007190483692555]="intf_text_html";
std.FIELDS[F_intf_text_html] = true;
const F_timer_prereq_in=9007192813364205; std.g_enum_ss[9007192813364205]="timer_prereq_in";
std.FIELDS[F_timer_prereq_in] = true;
const F_intf_line_p2=9007191886617891; std.g_enum_ss[9007191886617891]="intf_line_p2";
std.FIELDS[F_intf_line_p2] = true;
const F_rec_spec=9007193964343892; std.g_enum_ss[9007193964343892]="rec_spec";
std.FIELDS[F_rec_spec] = true;
const SUNIT_PERCENT=9007192852713232; std.g_enum_ss[9007192852713232]="SUNIT_PERCENT";
const F_div_patterns=9007193450652791; std.g_enum_ss[9007193450652791]="div_patterns";
std.FIELDS[F_div_patterns] = true;
const F_intf_line_dy=9007193243633554; std.g_enum_ss[9007193243633554]="intf_line_dy";
std.FIELDS[F_intf_line_dy] = true;
const F_prog_ver3_in=9007193406466911; std.g_enum_ss[9007193406466911]="prog_ver3_in";
std.FIELDS[F_prog_ver3_in] = true;
const F_comment=9007190295606581; std.g_enum_ss[9007190295606581]="comment";
std.FIELDS[F_comment] = true;
const R_a_choice_set=9007193148669828; std.g_enum_ss[9007193148669828]="a_choice_set";
const F_in_drag=9007192994383234; std.g_enum_ss[9007192994383234]="in_drag";
std.FIELDS[F_in_drag] = true;
const F_timer_prereq=9007190140924617; std.g_enum_ss[9007190140924617]="timer_prereq";
std.FIELDS[F_timer_prereq] = true;
const F_ball_x=9007193722039442; std.g_enum_ss[9007193722039442]="ball_x";
std.FIELDS[F_ball_x] = true;
const F_palette_action=9007190568333578; std.g_enum_ss[9007190568333578]="palette_action";
std.FIELDS[F_palette_action] = true;
const F_minval=9007191628692195; std.g_enum_ss[9007191628692195]="minval";
std.FIELDS[F_minval] = true;
const F_block_kind_grid=9007190792912901; std.g_enum_ss[9007190792912901]="block_kind_grid";
std.FIELDS[F_block_kind_grid] = true;
const F_work_grad_shape=9007192240170676; std.g_enum_ss[9007192240170676]="work_grad_shape";
std.FIELDS[F_work_grad_shape] = true;
const F_action_add=9007193082918314; std.g_enum_ss[9007193082918314]="action_add";
std.FIELDS[F_action_add] = true;
const F_intf_namelist_mru=9007191034150360; std.g_enum_ss[9007191034150360]="intf_namelist_mru";
std.FIELDS[F_intf_namelist_mru] = true;
const F_syms=9007192476812780; std.g_enum_ss[9007192476812780]="syms";
std.FIELDS[F_syms] = true;
const F_intf_text_font=9007192171585591; std.g_enum_ss[9007192171585591]="intf_text_font";
std.FIELDS[F_intf_text_font] = true;
const F_choice_func=9007193838393466; std.g_enum_ss[9007193838393466]="choice_func";
std.FIELDS[F_choice_func] = true;
const NK_IMPORT=9007193785169176; std.g_enum_ss[9007193785169176]="NK_IMPORT";
const F_intf_text_bold=9007193587428673; std.g_enum_ss[9007193587428673]="intf_text_bold";
std.FIELDS[F_intf_text_bold] = true;
const FORMAT_HTML=9007191751459116; std.g_enum_ss[9007191751459116]="FORMAT_HTML";
const F_label_func=9007191941311145; std.g_enum_ss[9007191941311145]="label_func";
std.FIELDS[F_label_func] = true;
const R_a_slider_ctl=9007193746818447; std.g_enum_ss[9007193746818447]="a_slider_ctl";
const F_intf_corner2=9007192596125791; std.g_enum_ss[9007192596125791]="intf_corner2";
std.FIELDS[F_intf_corner2] = true;
const F_intf_line_x1=9007192173117342; std.g_enum_ss[9007192173117342]="intf_line_x1";
std.FIELDS[F_intf_line_x1] = true;
const F_bar_tabs=9007192838898842; std.g_enum_ss[9007192838898842]="bar_tabs";
std.FIELDS[F_bar_tabs] = true;
const F_func_is_horz=9007193456717805; std.g_enum_ss[9007193456717805]="func_is_horz";
std.FIELDS[F_func_is_horz] = true;
const F_enumlist=9007193340117161; std.g_enum_ss[9007193340117161]="enumlist";
std.FIELDS[F_enumlist] = true;
const F_timer_func_in=9007192964496522; std.g_enum_ss[9007192964496522]="timer_func_in";
std.FIELDS[F_timer_func_in] = true;
const F_timer_nreps_in=9007193430052554; std.g_enum_ss[9007193430052554]="timer_nreps_in";
std.FIELDS[F_timer_nreps_in] = true;
const F_intf_line_angle=9007191488339436; std.g_enum_ss[9007191488339436]="intf_line_angle";
std.FIELDS[F_intf_line_angle] = true;
const F_name=9007190800402099; std.g_enum_ss[9007190800402099]="name";
std.FIELDS[F_name] = true;
const R_a_sym=9007191241707143; std.g_enum_ss[9007191241707143]="a_sym";
const F_div_assets=9007192748956565; std.g_enum_ss[9007192748956565]="div_assets";
std.FIELDS[F_div_assets] = true;
const F_color=9007193200940231; std.g_enum_ss[9007193200940231]="color";
std.FIELDS[F_color] = true;
const F_intf_text_size=9007190025849815; std.g_enum_ss[9007190025849815]="intf_text_size";
std.FIELDS[F_intf_text_size] = true;
const F_var_spec=9007191317522461; std.g_enum_ss[9007191317522461]="var_spec";
std.FIELDS[F_var_spec] = true;
const F_type=9007191793104952; std.g_enum_ss[9007191793104952]="type";
std.FIELDS[F_type] = true;
const F_intf_text_italic=9007190993669690; std.g_enum_ss[9007190993669690]="intf_text_italic";
std.FIELDS[F_intf_text_italic] = true;
const F_val_ss=9007190029927630; std.g_enum_ss[9007190029927630]="val_ss";
std.FIELDS[F_val_ss] = true;
const F_intf_line_x2=9007192156339723; std.g_enum_ss[9007192156339723]="intf_line_x2";
std.FIELDS[F_intf_line_x2] = true;
const F_initval=9007193722321953; std.g_enum_ss[9007193722321953]="initval";
std.FIELDS[F_initval] = true;
const F_default_=9007190011038358; std.g_enum_ss[9007190011038358]="default";
std.FIELDS[F_default_] = true;
const F_is_readonly=9007191412397527; std.g_enum_ss[9007191412397527]="is_readonly";
std.FIELDS[F_is_readonly] = true;
const F_is_bar_visible=9007192691497603; std.g_enum_ss[9007192691497603]="is_bar_visible";
std.FIELDS[F_is_bar_visible] = true;
const F_digits=9007193105966738; std.g_enum_ss[9007193105966738]="digits";
std.FIELDS[F_digits] = true;
const F_div_imports=9007193074694038; std.g_enum_ss[9007193074694038]="div_imports";
std.FIELDS[F_div_imports] = true;
const F_intf_line_len=9007193171615080; std.g_enum_ss[9007193171615080]="intf_line_len";
std.FIELDS[F_intf_line_len] = true;
const F_start_mouse_x=9007192913562431; std.g_enum_ss[9007192913562431]="start_mouse_x";
std.FIELDS[F_start_mouse_x] = true;
const F_val_ptr=9007191159888442; std.g_enum_ss[9007191159888442]="val_ptr";
std.FIELDS[F_val_ptr] = true;
const FUNC_SCROLL=9007190630549483; std.g_enum_ss[9007190630549483]="FUNC_SCROLL";
const F_intf_image_shrink=9007192580077405; std.g_enum_ss[9007192580077405]="intf_image_shrink";
std.FIELDS[F_intf_image_shrink] = true;
const F_intf_fill_color=9007192226200891; std.g_enum_ss[9007192226200891]="intf_fill_color";
std.FIELDS[F_intf_fill_color] = true;
const F_selx_ptr=9007193212826961; std.g_enum_ss[9007193212826961]="selx_ptr";
std.FIELDS[F_selx_ptr] = true;
const F_div_recs=9007192818873243; std.g_enum_ss[9007192818873243]="div_recs";
std.FIELDS[F_div_recs] = true;
const F_timer_start_in=9007192492351308; std.g_enum_ss[9007192492351308]="timer_start_in";
std.FIELDS[F_timer_start_in] = true;
const F_intf_text_indent=9007193212521732; std.g_enum_ss[9007193212521732]="intf_text_indent";
std.FIELDS[F_intf_text_indent] = true;
const F_intf_text_wrap=9007193657812466; std.g_enum_ss[9007193657812466]="intf_text_wrap";
std.FIELDS[F_intf_text_wrap] = true;
const F_prog_ver2_in=9007190965727562; std.g_enum_ss[9007190965727562]="prog_ver2_in";
std.FIELDS[F_prog_ver2_in] = true;
const F_rack_h=9007193055011980; std.g_enum_ss[9007193055011980]="rack_h";
std.FIELDS[F_rack_h] = true;
const WORK_EDITING=9007191138857081; std.g_enum_ss[9007191138857081]="WORK_EDITING";
const F_fontpicker_targ_ptr=9007193832701025; std.g_enum_ss[9007193832701025]="fontpicker_targ_ptr";
std.FIELDS[F_fontpicker_targ_ptr] = true;
const F_work_state=9007191720099739; std.g_enum_ss[9007191720099739]="work_state";
std.FIELDS[F_work_state] = true;
const F_nk=9007193803890755; std.g_enum_ss[9007193803890755]="nk";
std.FIELDS[F_nk] = true;
const F_intf_line_y1=9007192105859771; std.g_enum_ss[9007192105859771]="intf_line_y1";
std.FIELDS[F_intf_line_y1] = true;
const R_a_tabset=9007191267514725; std.g_enum_ss[9007191267514725]="a_tabset";
const F_intf_text_spacing=9007190534328459; std.g_enum_ss[9007190534328459]="intf_text_spacing";
std.FIELDS[F_intf_text_spacing] = true;
const F_intf_image_x=9007191085945060; std.g_enum_ss[9007191085945060]="intf_image_x";
std.FIELDS[F_intf_image_x] = true;
const F_intf_text_shrink=9007191381257199; std.g_enum_ss[9007191381257199]="intf_text_shrink";
std.FIELDS[F_intf_text_shrink] = true;
const FUNC_DRAW=9007191801225308; std.g_enum_ss[9007191801225308]="FUNC_DRAW";
const F_timer_time_grid=9007193615454524; std.g_enum_ss[9007193615454524]="timer_time_grid";
std.FIELDS[F_timer_time_grid] = true;
const R_a_asset2_spec=9007191679779692; std.g_enum_ss[9007191679779692]="a_asset2_spec";
const F_bar_tabx=9007192687900271; std.g_enum_ss[9007192687900271]="bar_tabx";
std.FIELDS[F_bar_tabx] = true;
const F_timer_group_in=9007193810461369; std.g_enum_ss[9007193810461369]="timer_group_in";
std.FIELDS[F_timer_group_in] = true;
const F_dtype=9007191915650516; std.g_enum_ss[9007191915650516]="dtype";
std.FIELDS[F_dtype] = true;
const F_maxval=9007191306035957; std.g_enum_ss[9007191306035957]="maxval";
std.FIELDS[F_maxval] = true;
const R_a_dtype_choice=9007190033684482; std.g_enum_ss[9007190033684482]="a_dtype_choice";
const F_ball_d=9007194057591822; std.g_enum_ss[9007194057591822]="ball_d";
std.FIELDS[F_ball_d] = true;
const F_intf_line_y2=9007192122637390; std.g_enum_ss[9007192122637390]="intf_line_y2";
std.FIELDS[F_intf_line_y2] = true;
const F_intf_corner3=9007192579348172; std.g_enum_ss[9007192579348172]="intf_corner3";
std.FIELDS[F_intf_corner3] = true;
const F_start_ball_x=9007190358244983; std.g_enum_ss[9007190358244983]="start_ball_x";
std.FIELDS[F_start_ball_x] = true;
const F_intf_image_y=9007191102722679; std.g_enum_ss[9007191102722679]="intf_image_y";
std.FIELDS[F_intf_image_y] = true;
const R_a_field_spec=9007193412883690; std.g_enum_ss[9007193412883690]="a_field_spec";
const F_is_stdlib=9007191242199121; std.g_enum_ss[9007191242199121]="is_stdlib";
std.FIELDS[F_is_stdlib] = true;
const F_ncorner_grid=9007191865694364; std.g_enum_ss[9007191865694364]="ncorner_grid";
std.FIELDS[F_ncorner_grid] = true;
const F_intf_image_aspect=9007194256725092; std.g_enum_ss[9007194256725092]="intf_image_aspect";
std.FIELDS[F_intf_image_aspect] = true;
const F_work_name_in=9007190166374545; std.g_enum_ss[9007190166374545]="work_name_in";
std.FIELDS[F_work_name_in] = true;
const WORK_NEW=9007190446357107; std.g_enum_ss[9007190446357107]="WORK_NEW";
const NK_PATTERN=9007192200000045; std.g_enum_ss[9007192200000045]="NK_PATTERN";
const F_fields=9007190211365693; std.g_enum_ss[9007190211365693]="fields";
std.FIELDS[F_fields] = true;
const FUNC_CALC=9007192332170887; std.g_enum_ss[9007192332170887]="FUNC_CALC";
const F_color_ptr=9007191431620178; std.g_enum_ss[9007191431620178]="color_ptr";
std.FIELDS[F_color_ptr] = true;
const R_a_sect_div=9007190613587575; std.g_enum_ss[9007190613587575]="a_sect_div";
const F_skip_reset=9007190744266519; std.g_enum_ss[9007190744266519]="skip_reset";
std.FIELDS[F_skip_reset] = true;
const F_symp=9007192527145637; std.g_enum_ss[9007192527145637]="symp";
std.FIELDS[F_symp] = true;
const R_a_rec_spec=9007192818448036; std.g_enum_ss[9007192818448036]="a_rec_spec";
const F_div_const=9007193691272847; std.g_enum_ss[9007193691272847]="div_const";
std.FIELDS[F_div_const] = true;
const F_div_recs2=9007190674938635; std.g_enum_ss[9007190674938635]="div_recs2";
std.FIELDS[F_div_recs2] = true;
const COMPACT_SIZE=9007192111913864; std.g_enum_ss[9007192111913864]="COMPACT_SIZE";
const F_intf_image_indent=9007192186416242; std.g_enum_ss[9007192186416242]="intf_image_indent";
std.FIELDS[F_intf_image_indent] = true;
const F_dtype_set_tabs=9007190320720572; std.g_enum_ss[9007190320720572]="dtype_set_tabs";
std.FIELDS[F_dtype_set_tabs] = true;
const F_sunit=9007190049348627; std.g_enum_ss[9007190049348627]="sunit";
std.FIELDS[F_sunit] = true;
const F_color_val=9007193610054711; std.g_enum_ss[9007193610054711]="color_val";
std.FIELDS[F_color_val] = true;
const F_intf_font=9007190148880879; std.g_enum_ss[9007190148880879]="intf_font";
std.FIELDS[F_intf_font] = true;
const F_old_val=9007191036406101; std.g_enum_ss[9007191036406101]="old_val";
std.FIELDS[F_old_val] = true;
const R_a_colorchart_state=9007193055989359; std.g_enum_ss[9007193055989359]="a_colorchart_state";
const F_intf_text_hideu=9007192828920889; std.g_enum_ss[9007192828920889]="intf_text_hideu";
std.FIELDS[F_intf_text_hideu] = true;
const FORMAT_HEX=9007193301062174; std.g_enum_ss[9007193301062174]="FORMAT_HEX";
const F_selx=9007192042983600; std.g_enum_ss[9007192042983600]="selx";
std.FIELDS[F_selx] = true;
const R_a_doc=9007193967503790; std.g_enum_ss[9007193967503790]="a_doc";
const F_is_expanded=9007193224900440; std.g_enum_ss[9007193224900440]="is_expanded";
std.FIELDS[F_is_expanded] = true;
const F_fill_choices=9007193890499310; std.g_enum_ss[9007193890499310]="fill_choices";
std.FIELDS[F_fill_choices] = true;
const F_intf_corner4=9007192562570553; std.g_enum_ss[9007192562570553]="intf_corner4";
std.FIELDS[F_intf_corner4] = true;
const F_ss_driven=9007194207617541; std.g_enum_ss[9007194207617541]="ss_driven";
std.FIELDS[F_ss_driven] = true;
const F_work_nk=9007191349546857; std.g_enum_ss[9007191349546857]="work_nk";
std.FIELDS[F_work_nk] = true;
const F_timer_nreps_grid=9007190075600629; std.g_enum_ss[9007190075600629]="timer_nreps_grid";
std.FIELDS[F_timer_nreps_grid] = true;
const F_intf_image_orgx=9007193266248342; std.g_enum_ss[9007193266248342]="intf_image_orgx";
std.FIELDS[F_intf_image_orgx] = true;
const F_add_expr=9007191338805683; std.g_enum_ss[9007191338805683]="add_expr";
std.FIELDS[F_add_expr] = true;
const F_asset_spec=9007192159896358; std.g_enum_ss[9007192159896358]="asset_spec";
std.FIELDS[F_asset_spec] = true;
const F_is_doc_open=9007190804128894; std.g_enum_ss[9007190804128894]="is_doc_open";
std.FIELDS[F_is_doc_open] = true;
const F_intf_stroke_color=9007192874305302; std.g_enum_ss[9007192874305302]="intf_stroke_color";
std.FIELDS[F_intf_stroke_color] = true;
const F_work_sym=9007190819645661; std.g_enum_ss[9007190819645661]="work_sym";
std.FIELDS[F_work_sym] = true;
const F_val_list=9007192993813256; std.g_enum_ss[9007192993813256]="val_list";
std.FIELDS[F_val_list] = true;
const F_line_cap_grid=9007191055038750; std.g_enum_ss[9007191055038750]="line_cap_grid";
std.FIELDS[F_line_cap_grid] = true;
const F_intf_bbox=9007192170568813; std.g_enum_ss[9007192170568813]="intf_bbox";
std.FIELDS[F_intf_bbox] = true;
const F_div_units=9007190628457363; std.g_enum_ss[9007190628457363]="div_units";
std.FIELDS[F_div_units] = true;
const R_a_slot=9007193235264524; std.g_enum_ss[9007193235264524]="a_slot";
const F_intf_image_angle=9007191502443023; std.g_enum_ss[9007191502443023]="intf_image_angle";
std.FIELDS[F_intf_image_angle] = true;
const F_intf_image_grow=9007191331327591; std.g_enum_ss[9007191331327591]="intf_image_grow";
std.FIELDS[F_intf_image_grow] = true;
const F_div_fonts=9007191198555166; std.g_enum_ss[9007191198555166]="div_fonts";
std.FIELDS[F_div_fonts] = true;
const F_work_grad_stopx=9007191494511041; std.g_enum_ss[9007191494511041]="work_grad_stopx";
std.FIELDS[F_work_grad_stopx] = true;
const F_name_in=9007191478715003; std.g_enum_ss[9007191478715003]="name_in";
std.FIELDS[F_name_in] = true;
const F_doc_path=9007190640223956; std.g_enum_ss[9007190640223956]="doc_path";
std.FIELDS[F_doc_path] = true;
const F_initval_in=9007190429835109; std.g_enum_ss[9007190429835109]="initval_in";
std.FIELDS[F_initval_in] = true;
const NK_FONT=9007192463955020; std.g_enum_ss[9007192463955020]="NK_FONT";
const R_a_font_spec=9007192469652721; std.g_enum_ss[9007192469652721]="a_font_spec";
const F_work_var=9007190354776259; std.g_enum_ss[9007190354776259]="work_var";
std.FIELDS[F_work_var] = true;
const F_const_choices=9007193128810244; std.g_enum_ss[9007193128810244]="const_choices";
std.FIELDS[F_const_choices] = true;
const F_action_del=9007192252848112; std.g_enum_ss[9007192252848112]="action_del";
std.FIELDS[F_action_del] = true;
const F_prompt=9007190964804582; std.g_enum_ss[9007190964804582]="prompt";
std.FIELDS[F_prompt] = true;
const R_a_color_ctl=9007190849601625; std.g_enum_ss[9007190849601625]="a_color_ctl";
const R_a_global=9007190661834247; std.g_enum_ss[9007190661834247]="a_global";
const F_intf_corners=9007193653115788; std.g_enum_ss[9007193653115788]="intf_corners";
std.FIELDS[F_intf_corners] = true;
const F_enabled=9007190189270801; std.g_enum_ss[9007190189270801]="enabled";
std.FIELDS[F_enabled] = true;
const F_prog_title_in=9007191849719689; std.g_enum_ss[9007191849719689]="prog_title_in";
std.FIELDS[F_prog_title_in] = true;
const F_font_exp=9007193525095865; std.g_enum_ss[9007193525095865]="font_exp";
std.FIELDS[F_font_exp] = true;
const F_nrows=9007194105500079; std.g_enum_ss[9007194105500079]="nrows";
std.FIELDS[F_nrows] = true;
const F_skip_expr=9007190927434687; std.g_enum_ss[9007190927434687]="skip_expr";
std.FIELDS[F_skip_expr] = true;
const F_palette_ferrari_selx=9007194183737158; std.g_enum_ss[9007194183737158]="palette_ferrari_selx";
std.FIELDS[F_palette_ferrari_selx] = true;
const F_text_size_grid=9007191615415178; std.g_enum_ss[9007191615415178]="text_size_grid";
std.FIELDS[F_text_size_grid] = true;
const F_format=9007190044619795; std.g_enum_ss[9007190044619795]="format";
std.FIELDS[F_format] = true;
const F_exportf=9007194179201680; std.g_enum_ss[9007194179201680]="exportf";
std.FIELDS[F_exportf] = true;
const F_block_slice_grid=9007191143201609; std.g_enum_ss[9007191143201609]="block_slice_grid";
std.FIELDS[F_block_slice_grid] = true;
const FULL_SIZE=9007192426333106; std.g_enum_ss[9007192426333106]="FULL_SIZE";
const F_div_vars=9007192688142666; std.g_enum_ss[9007192688142666]="div_vars";
std.FIELDS[F_div_vars] = true;
const F_is_folder=9007192134898621; std.g_enum_ss[9007192134898621]="is_folder";
std.FIELDS[F_is_folder] = true;
const F_func_kind=9007193888035121; std.g_enum_ss[9007193888035121]="func_kind";
std.FIELDS[F_func_kind] = true;
const F_dtype_slot=9007193264642165; std.g_enum_ss[9007193264642165]="dtype_slot";
std.FIELDS[F_dtype_slot] = true;
const F_step=9007190441390546; std.g_enum_ss[9007190441390546]="step";
std.FIELDS[F_step] = true;
const R_a_asset_spec=9007191654844470; std.g_enum_ss[9007191654844470]="a_asset_spec";
const F_intf_opacity=9007190570383735; std.g_enum_ss[9007190570383735]="intf_opacity";
std.FIELDS[F_intf_opacity] = true;
const F_local=9007192237567243; std.g_enum_ss[9007192237567243]="local";
std.FIELDS[F_local] = true;
const F_assets2=9007193998476961; std.g_enum_ss[9007193998476961]="assets2";
std.FIELDS[F_assets2] = true;
const R_a_func_spec=9007191457942492; std.g_enum_ss[9007191457942492]="a_func_spec";
const F_font_net=9007194152677993; std.g_enum_ss[9007194152677993]="font_net";
std.FIELDS[F_font_net] = true;
const F_prog_kind=9007192857070479; std.g_enum_ss[9007192857070479]="prog_kind";
std.FIELDS[F_prog_kind] = true;
const F_palette_targ_ptr=9007190070394041; std.g_enum_ss[9007190070394041]="palette_targ_ptr";
std.FIELDS[F_palette_targ_ptr] = true;
const FUNC_SLICE=9007191215348072; std.g_enum_ss[9007191215348072]="FUNC_SLICE";
const F_key1=9007192080821082; std.g_enum_ss[9007192080821082]="key1";
std.FIELDS[F_key1] = true;
const FUNC_REPORT=9007191329825320; std.g_enum_ss[9007191329825320]="FUNC_REPORT";
const F_prog_kind_choices=9007190322778984; std.g_enum_ss[9007190322778984]="prog_kind_choices";
std.FIELDS[F_prog_kind_choices] = true;
const F_draw_tools=9007191106930710; std.g_enum_ss[9007191106930710]="draw_tools";
std.FIELDS[F_draw_tools] = true;
const F_block_add_unit_grid=9007193250560165; std.g_enum_ss[9007193250560165]="block_add_unit_grid";
std.FIELDS[F_block_add_unit_grid] = true;
const F_intf_image_corner=9007193175812089; std.g_enum_ss[9007193175812089]="intf_image_corner";
std.FIELDS[F_intf_image_corner] = true;
const F_is_open=9007191493292457; std.g_enum_ss[9007191493292457]="is_open";
std.FIELDS[F_is_open] = true;
const F_intf_line_thick=9007190473568682; std.g_enum_ss[9007190473568682]="intf_line_thick";
std.FIELDS[F_intf_line_thick] = true;
const F_subrec=9007190562556692; std.g_enum_ss[9007190562556692]="subrec";
std.FIELDS[F_subrec] = true;
const F_work_color_ctl=9007190409376203; std.g_enum_ss[9007190409376203]="work_color_ctl";
std.FIELDS[F_work_color_ctl] = true;
const F_key2=9007192064043463; std.g_enum_ss[9007192064043463]="key2";
std.FIELDS[F_key2] = true;
const F_func_spec=9007192650767468; std.g_enum_ss[9007192650767468]="func_spec";
std.FIELDS[F_func_spec] = true;
const F_proj_tabs=9007190146090704; std.g_enum_ss[9007190146090704]="proj_tabs";
std.FIELDS[F_proj_tabs] = true;
const F_work_grad_dir=9007193051591146; std.g_enum_ss[9007193051591146]="work_grad_dir";
std.FIELDS[F_work_grad_dir] = true;
const F_label_list=9007191676280395; std.g_enum_ss[9007191676280395]="label_list";
std.FIELDS[F_label_list] = true;
const F_div_colors=9007193727526080; std.g_enum_ss[9007193727526080]="div_colors";
std.FIELDS[F_div_colors] = true;
const F_fpath=9007190067707713; std.g_enum_ss[9007190067707713]="fpath";
std.FIELDS[F_fpath] = true;
const F_timer_how_timed=9007193553279956; std.g_enum_ss[9007193553279956]="timer_how_timed";
std.FIELDS[F_timer_how_timed] = true;
const F_prog_export_all=9007191552043755; std.g_enum_ss[9007191552043755]="prog_export_all";
std.FIELDS[F_prog_export_all] = true;
const F_text_just_grid=9007193111237367; std.g_enum_ss[9007193111237367]="text_just_grid";
std.FIELDS[F_text_just_grid] = true;
const F_action=9007192789918218; std.g_enum_ss[9007192789918218]="action";
std.FIELDS[F_action] = true;
const FUNC_GRID=9007193831253450; std.g_enum_ss[9007193831253450]="FUNC_GRID";
const F_div_enums=9007190149456718; std.g_enum_ss[9007190149456718]="div_enums";
std.FIELDS[F_div_enums] = true;
const F_color_ss=9007191662183638; std.g_enum_ss[9007191662183638]="color_ss";
std.FIELDS[F_color_ss] = true;
const F_sizing=9007191915790290; std.g_enum_ss[9007191915790290]="sizing";
std.FIELDS[F_sizing] = true;
const F_block_skip_unit_grid=9007190279940805; std.g_enum_ss[9007190279940805]="block_skip_unit_grid";
std.FIELDS[F_block_skip_unit_grid] = true;
const F_timer_start=9007191182373282; std.g_enum_ss[9007191182373282]="timer_start";
std.FIELDS[F_timer_start] = true;
const F_prog_name_in=9007193175675860; std.g_enum_ss[9007193175675860]="prog_name_in";
std.FIELDS[F_prog_name_in] = true;
const F_intf_text_color=9007191316912185; std.g_enum_ss[9007191316912185]="intf_text_color";
std.FIELDS[F_intf_text_color] = true;
const F_intf_bordpos=9007193222421159; std.g_enum_ss[9007193222421159]="intf_bordpos";
std.FIELDS[F_intf_bordpos] = true;
const WORK_CLOSED=9007192007988295; std.g_enum_ss[9007192007988295]="WORK_CLOSED";
//[reflAAA]
std.merge_lit(_M,0,std.META,_M, std.F_mod_const, "AREA_THRESHOLD", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "BEEP", std.F_vv_typek, VAL, std.TYPE_SOUND, POP, "BKINDSL_SCROLL"
, std.F_vv_typek, VAL, std.TYPE_NUM, POP, "BKINDSL_SLICE", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "BKIND_GRID", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "BKIND_HORZ", std.F_vv_typek
, VAL, std.TYPE_NUM, POP, "BKIND_PLAIN", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "BKIND_REPORT", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "BKIND_VERT", std.F_vv_typek, VAL, 
std.TYPE_NUM, POP, "BUTT_FLASH", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "BUTT_HI_BACK", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "BUTT_HI_BORD", std.F_vv_typek, VAL, std.TYPE_COLOR
, POP, "BUTT_HI_FILL", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "BUTT_HI_TEXT", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "BUTT_LO_BACK", std.F_vv_typek, VAL, std.TYPE_COLOR
, POP, "BUTT_LO_BORD", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "BUTT_LO_TEXT", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "BUTT_THICK", std.F_vv_typek, VAL, std.TYPE_NUM, POP
, "CHECKERBOARD", std.F_vv_typek, VAL, std.TYPE_IMAGE, POP, "CHIPS_PER_RAMP", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "CHIPS_PER_ROW", std.F_vv_typek, VAL, std.TYPE_NUM, POP
, "CHOICE_CORNER", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "CHOICE_V", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "CLICK", std.F_vv_typek, VAL, std.TYPE_SOUND, POP, "C_PALTEXT"
, std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "C_TAB_UND", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "C_TOOL_LABEL", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "C_TOOL_LABEL_SEL_BACK"
, std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "DEAD_COLOR", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "DEFAULT_GRADIENT", std.F_vv_rec, VAL, "a_gradient", std.F_vv_typek, VAL, 
std.TYPE_RECORD, POP, "DIMMED", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "DRAWT_IMAGE", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "DRAWT_LINE", std.F_vv_typek, VAL, std.TYPE_NUM
, POP, "DRAWT_OVAL", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "DRAWT_POLY", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "DRAWT_RECT", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "DRAWT_TEXT"
, std.F_vv_typek, VAL, std.TYPE_NUM, POP, "DROPDOWN_ARROW_BACK", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "DROPDOWN_ARROW_TEXT", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, 
"ENTRY_LO_BACK", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "ENTRY_LO_BORD", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "ENTRY_LO_TEXT", std.F_vv_typek, VAL, std.TYPE_COLOR, POP
, "ENTRY_V", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "FERRARI", std.F_vv_typek, VAL, std.TYPE_ARRAY, POP, "FERR_NCOL", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "FERR_NRAMPS"
, std.F_vv_typek, VAL, std.TYPE_NUM, POP, "FERR_NROW", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "FILL_COLOR", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "FILL_GRAD", std.F_vv_typek
, VAL, std.TYPE_NUM, POP, "FILL_TILE", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "FONTLIST", std.F_vv_typek, VAL, std.TYPE_ARRAY, POP, "FUNC_DIVIDER", std.F_vv_typek, VAL, std.TYPE_STR
, POP, "GRAD1", std.F_vv_rec, VAL, "a_gradient", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "GRAD2", std.F_vv_rec, VAL, "a_gradient", std.F_vv_typek, VAL, std.TYPE_RECORD, POP
, "GRAY8L", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "GUTTER", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "ICON_IMAGE", std.F_vv_typek, VAL, std.TYPE_IMAGE, POP, "INDENT_PER"
, std.F_vv_typek, VAL, std.TYPE_NUM, POP, "ITEM_DV", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "MODE_BUILD", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "MODE_CODE", std.F_vv_typek
, VAL, std.TYPE_NUM, POP, "MODE_DATA", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "MODE_PROJECT", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "NFONTS", std.F_vv_typek, VAL, std.TYPE_NUM
, POP, "ONESHOT_CORNER", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "PATT_CARDINAL", std.F_vv_typek, VAL, std.TYPE_PATTERN, POP, "PATT_RANGE_0_100", std.F_vv_typek, VAL, std.TYPE_PATTERN
, POP, "PICKER_COLOR_TABS", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "PICKER_FONT_TABS", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "SCAFFOLDING", std.F_vv_typek, VAL, std.TYPE_YESNO
, POP, "SECTD_BACK", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "SECTION_V", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "SET2", std.F_vv_rec, VAL, "a_slot", std.F_vv_typek, VAL, 
std.TYPE_RECORD, POP, "SLIDER_CORNER", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "TAB", std.F_vv_typek, VAL, std.TYPE_STR, POP, "TABV", std.F_vv_typek, VAL, std.TYPE_NUM, POP
, "TAB_BORD", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "TAB_CORNER", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "TAB_HI_BACK", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "TAB_HI_BORD"
, std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "TAB_HI_TEXT", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "TAB_LO_BACK", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "TAB_LO_BORD"
, std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "TAB_LO_TEXT", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "TAB_UND", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "TARG_WIDTH", std.F_vv_typek
, VAL, std.TYPE_NUM, POP, "THUD", std.F_vv_typek, VAL, std.TYPE_SOUND, POP, "TOGGLE_CORNER", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "TOOL_ENTRYBOX", std.F_vv_typek, VAL, 
std.TYPE_NUM, POP, "TOOL_LABEL", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "TOOL_LINDENT", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "TOOL_MID_INDENT", std.F_vv_typek, VAL, std.TYPE_NUM
, POP, "TOOL_RINDENT", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "TOOL_ROWV", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "TOOL_TSIZE", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "TRACE_COLORS"
, std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "TRACE_CPICK", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "TRACE_FUDGE", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "TRACE_GRAD", 
std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "TRACE_HOTSPOT", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "TRACE_INDICES", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "TRACE_ONESHOT"
, std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "TRACE_PALETTE", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "TRACE_SIZING", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "TRACE_SLIDER"
, std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "TRACE_STOPS", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "TRACE_VALIDATE", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "TRACE_WORK"
, std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "TYPE_TO_STR", std.F_vv_typek, VAL, std.TYPE_ARRAY, POP, "UNIT_AL", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "UNIT_PT", std.F_vv_typek
, VAL, std.TYPE_NUM, POP, "UNIT_PX", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "hue_fudge", std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, std.F_mod_enums, "COMPACT_SIZE", VAL, 
COMPACT_SIZE, "FORMAT_BEADS", VAL, FORMAT_BEADS, "FORMAT_HEX", VAL, FORMAT_HEX, "FORMAT_HTML", VAL, FORMAT_HTML, "FULL_SIZE", VAL, FULL_SIZE, "FUNC_CALC", VAL, FUNC_CALC, 
"FUNC_DRAW", VAL, FUNC_DRAW, "FUNC_GRID", VAL, FUNC_GRID, "FUNC_REPORT", VAL, FUNC_REPORT, "FUNC_SCROLL", VAL, FUNC_SCROLL, "FUNC_SLICE", VAL, FUNC_SLICE, "NK_FONT", VAL, 
NK_FONT, "NK_IMPORT", VAL, NK_IMPORT, "NK_PATTERN", VAL, NK_PATTERN, "SUNIT_PERCENT", VAL, SUNIT_PERCENT, "SUNIT_POINTS", VAL, SUNIT_POINTS, "WORK_CLOSED", VAL, WORK_CLOSED
, "WORK_EDITING", VAL, WORK_EDITING, "WORK_NEW", VAL, WORK_NEW, POP, std.F_mod_funcs, "add_textsize_slider", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk
, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "add_textsize_slider_2985", std.F_vv_funck
, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, POP, POP, "add_tool_bbox", std.F_vv_funck, VAL, std.FK_DRAW, POP, "add_tool_bbox_2875", std.F_vv_funck, VAL, std.FK_DRAW, POP, "add_tool_color", std.F_vv_funck, VAL, 
std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "label", std.F_vv_typek, VAL, std.TYPE_STR, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, 
std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, "a_color_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "add_tool_color_2911", std.F_vv_funck, VAL, std.FK_DRAW, 
std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "label", std.F_vv_typek, VAL, std.TYPE_STR, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn
, VAL, "ctl", std.F_vv_rec, VAL, "a_color_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "add_tool_corner", std.F_vv_funck, VAL, std.FK_DRAW, POP, "add_tool_corner_2956"
, std.F_vv_funck, VAL, std.FK_DRAW, POP, "add_tool_effects1", std.F_vv_funck, VAL, std.FK_DRAW, POP, "add_tool_effects2", std.F_vv_funck, VAL, std.FK_DRAW, POP, "add_tool_fill"
, std.F_vv_funck, VAL, std.FK_DRAW, POP, "add_tool_fill_2899", std.F_vv_funck, VAL, std.FK_DRAW, POP, "add_tool_font", std.F_vv_funck, VAL, std.FK_DRAW, POP, "add_tool_font_2919"
, std.F_vv_funck, VAL, std.FK_DRAW, POP, "add_tool_image", std.F_vv_funck, VAL, std.FK_DRAW, POP, "add_tool_image_2883", std.F_vv_funck, VAL, std.FK_DRAW, POP, "add_tool_imagef"
, std.F_vv_funck, VAL, std.FK_DRAW, POP, "add_tool_just", std.F_vv_funck, VAL, std.FK_DRAW, POP, "add_tool_just_2833", std.F_vv_funck, VAL, std.FK_DRAW, POP, "add_tool_linecap"
, std.F_vv_cat, VAL, "||line cap picker", std.F_vv_funck, VAL, std.FK_DRAW, POP, "add_tool_linecap_2815", std.F_vv_funck, VAL, std.FK_DRAW, POP, "add_tool_num", std.F_vv_funck
, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "prompt", std.F_vv_typek, VAL, std.TYPE_STR, POP, 2, std.F_vv_parmk, VAL, std.PK_POS
, std.F_vv_parmn, VAL, "data", std.F_vv_typek, VAL, std.TYPE_STR, POP, 3, std.F_vv_parmk, VAL, std.PK_NAMED, std.F_vv_parmn, VAL, "min", std.F_vv_typek, VAL, std.TYPE_NUM, POP
, 4, std.F_vv_parmk, VAL, std.PK_NAMED, std.F_vv_parmn, VAL, "max", std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, POP, "add_tool_num_2932", std.F_vv_funck, VAL, std.FK_DRAW
, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "prompt", std.F_vv_typek, VAL, std.TYPE_STR, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn
, VAL, "data", std.F_vv_typek, VAL, std.TYPE_STR, POP, 3, std.F_vv_parmk, VAL, std.PK_NAMED, std.F_vv_parmn, VAL, "min", std.F_vv_typek, VAL, std.TYPE_NUM, POP, 4, std.F_vv_parmk
, VAL, std.PK_NAMED, std.F_vv_parmn, VAL, "max", std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, POP, "add_tool_point", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk
, VAL, std.PK_POS, std.F_vv_parmn, VAL, "prompt", std.F_vv_typek, VAL, std.TYPE_STR, POP, POP, POP, "add_tool_point_3267", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms
, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "prompt", std.F_vv_typek, VAL, std.TYPE_STR, POP, POP, POP, "add_tool_slider", std.F_vv_funck, VAL, std.FK_DRAW, 
std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "add_tool_slider_2942"
, std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, 
std.TYPE_RECORD, POP, POP, POP, "add_tool_str", std.F_vv_funck, VAL, std.FK_DRAW, POP, "add_tool_str_2891", std.F_vv_funck, VAL, std.FK_DRAW, POP, "angle_to_graddir", std.F_vv_cat
, VAL, "||whenever we change the work_grad.grad_angle", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec
, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "apn", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn
, VAL, "ss", std.F_vv_typek, VAL, std.TYPE_STR, POP, POP, POP, "app", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, 
"ss", std.F_vv_typek, VAL, std.TYPE_STR, POP, 2, std.F_vv_parmk, VAL, std.PK_NAMED, std.F_vv_parmn, VAL, "add_nl", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, POP, POP, "app_strlit"
, std.F_vv_cat, VAL, "||append a string literal", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ss", std.F_vv_typek
, VAL, std.TYPE_STR, POP, POP, POP, "blank", std.F_vv_funck, VAL, std.FK_CALC, POP, "build_namelist", std.F_vv_funck, VAL, std.FK_CALC, POP, "butt_block_add", std.F_vv_funck
, VAL, std.FK_DRAW, POP, "butt_block_dup", std.F_vv_funck, VAL, std.FK_DRAW, POP, "butt_block_skip", std.F_vv_funck, VAL, std.FK_DRAW, POP, "butt_grad_stop", std.F_vv_funck
, VAL, std.FK_DRAW, POP, "butt_modal_cancel", std.F_vv_funck, VAL, std.FK_DRAW, POP, "butt_work_cancel", std.F_vv_cat, VAL, "||work area cancel / ok buttons", std.F_vv_funck
, VAL, std.FK_DRAW, POP, "calc_ball_x", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, 
"a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, std.F_vv_typek, VAL, std.TYPE_NUM, POP, "choice_get_selx", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms
, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "c", std.F_vv_rec, VAL, "a_choice_set", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, std.F_vv_typek, VAL, std.TYPE_NUM
, POP, "choice_set_selx", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "c", std.F_vv_rec, VAL, "a_choice_set"
, std.F_vv_typek, VAL, std.TYPE_RECORD, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "newval", std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, POP, "clear_band_selection"
, std.F_vv_funck, VAL, std.FK_CALC, POP, "clear_dtype_slots", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "slotx"
, std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, POP, "clear_work_name", std.F_vv_funck, VAL, std.FK_CALC, POP, "color_ctl_getv", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms
, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, "a_color_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, std.F_vv_typek, VAL, std.TYPE_COLOR
, POP, "color_ctl_setss", std.F_vv_cat, VAL, "||set a color control by name priority", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS
, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, "a_color_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "name", 
std.F_vv_typek, VAL, std.TYPE_STR, POP, 3, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "val", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, POP, POP, "color_ctl_setv"
, std.F_vv_cat, VAL, "||set a color control value", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec
, VAL, "a_color_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "val", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, POP
, POP, "compare_slots", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "a", std.F_vv_rec, VAL, "a_slot", std.F_vv_typek
, VAL, std.TYPE_RECORD, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "b", std.F_vv_rec, VAL, "a_slot", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, std.F_vv_typek
, VAL, std.TYPE_NUM, POP, "d_arrow_down", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "V", std.F_vv_typek, VAL, 
std.TYPE_NUM, POP, POP, POP, "d_asset_path", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "fpath", std.F_vv_typek
, VAL, std.TYPE_STR, POP, POP, POP, "d_asset_spec", std.F_vv_cat, VAL, "||draw a asset_spec2 in the toolbar list", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk
, VAL, std.PK_POS, std.F_vv_parmn, VAL, "localfolder", std.F_vv_typek, VAL, std.TYPE_STR, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "item", std.F_vv_rec
, VAL, "a_asset2_spec", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_asset_spec_2177", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, 
std.PK_POS, std.F_vv_parmn, VAL, "localfolder", std.F_vv_typek, VAL, std.TYPE_STR, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "item", std.F_vv_rec, VAL, 
"a_asset2_spec", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_asset_spec_2191", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS
, std.F_vv_parmn, VAL, "localfolder", std.F_vv_typek, VAL, std.TYPE_STR, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "item", std.F_vv_rec, VAL, "a_asset2_spec"
, std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_asset_spec_2194", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn
, VAL, "localfolder", std.F_vv_typek, VAL, std.TYPE_STR, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "item", std.F_vv_rec, VAL, "a_asset2_spec", std.F_vv_typek
, VAL, std.TYPE_RECORD, POP, POP, POP, "d_botbar", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_color_sample", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_color_sample_3410", std.F_vv_funck
, VAL, std.FK_DRAW, POP, "d_color_spec", std.F_vv_cat, VAL, "||draw a color item in the toolbar list", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, 
std.PK_POS, std.F_vv_parmn, VAL, "sym", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_color_spec_2233", std.F_vv_funck, VAL, std.FK_DRAW
, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "sym", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_color_spec_2237"
, std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "sym", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, POP, POP, "d_data_editarea", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_data_editarea_1178", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_data_recpick", std.F_vv_funck, VAL, 
std.FK_DRAW, POP, "d_div_add", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "div", std.F_vv_rec, VAL, "a_sect_div"
, std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_div_del", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, 
"div", std.F_vv_rec, VAL, "a_sect_div", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_double_arrows", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk
, VAL, std.PK_POS, std.F_vv_parmn, VAL, "V", std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, POP, "d_dtriangle", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk
, VAL, std.PK_POS, std.F_vv_parmn, VAL, "expandf", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "indentx", std.F_vv_typek
, VAL, std.TYPE_NUM, POP, 3, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "indenty", std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, POP, "d_dtype_picker", std.F_vv_funck
, VAL, std.FK_DRAW, POP, "d_dtype_picker_1070", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_enum_spec", std.F_vv_cat, VAL, "||draw a enum item in the toolbar list", std.F_vv_funck
, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "sym", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP
, POP, "d_enum_spec_2222", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "sym", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek
, VAL, std.TYPE_RECORD, POP, POP, POP, "d_ferrari_grid", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_font_example", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk
, VAL, std.PK_POS, std.F_vv_parmn, VAL, "fontname", std.F_vv_typek, VAL, std.TYPE_STR, POP, POP, POP, "d_font_example_4239", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms
, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "fontname", std.F_vv_typek, VAL, std.TYPE_STR, POP, POP, POP, "d_font_example_4242", std.F_vv_funck, VAL, std.FK_DRAW
, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "fontname", std.F_vv_typek, VAL, std.TYPE_STR, POP, POP, POP, "d_gradient_bar", std.F_vv_funck, VAL, 
std.FK_DRAW, POP, "d_gradient_kind_assy", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_gradient_sample", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_gradient_spec", std.F_vv_cat
, VAL, "||draw a gradient item in the toolbar section", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "sym", std.F_vv_rec
, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_gradient_spec_2250", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS
, std.F_vv_parmn, VAL, "sym", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_gradient_spec_2252", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms
, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "sym", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_gutter", std.F_vv_funck
, VAL, std.FK_DRAW, POP, "d_modal_dtype_picker", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_name_close", std.F_vv_cat, VAL, "||program name and close button", std.F_vv_funck
, VAL, std.FK_DRAW, POP, "d_name_close_2731", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_name_close_2733", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_name_entry", std.F_vv_cat
, VAL, "||name entry row", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "field", std.F_vv_rec, VAL, "a_input_field"
, std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_name_entry_2748", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn
, VAL, "field", std.F_vv_rec, VAL, "a_input_field", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_name_entry_2750", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms
, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "field", std.F_vv_rec, VAL, "a_input_field", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_namelist", 
std.F_vv_cat, VAL, "||uses sorted_syms, which points to the subset of the namelist", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_namelist_butts", std.F_vv_funck, VAL, std.FK_DRAW
, POP, "d_oneshot", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "prompt", std.F_vv_typek, VAL, std.TYPE_STR, POP
, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "action", std.F_vv_typek, VAL, std.TYPE_FUNC, POP, POP, POP, "d_prog_version", std.F_vv_funck, VAL, std.FK_DRAW, POP
, "d_prog_version_2713", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_prog_version_2716", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_prog_version_2718", std.F_vv_funck, VAL, std.FK_DRAW
, POP, "d_prog_version_2720", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_prog_version_2722", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_prog_version_2724", std.F_vv_funck, VAL, 
std.FK_DRAW, POP, "d_pulldown", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "slotx", std.F_vv_typek, VAL, std.TYPE_NUM
, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "label", std.F_vv_typek, VAL, std.TYPE_STR, POP, POP, POP, "d_pulldown_1252", std.F_vv_funck, VAL, std.FK_DRAW
, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "slotx", std.F_vv_typek, VAL, std.TYPE_NUM, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn
, VAL, "label", std.F_vv_typek, VAL, std.TYPE_STR, POP, POP, POP, "d_rec_field", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn
, VAL, "nlev", std.F_vv_typek, VAL, std.TYPE_NUM, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "field", std.F_vv_rec, VAL, "a_field_spec", std.F_vv_typek, VAL, 
std.TYPE_RECORD, POP, POP, POP, "d_rec_name", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "nlev", std.F_vv_typek
, VAL, std.TYPE_NUM, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "name", std.F_vv_typek, VAL, std.TYPE_STR, POP, POP, POP, "d_recent", std.F_vv_cat, VAL, 
"||show recent projects", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_resetdot", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn
, VAL, "ctl", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_sectdiv", std.F_vv_cat, VAL, "||draw section divider", std.F_vv_funck
, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "div", std.F_vv_rec, VAL, "a_sect_div", std.F_vv_typek, VAL, std.TYPE_RECORD, POP
, POP, POP, "d_sectdivA", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "div", std.F_vv_rec, VAL, "a_sect_div"
, std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_sectdivB", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, 
"div", std.F_vv_rec, VAL, "a_sect_div", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_sectprompt", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk
, VAL, std.PK_POS, std.F_vv_parmn, VAL, "prompt", std.F_vv_typek, VAL, std.TYPE_STR, POP, POP, POP, "d_slice_stack", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_slider_assy"
, std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, 
std.TYPE_RECORD, POP, POP, POP, "d_slider_minus", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec
, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_slider_plus", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS
, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_slider_rack", std.F_vv_cat, VAL, "||draw slider rack and ball"
, std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, 
std.TYPE_RECORD, POP, POP, POP, "d_stop_icon", std.F_vv_cat, VAL, "||draw the little movable icon for gradient stops", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, 
std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "bar", std.F_vv_rec, VAL, "a_rect", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn
, VAL, "bot", std.F_vv_rec, VAL, "a_rect", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, 3, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "bandx|index of band", std.F_vv_typek
, VAL, std.TYPE_NUM, POP, 4, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "countx|index as stored in g_stop_centerx, etc.", std.F_vv_typek, VAL, std.TYPE_NUM, POP
, 5, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "hilite", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, POP, POP, "d_timer_interval", std.F_vv_funck, VAL, std.FK_DRAW
, POP, "d_timer_interval_2433", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_timer_rep", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_timer_rep_2418", std.F_vv_funck, VAL, std.FK_DRAW
, POP, "d_timer_rep_2422", std.F_vv_funck, VAL, std.FK_DRAW, POP, "d_var_summary", std.F_vv_cat, VAL, "||draw a const or var in the toolbar list", std.F_vv_funck, VAL, std.FK_DRAW
, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "sym|symbol being drawn", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP
, POP, "d_work_dtype", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "spec", std.F_vv_rec, VAL, "a_var_spec", 
std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_work_var", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, 
"spec", std.F_vv_rec, VAL, "a_var_spec", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_work_var_1210", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk
, VAL, std.PK_POS, std.F_vv_parmn, VAL, "spec", std.F_vv_rec, VAL, "a_var_spec", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_work_var_1212", std.F_vv_funck, VAL, 
std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "spec", std.F_vv_rec, VAL, "a_var_spec", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP
, POP, "d_work_var_1216", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "spec", std.F_vv_rec, VAL, "a_var_spec"
, std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_work_var_1218", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn
, VAL, "spec", std.F_vv_rec, VAL, "a_var_spec", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_work_var_1220", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1
, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "spec", std.F_vv_rec, VAL, "a_var_spec", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_work_var_hdr", std.F_vv_funck
, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "spec", std.F_vv_rec, VAL, "a_var_spec", std.F_vv_typek, VAL, std.TYPE_RECORD, POP
, POP, POP, "d_work_var_hdr_1193", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "spec", std.F_vv_rec, VAL, "a_var_spec"
, std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_work_var_hdr_1199", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn
, VAL, "spec", std.F_vv_rec, VAL, "a_var_spec", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "d_work_var_hdr_1202", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms
, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "spec", std.F_vv_rec, VAL, "a_var_spec", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "default_linear_ctl"
, std.F_vv_cat, VAL, "||set work controls to default values", std.F_vv_funck, VAL, std.FK_CALC, POP, "default_radial_ctl", std.F_vv_cat, VAL, "||set work controls to default values"
, std.F_vv_funck, VAL, std.FK_CALC, POP, "delta_const_choices", std.F_vv_funck, VAL, std.FK_CALC, POP, "delta_grad_pos", std.F_vv_cat, VAL, "||user just changed a gradient stop pos"
, std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, 
std.TYPE_RECORD, POP, POP, POP, "do_block_add", std.F_vv_funck, VAL, std.FK_CALC, POP, "do_block_del", std.F_vv_funck, VAL, std.FK_CALC, POP, "do_block_dup", std.F_vv_funck
, VAL, std.FK_CALC, POP, "do_block_skip", std.F_vv_funck, VAL, std.FK_CALC, POP, "do_close_doc", std.F_vv_funck, VAL, std.FK_CALC, POP, "do_color_add", std.F_vv_cat, VAL, 
"||add a new color", std.F_vv_funck, VAL, std.FK_CALC, POP, "do_color_edit", std.F_vv_cat, VAL, "||edit currently selected color", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms
, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "sym", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "do_color_work_init", std.F_vv_funck
, VAL, std.FK_CALC, POP, "do_const_add", std.F_vv_funck, VAL, std.FK_CALC, POP, "do_const_edit", std.F_vv_cat, VAL, "||edit selected item", std.F_vv_funck, VAL, std.FK_CALC
, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "sym", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "do_enum_add"
, std.F_vv_cat, VAL, "||add a new enum", std.F_vv_funck, VAL, std.FK_CALC, POP, "do_enum_edit", std.F_vv_cat, VAL, "||edit currently selected enum", std.F_vv_funck, VAL, std.FK_CALC
, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "sym", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "do_gradient_add"
, std.F_vv_funck, VAL, std.FK_CALC, POP, "do_gradient_edit", std.F_vv_cat, VAL, "||edit currently selected enum", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk
, VAL, std.PK_POS, std.F_vv_parmn, VAL, "sym", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "do_lang", std.F_vv_funck, VAL, std.FK_CALC
, POP, "do_modal_cancel", std.F_vv_funck, VAL, std.FK_CALC, POP, "do_name_update", std.F_vv_funck, VAL, std.FK_CALC, POP, "do_namelist_add", std.F_vv_cat, VAL, "||start work on a new declaration"
, std.F_vv_funck, VAL, std.FK_CALC, POP, "do_namelist_del", std.F_vv_funck, VAL, std.FK_CALC, POP, "do_namelist_dup", std.F_vv_funck, VAL, std.FK_CALC, POP, "do_open", std.F_vv_funck
, VAL, std.FK_CALC, POP, "do_quit", std.F_vv_funck, VAL, std.FK_CALC, POP, "do_slider_minus", std.F_vv_cat, VAL, "||action function when minus button is pressed", std.F_vv_funck
, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "shift", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, POP, POP, "do_slider_plus", std.F_vv_funck, VAL, std.FK_CALC
, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, 2, std.F_vv_parmk
, VAL, std.PK_POS, std.F_vv_parmn, VAL, "shift", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, POP, POP, "do_stop_add", std.F_vv_cat, VAL, "||add another gradient stop", std.F_vv_funck
, VAL, std.FK_CALC, POP, "do_stop_del", std.F_vv_cat, VAL, "||delete gradient stop", std.F_vv_funck, VAL, std.FK_CALC, POP, "do_var_add", std.F_vv_funck, VAL, std.FK_CALC, POP
, "do_var_edit", std.F_vv_cat, VAL, "||edit selected item", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "sym"
, std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "do_work_cancel", std.F_vv_cat, VAL, "||end work on a new declaration", std.F_vv_funck, VAL, 
std.FK_CALC, POP, "do_work_ok", std.F_vv_cat, VAL, "||user is finishing data entry of a named item", std.F_vv_funck, VAL, std.FK_CALC, POP, "do_worksym_del", std.F_vv_cat, VAL, 
"||del currently selected color/gradient/etc.", std.F_vv_funck, VAL, std.FK_CALC, POP, "draw_1_toggle", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk
, VAL, std.PK_POS, std.F_vv_parmn, VAL, "label", std.F_vv_typek, VAL, std.TYPE_STR, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "result_ptr", std.F_vv_typek
, VAL, std.TYPE_PTR, POP, POP, POP, "draw_choice_grid", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "o", std.F_vv_rec
, VAL, "a_choice_set", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "textsize", std.F_vv_typek, VAL, std.TYPE_NUM, POP
, POP, POP, "draw_color_entry", std.F_vv_cat, VAL, "||draw color expression and then the chip", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS
, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, "a_color_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "draw_color_sample", std.F_vv_cat, VAL, "||draw sample to the right for color ctl"
, std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, "a_color_ctl", std.F_vv_typek, VAL, 
std.TYPE_RECORD, POP, POP, POP, "draw_dropdown", std.F_vv_cat, VAL, "||draw a dropdown menu", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS
, std.F_vv_parmn, VAL, "c", std.F_vv_rec, VAL, "a_choice_set", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "draw_entry", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms
, 1, std.F_vv_parmk, VAL, std.PK_NAMED, std.F_vv_parmn, VAL, "hint", std.F_vv_typek, VAL, std.TYPE_STR, POP, POP, POP, "draw_font_entry", std.F_vv_cat, VAL, "||draw font name and then the sample"
, std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "data", std.F_vv_rec, VAL, "a_font_spec", std.F_vv_typek, VAL, 
std.TYPE_RECORD, POP, POP, POP, "draw_font_picker", std.F_vv_funck, VAL, std.FK_DRAW, POP, "draw_font_sample", std.F_vv_cat, VAL, "||draw sample to the right for font ctl"
, std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "p", std.F_vv_rec, VAL, "a_font_spec", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, POP, POP, "draw_oneshot", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "label", std.F_vv_typek, VAL, std.TYPE_STR
, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "action", std.F_vv_typek, VAL, std.TYPE_FUNC, POP, 3, std.F_vv_parmk, VAL, std.PK_NAMED, std.F_vv_parmn, VAL, 
"enterkey", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, POP, POP, "draw_tabs", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn
, VAL, "tabs", std.F_vv_rec, VAL, "a_tabset", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "deadspace|out of 100 aliquots, how much to devote to dead space on each side"
, std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, POP, "draw_tabs2", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, 
"tabs", std.F_vv_rec, VAL, "a_tabset", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ix", std.F_vv_typek, VAL, std.TYPE_NUM
, POP, POP, POP, "draw_toggle", std.F_vv_cat, VAL, "||draw an inline toggle", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn
, VAL, "label", std.F_vv_typek, VAL, std.TYPE_STR, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "val", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, POP, POP, 
"dtype_ss", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "dtype", std.F_vv_typek, VAL, std.TYPE_ARRAY, POP, POP
, std.F_vv_typek, VAL, std.TYPE_STR, POP, "emit_func", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "sym", std.F_vv_rec
, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "emit_func_kind", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS
, std.F_vv_parmn, VAL, "sym", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "exec_action", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms
, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "label", std.F_vv_typek, VAL, std.TYPE_STR, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "action"
, std.F_vv_typek, VAL, std.TYPE_FUNC, POP, POP, POP, "ferr_closest_chip", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn
, VAL, "targcolor", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, POP, std.F_vv_typek, VAL, std.TYPE_NUM, POP, "ferr_first_ramp", std.F_vv_funck, VAL, std.FK_DRAW, POP, "ferr_first_ramp_4574"
, std.F_vv_funck, VAL, std.FK_DRAW, POP, "ferr_first_ramp_4576", std.F_vv_funck, VAL, std.FK_DRAW, POP, "ferr_hilite_chip", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms
, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "box", std.F_vv_rec, VAL, "a_rect", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "ferr_ramp", std.F_vv_funck
, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "rampx", std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, POP, "ferr_ramp_chip", std.F_vv_funck
, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "colorx", std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, POP, "ferrari_palette_draw"
, std.F_vv_funck, VAL, std.FK_DRAW, POP, "fix_band_pos", std.F_vv_cat, VAL, "||fix currently selected band position so it is sorted correctly", std.F_vv_funck, VAL, std.FK_CALC
, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "is_rightwards", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, POP, POP, "func_header", std.F_vv_funck
, VAL, std.FK_CALC, POP, "gen_code", std.F_vv_funck, VAL, std.FK_CALC, POP, "grad_work_init", std.F_vv_cat, VAL, "||init code for entering gradient editing", std.F_vv_funck
, VAL, std.FK_CALC, POP, "graphics_add_buts", std.F_vv_funck, VAL, std.FK_DRAW, POP, "html_color_chip", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk
, VAL, std.PK_POS, std.F_vv_parmn, VAL, "myslot", std.F_vv_rec, VAL, "a_slot", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "html_color_chip_4796", std.F_vv_funck, VAL, 
std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "myslot", std.F_vv_rec, VAL, "a_slot", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP
, POP, "html_color_chip_4806", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "myslot", std.F_vv_rec, VAL, "a_slot"
, std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "html_palette_draw", std.F_vv_funck, VAL, std.FK_DRAW, POP, "html_palette_init", std.F_vv_funck, VAL, std.FK_CALC, POP
, "html_palette_resize", std.F_vv_funck, VAL, std.FK_DRAW, POP, "html_slot_str", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn
, VAL, "slot", std.F_vv_rec, VAL, "a_slot", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, std.F_vv_typek, VAL, std.TYPE_STR, POP, "icon_image", std.F_vv_funck, VAL, std.FK_DRAW
, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "cell", std.F_vv_rec, VAL, "a_rect", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "icon_line"
, std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "cell", std.F_vv_rec, VAL, "a_rect", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, POP, POP, "icon_oval", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "cell", std.F_vv_rec, VAL, "a_rect"
, std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "icon_poly", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, 
"cell", std.F_vv_rec, VAL, "a_rect", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "icon_rect", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, 
std.PK_POS, std.F_vv_parmn, VAL, "cell", std.F_vv_rec, VAL, "a_rect", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "icon_text", std.F_vv_funck, VAL, std.FK_DRAW, std.F_vv_parms
, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "cell", std.F_vv_rec, VAL, "a_rect", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "intf_load_band", std.F_vv_cat
, VAL, "||user has selected a new gradient stop to edit", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "bandx"
, std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, POP, "is_indirect_type", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn
, VAL, "type", std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "main_draw", std.F_vv_funck, VAL, std.FK_DRAW, POP, "main_draw2", std.F_vv_funck
, VAL, std.FK_DRAW, POP, "main_draw3", std.F_vv_funck, VAL, std.FK_DRAW, POP, "main_draw_layer", std.F_vv_funck, VAL, std.FK_DRAW, POP, "main_init", std.F_vv_funck, VAL, std.FK_CALC
, POP, "main_modal_layer", std.F_vv_funck, VAL, std.FK_DRAW, POP, "not_yet", std.F_vv_funck, VAL, std.FK_DRAW, POP, "open_butts", std.F_vv_funck, VAL, std.FK_DRAW, POP, "open_header"
, std.F_vv_funck, VAL, std.FK_DRAW, POP, "open_header_1796", std.F_vv_funck, VAL, std.FK_DRAW, POP, "opening_menu", std.F_vv_funck, VAL, std.FK_DRAW, POP, "pick_dtype", std.F_vv_funck
, VAL, std.FK_DRAW, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "choices", std.F_vv_rec, VAL, "a_dtype_choice", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, POP, POP, "section2", std.F_vv_funck, VAL, std.FK_DRAW, POP, "section3", std.F_vv_funck, VAL, std.FK_DRAW, POP, "set_namelist_kind", std.F_vv_cat, VAL, "||called when we change the tabs for kind of object"
, std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "kind", std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, POP, "slider_getss"
, std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, 
std.TYPE_RECORD, POP, POP, std.F_vv_typek, VAL, std.TYPE_STR, POP, "slider_getv", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn
, VAL, "ctl", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, std.F_vv_typek, VAL, std.TYPE_NUM, POP, "slider_load", std.F_vv_cat, VAL, 
"||load the linked value into the slider", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, 
"a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "slider_reset", std.F_vv_cat, VAL, "||set to default value", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms
, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "slider_setv", std.F_vv_cat
, VAL, "||take the num value and set back to the underlying value, and convert to string", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS
, std.F_vv_parmn, VAL, "ctl", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, 2, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "newval"
, std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, POP, "store_graddir", std.F_vv_cat, VAL, "||whenever we change grad dir selection", std.F_vv_funck, VAL, std.FK_CALC, POP, "store_gradshape"
, std.F_vv_cat, VAL, "||whenever we change grad shape selection", std.F_vv_funck, VAL, std.FK_CALC, POP, "store_repetitions", std.F_vv_cat, VAL, "||user has clicked on one of the fixed repetition mutex buttons"
, std.F_vv_funck, VAL, std.FK_CALC, POP, "str_suffix", std.F_vv_cat, VAL, "||extract the file suffix", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, 
std.PK_POS, std.F_vv_parmn, VAL, "ss|string to process", std.F_vv_typek, VAL, std.TYPE_STR, POP, POP, std.F_vv_typek, VAL, std.TYPE_STR, POP, "symname", std.F_vv_funck, VAL, 
std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "sym", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, std.F_vv_typek
, VAL, std.TYPE_STR, POP, "sync_palette", std.F_vv_cat, VAL, "||set up the picker to point to this kind of object", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk
, VAL, std.PK_POS, std.F_vv_parmn, VAL, "targ", std.F_vv_rec, VAL, "a_color_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "toolbar", std.F_vv_funck, VAL, std.FK_DRAW
, POP, "toolbar_1935", std.F_vv_funck, VAL, std.FK_DRAW, POP, "type_of_ss", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn
, VAL, "type", std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, std.F_vv_typek, VAL, std.TYPE_STR, POP, "val_summary", std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk
, VAL, std.PK_POS, std.F_vv_parmn, VAL, "spec", std.F_vv_rec, VAL, "a_var_spec", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, std.F_vv_typek, VAL, std.TYPE_STR, POP, "validate_varname"
, std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "input", std.F_vv_rec, VAL, "a_input_field", std.F_vv_typek, VAL, 
std.TYPE_RECORD, POP, POP, std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "var_add_init", std.F_vv_funck, VAL, std.FK_CALC, POP, "var_edit_init", std.F_vv_cat, VAL, "||edit selected item"
, std.F_vv_funck, VAL, std.FK_CALC, std.F_vv_parms, 1, std.F_vv_parmk, VAL, std.PK_POS, std.F_vv_parmn, VAL, "sym", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, POP, POP, POP, std.F_mod_recs, "a_asset2_spec", std.F_vv_fields, "fpath", std.F_vv_typek, VAL, std.TYPE_STR, POP, "height", std.F_vv_typek, VAL, std.TYPE_NUM, POP, 
"name", std.F_vv_typek, VAL, std.TYPE_STR, POP, "width", std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, POP, "a_asset_spec", std.F_vv_fields, "assets2", std.F_vv_rec, VAL, "a_asset2_spec"
, std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "is_folder", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "local", std.F_vv_typek, VAL, std.TYPE_STR, POP, "remote", std.F_vv_typek
, VAL, std.TYPE_STR, POP, POP, POP, "a_choice_set", std.F_vv_fields, "choice_func", std.F_vv_typek, VAL, std.TYPE_FUNC, POP, "enabled", std.F_vv_typek, VAL, std.TYPE_YESNO
, POP, "is_open", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "label_func", std.F_vv_rec, VAL, "functype_227", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "label_list", std.F_vv_typek
, VAL, std.TYPE_ARRAY, POP, "nrows", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "selx", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "selx_ptr", std.F_vv_typek, VAL, std.TYPE_PTR, POP
, "val_list", std.F_vv_typek, VAL, std.TYPE_ARRAY, POP, POP, POP, "a_color_ctl", std.F_vv_cat, VAL, "||color control for work area", std.F_vv_fields, "color_ptr", std.F_vv_typek
, VAL, std.TYPE_PTR, POP, "color_ss", std.F_vv_typek, VAL, std.TYPE_STR, POP, "color_val", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "ss_driven", std.F_vv_typek, VAL, std.TYPE_YESNO
, POP, POP, POP, "a_colorchart_state", std.F_vv_fields, "format", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "sizing", std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, POP, "a_doc"
, std.F_vv_fields, "doc_path", std.F_vv_typek, VAL, std.TYPE_STR, POP, "is_doc_open", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "prog_export_all", std.F_vv_typek, VAL, std.TYPE_YESNO
, POP, "prog_kind", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "syms", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "a_dtype_choice", std.F_vv_fields
, "name", std.F_vv_typek, VAL, std.TYPE_STR, POP, "symp", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "type", std.F_vv_typek, VAL, std.TYPE_NUM, POP
, POP, POP, "a_field_spec", std.F_vv_fields, "dtype", std.F_vv_typek, VAL, std.TYPE_ARRAY, POP, "name", std.F_vv_typek, VAL, std.TYPE_STR, POP, "name_in", std.F_vv_rec, VAL, 
"a_input_field", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "subrec", std.F_vv_rec, VAL, "a_rec_spec", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "a_font_spec", 
std.F_vv_fields, "font_exp", std.F_vv_typek, VAL, std.TYPE_STR, POP, "font_net", std.F_vv_typek, VAL, std.TYPE_STR, POP, POP, POP, "a_func_spec", std.F_vv_fields, "func_is_horz"
, std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "func_kind", std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, POP, "a_global", std.F_vv_fields, "add_expr", std.F_vv_typek, VAL, std.TYPE_STR
, POP, "bar_tabs", std.F_vv_rec, VAL, "a_tabset", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "bar_tabx", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "block_add_unit_grid", std.F_vv_rec
, VAL, "a_choice_set", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "block_kind_grid", std.F_vv_rec, VAL, "a_choice_set", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "block_skip_unit_grid"
, std.F_vv_rec, VAL, "a_choice_set", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "block_slice_grid", std.F_vv_rec, VAL, "a_choice_set", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, "const_choices", std.F_vv_rec, VAL, "a_choice_set", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "div_assets", std.F_vv_rec, VAL, "a_sect_div", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, "div_colors", std.F_vv_rec, VAL, "a_sect_div", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "div_const", std.F_vv_rec, VAL, "a_sect_div", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, "div_enums", std.F_vv_rec, VAL, "a_sect_div", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "div_fonts", std.F_vv_rec, VAL, "a_sect_div", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, "div_gradients", std.F_vv_rec, VAL, "a_sect_div", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "div_imports", std.F_vv_rec, VAL, "a_sect_div", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, "div_patterns", std.F_vv_rec, VAL, "a_sect_div", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "div_recs", std.F_vv_rec, VAL, "a_sect_div", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, "div_recs2", std.F_vv_rec, VAL, "a_sect_div", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "div_units", std.F_vv_rec, VAL, "a_sect_div", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, "div_vars", std.F_vv_rec, VAL, "a_sect_div", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "draw_tools", std.F_vv_rec, VAL, "a_choice_set", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, "dtype_choices", std.F_vv_rec, VAL, "a_dtype_choice", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "dtype_set_tabs", std.F_vv_rec, VAL, "a_tabset", std.F_vv_typek, VAL, 
std.TYPE_RECORD, POP, "dtype_slot", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "fill_choices", std.F_vv_rec, VAL, "a_choice_set", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "fontpicker_targ_ptr"
, std.F_vv_rec, VAL, "a_font_spec", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "intf_bbox", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_bordpos", std.F_vv_typek, VAL, std.TYPE_STR
, POP, "intf_corner1", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_corner2", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_corner3", std.F_vv_typek, VAL, std.TYPE_STR, POP
, "intf_corner4", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_corners", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_fill_color", std.F_vv_rec, VAL, "a_color_ctl", std.F_vv_typek
, VAL, std.TYPE_RECORD, POP, "intf_font", std.F_vv_rec, VAL, "a_font_spec", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "intf_image_angle", std.F_vv_typek, VAL, std.TYPE_STR
, POP, "intf_image_aspect", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "intf_image_corner", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_image_grow", std.F_vv_typek, VAL, 
std.TYPE_YESNO, POP, "intf_image_indent", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_image_orgx", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_image_orgy", std.F_vv_typek
, VAL, std.TYPE_STR, POP, "intf_image_shrink", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "intf_image_x", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_image_y", std.F_vv_typek
, VAL, std.TYPE_STR, POP, "intf_line_angle", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_line_dx", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_line_dy", std.F_vv_typek
, VAL, std.TYPE_STR, POP, "intf_line_len", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_line_p1", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_line_p2", std.F_vv_typek, VAL, 
std.TYPE_STR, POP, "intf_line_thick", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_line_x1", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_line_x2", std.F_vv_typek, VAL, 
std.TYPE_STR, POP, "intf_line_y1", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_line_y2", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_namelist_mru", std.F_vv_typek, VAL, 
std.TYPE_STR, POP, "intf_opacity", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_stroke_color", std.F_vv_rec, VAL, "a_color_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP
, "intf_text_bold", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "intf_text_color", std.F_vv_rec, VAL, "a_color_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "intf_text_font"
, std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_text_hideu", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "intf_text_html", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "intf_text_indent"
, std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_text_italic", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "intf_text_leading", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_text_shrink"
, std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "intf_text_size", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_text_spacing", std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_text_str"
, std.F_vv_typek, VAL, std.TYPE_STR, POP, "intf_text_wrap", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "is_bar_visible", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "is_modal_dtype"
, std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "line_cap_grid", std.F_vv_rec, VAL, "a_choice_set", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "line_joint_grid", std.F_vv_rec, VAL, 
"a_choice_set", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "mode_tabs", std.F_vv_rec, VAL, "a_tabset", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "ncorner_grid", std.F_vv_rec
, VAL, "a_choice_set", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "palette_action", std.F_vv_typek, VAL, std.TYPE_FUNC, POP, "palette_ferrari_selx", std.F_vv_typek, VAL, std.TYPE_NUM
, POP, "palette_targ_ptr", std.F_vv_rec, VAL, "a_color_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "prog_kind_choices", std.F_vv_rec, VAL, "a_choice_set", std.F_vv_typek
, VAL, std.TYPE_RECORD, POP, "prog_name_in", std.F_vv_rec, VAL, "a_input_field", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "prog_title_in", std.F_vv_rec, VAL, "a_input_field"
, std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "prog_ver1_in", std.F_vv_rec, VAL, "a_input_field", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "prog_ver2_in", std.F_vv_rec, VAL, 
"a_input_field", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "prog_ver3_in", std.F_vv_rec, VAL, "a_input_field", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "proj_tabs", std.F_vv_rec
, VAL, "a_tabset", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "skip_expr", std.F_vv_typek, VAL, std.TYPE_STR, POP, "text_just_grid", std.F_vv_rec, VAL, "a_choice_set", std.F_vv_typek
, VAL, std.TYPE_RECORD, POP, "text_size_grid", std.F_vv_rec, VAL, "a_choice_set", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "timer_func_in", std.F_vv_rec, VAL, "a_input_field"
, std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "timer_group", std.F_vv_typek, VAL, std.TYPE_STR, POP, "timer_group_in", std.F_vv_rec, VAL, "a_input_field", std.F_vv_typek, VAL, 
std.TYPE_RECORD, POP, "timer_how_timed", std.F_vv_rec, VAL, "a_choice_set", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "timer_nreps_grid", std.F_vv_rec, VAL, "a_choice_set"
, std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "timer_nreps_in", std.F_vv_rec, VAL, "a_input_field", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "timer_prereq", std.F_vv_typek
, VAL, std.TYPE_STR, POP, "timer_prereq_in", std.F_vv_rec, VAL, "a_input_field", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "timer_start", std.F_vv_typek, VAL, std.TYPE_STR
, POP, "timer_start_in", std.F_vv_rec, VAL, "a_input_field", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "timer_time_grid", std.F_vv_rec, VAL, "a_choice_set", std.F_vv_typek
, VAL, std.TYPE_RECORD, POP, "work_color", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "work_color_ctl", std.F_vv_rec, VAL, "a_color_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, "work_grad", std.F_vv_rec, VAL, "a_gradient", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "work_grad_dir", std.F_vv_rec, VAL, "a_choice_set", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, "work_grad_shape", std.F_vv_rec, VAL, "a_choice_set", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "work_grad_stopx", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "work_name_in"
, std.F_vv_rec, VAL, "a_input_field", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "work_nk", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "work_state", std.F_vv_typek, VAL, std.TYPE_NUM
, POP, "work_sym", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "work_var", std.F_vv_rec, VAL, "a_var_spec", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, POP, POP, "a_rec_spec", std.F_vv_fields, "fields", std.F_vv_rec, VAL, "a_field_spec", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "is_expanded", std.F_vv_typek, VAL, 
std.TYPE_YESNO, POP, "name", std.F_vv_typek, VAL, std.TYPE_STR, POP, "name_in", std.F_vv_rec, VAL, "a_input_field", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "a_sect_div"
, std.F_vv_fields, "action_add", std.F_vv_typek, VAL, std.TYPE_FUNC, POP, "action_del", std.F_vv_typek, VAL, std.TYPE_FUNC, POP, "is_expanded", std.F_vv_typek, VAL, std.TYPE_YESNO
, POP, "is_readonly", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "nk", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "prompt", std.F_vv_typek, VAL, std.TYPE_STR, POP, POP, POP, "a_slider_ctl"
, std.F_vv_fields, "action", std.F_vv_typek, VAL, std.TYPE_FUNC, POP, "ball_d", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "ball_x", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "default"
, std.F_vv_typek, VAL, std.TYPE_NUM, POP, "digits", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "in_drag", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "maxval", std.F_vv_typek, VAL, 
std.TYPE_NUM, POP, "minval", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "old_val", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "prompt", std.F_vv_typek, VAL, std.TYPE_STR, POP, "rack_h"
, std.F_vv_typek, VAL, std.TYPE_NUM, POP, "skip_reset", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "ss_driven", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "start_ball_x", std.F_vv_typek
, VAL, std.TYPE_NUM, POP, "start_mouse_x", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "step", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "sunit", std.F_vv_typek, VAL, std.TYPE_NUM
, POP, "val_ptr", std.F_vv_typek, VAL, std.TYPE_PTR, POP, "val_ss", std.F_vv_typek, VAL, std.TYPE_STR, POP, POP, POP, "a_slot", std.F_vv_fields, "color", std.F_vv_typek, VAL, 
std.TYPE_COLOR, POP, "key1", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "key2", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "key3", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "name"
, std.F_vv_typek, VAL, std.TYPE_STR, POP, POP, POP, "a_sym", std.F_vv_fields, "asset_spec", std.F_vv_rec, VAL, "a_asset_spec", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "color"
, std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "comment", std.F_vv_typek, VAL, std.TYPE_STR, POP, "exportf", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "func_spec", std.F_vv_rec
, VAL, "a_func_spec", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "grad", std.F_vv_rec, VAL, "a_gradient", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "is_stdlib", std.F_vv_typek
, VAL, std.TYPE_YESNO, POP, "name", std.F_vv_typek, VAL, std.TYPE_STR, POP, "nk", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "rec_spec", std.F_vv_rec, VAL, "a_rec_spec", std.F_vv_typek
, VAL, std.TYPE_RECORD, POP, "var_spec", std.F_vv_rec, VAL, "a_var_spec", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, "a_tabset", std.F_vv_fields, "action", std.F_vv_typek
, VAL, std.TYPE_FUNC, POP, "label_list", std.F_vv_typek, VAL, std.TYPE_ARRAY, POP, "selx", std.F_vv_typek, VAL, std.TYPE_NUM, POP, POP, POP, "a_var_spec", std.F_vv_fields, 
"dtype", std.F_vv_typek, VAL, std.TYPE_ARRAY, POP, "enumlist", std.F_vv_typek, VAL, std.TYPE_ARRAY, POP, "initval", std.F_vv_typek, VAL, std.TYPE_ANY, POP, "initval_in", std.F_vv_rec
, VAL, "a_input_field", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "name", std.F_vv_typek, VAL, std.TYPE_STR, POP, "name_in", std.F_vv_rec, VAL, "a_input_field", std.F_vv_typek
, VAL, std.TYPE_RECORD, POP, "subrec", std.F_vv_rec, VAL, "a_rec_spec", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, POP, POP, POP, std.F_mod_vars, "BARV", std.F_vv_typek, VAL, 
std.TYPE_NUM, POP, "GRID_NCOLS", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "GRID_NPARTS", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "GRID_NROWS", std.F_vv_typek, VAL, std.TYPE_NUM
, POP, "NCELLS", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "NCOLS", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "NROWS", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "SET1", std.F_vv_rec
, VAL, "a_slot", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "SLIDER_BORD_POS", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "SLIDER_BORD_THICK"
, std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "SLIDER_GRAD_ANGLE", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, "SLIDER_GRAD_CENTERX", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "SLIDER_GRAD_CENTERY", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek
, VAL, std.TYPE_RECORD, POP, "SLIDER_GRAD_FOCUSX", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "SLIDER_GRAD_FOCUSY", std.F_vv_rec, VAL, "a_slider_ctl"
, std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "SLIDER_GRAD_INNER", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "SLIDER_GRAD_OPACITY", std.F_vv_rec
, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "SLIDER_GRAD_OUTER", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "SLIDER_GRAD_POS"
, std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "SLIDER_IMAGE_CORNER", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, "SLIDER_IMAGE_INDENT", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "SLIDER_LINE_THICK", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek
, VAL, std.TYPE_RECORD, POP, "SLIDER_OPACITY", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "SLIDER_RECT_CORNER", std.F_vv_rec, VAL, "a_slider_ctl"
, std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "SLIDER_TEXT_INDENT", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "SLIDER_TEXT_LEADING", std.F_vv_rec
, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "SLIDER_TEXT_SIZE_ABS", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "SLIDER_TEXT_SIZE_REL"
, std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "SLIDER_TEXT_SPACING", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, "SLIDER_TEXT_VPOS", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "SLIDER_TIMER_DELAY", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek
, VAL, std.TYPE_RECORD, POP, "SLIDER_TIMER_RATE", std.F_vv_rec, VAL, "a_slider_ctl", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "TOOLBARH", std.F_vv_typek, VAL, std.TYPE_NUM
, POP, "c_back", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "c_text", std.F_vv_typek, VAL, std.TYPE_COLOR, POP, "chip_h", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "doc", std.F_vv_rec
, VAL, "a_doc", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "fresh", std.F_vv_typek, VAL, std.TYPE_YESNO, POP, "g", std.F_vv_rec, VAL, "a_global", std.F_vv_typek, VAL, std.TYPE_RECORD
, POP, "g_code", std.F_vv_typek, VAL, std.TYPE_STR, POP, "g_stop_centerx", std.F_vv_typek, VAL, std.TYPE_ARRAY, POP, "g_stop_centery", std.F_vv_typek, VAL, std.TYPE_ARRAY, POP
, "g_stop_ndy", std.F_vv_typek, VAL, std.TYPE_ARRAY, POP, "gsc", std.F_vv_rec, VAL, "a_colorchart_state", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "hilite", std.F_vv_typek
, VAL, std.TYPE_YESNO, POP, "indent", std.F_vv_typek, VAL, std.TYPE_NUM, POP, "lib_syms", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "slotlist"
, std.F_vv_rec, VAL, "a_slot", std.F_vv_typek, VAL, std.TYPE_RECORD, POP, "sorted_syms", std.F_vv_rec, VAL, "a_sym", std.F_vv_typek, VAL, std.TYPE_RECORD);
//[reflZZZ]
//-------  func const
const d_work_var_1218_F = new std.a_function("builder", "d_work_var_1218", d_work_var_1218);
const d_work_var_1210_F = new std.a_function("builder", "d_work_var_1210", d_work_var_1210);
const d_name_close_2733_F = new std.a_function("builder", "d_name_close_2733", d_name_close_2733);
const d_name_close_2731_F = new std.a_function("builder", "d_name_close_2731", d_name_close_2731);
const pick_dtype_F = new std.a_function("builder", "pick_dtype", pick_dtype, track_pick_dtype);
const pick_dtype_cell_F= new std.a_function("builder", "pick_dtype_cell", pick_dtype_cell);
const toolbar_F = new std.a_function("builder", "toolbar", toolbar);
const do_namelist_dup_F = new std.a_function("builder", "do_namelist_dup", do_namelist_dup);
const d_prog_version_2724_F = new std.a_function("builder", "d_prog_version_2724", d_prog_version_2724);
const d_oneshot_F = new std.a_function("builder", "d_oneshot", d_oneshot, track_d_oneshot);
const do_color_work_init_F = new std.a_function("builder", "do_color_work_init", do_color_work_init);
const icon_poly_F = new std.a_function("builder", "icon_poly", icon_poly);
const validate_varname_F = new std.a_function("builder", "validate_varname", validate_varname);
const d_prog_version_2716_F = new std.a_function("builder", "d_prog_version_2716", d_prog_version_2716);
const d_gradient_sample_F = new std.a_function("builder", "d_gradient_sample", d_gradient_sample);
const do_stop_add_F = new std.a_function("builder", "do_stop_add", do_stop_add);
const d_name_entry_F = new std.a_function("builder", "d_name_entry", d_name_entry);
const add_tool_str_2891_F = new std.a_function("builder", "add_tool_str_2891", add_tool_str_2891);
const add_tool_font_2919_F = new std.a_function("builder", "add_tool_font_2919", add_tool_font_2919);
const d_work_var_hdr_1193_F = new std.a_function("builder", "d_work_var_hdr_1193", d_work_var_hdr_1193);
const html_color_chip_4806_F = new std.a_function("builder", "html_color_chip_4806", html_color_chip_4806);
const icon_line_F = new std.a_function("builder", "icon_line", icon_line);
const add_tool_slider_2942_F = new std.a_function("builder", "add_tool_slider_2942", add_tool_slider_2942);
const clear_band_selection_F = new std.a_function("builder", "clear_band_selection", clear_band_selection);
const d_resetdot_F = new std.a_function("builder", "d_resetdot", d_resetdot, track_d_resetdot);
const d_sectdivA_F = new std.a_function("builder", "d_sectdivA", d_sectdivA, track_d_sectdivA);
const draw_1_toggle_F = new std.a_function("builder", "draw_1_toggle", draw_1_toggle);
const d_gradient_bar_F = new std.a_function("builder", "d_gradient_bar", d_gradient_bar, track_d_gradient_bar);
const d_font_example_4239_F = new std.a_function("builder", "d_font_example_4239", d_font_example_4239);
const html_palette_resize_F = new std.a_function("builder", "html_palette_resize", html_palette_resize);
const do_work_cancel_F = new std.a_function("builder", "do_work_cancel", do_work_cancel);
const do_quit_F = new std.a_function("builder", "do_quit", do_quit);
const open_header_F = new std.a_function("builder", "open_header", open_header);
const section2_F = new std.a_function("builder", "section2", section2);
const d_ferrari_grid_F = new std.a_function("builder", "d_ferrari_grid", d_ferrari_grid);
const d_ferrari_grid_cell_F= new std.a_function("builder", "d_ferrari_grid_cell", d_ferrari_grid_cell);
const d_work_var_1212_F = new std.a_function("builder", "d_work_var_1212", d_work_var_1212);
const do_worksym_del_F = new std.a_function("builder", "do_worksym_del", do_worksym_del);
const d_work_var_1220_F = new std.a_function("builder", "d_work_var_1220", d_work_var_1220);
const d_namelist_F = new std.a_function("builder", "d_namelist", d_namelist, track_d_namelist);
const d_namelist_cell_F= new std.a_function("builder", "d_namelist_cell", d_namelist_cell);
const d_work_var_F = new std.a_function("builder", "d_work_var", d_work_var);
const icon_image_F = new std.a_function("builder", "icon_image", icon_image);
const var_add_init_F = new std.a_function("builder", "var_add_init", var_add_init);
const d_work_var_hdr_1199_F = new std.a_function("builder", "d_work_var_hdr_1199", d_work_var_hdr_1199);
const d_slider_plus_F = new std.a_function("builder", "d_slider_plus", d_slider_plus, track_d_slider_plus);
const main_draw_layer_F = new std.a_function("builder", "main_draw_layer", main_draw_layer);
const do_const_add_F = new std.a_function("builder", "do_const_add", do_const_add);
const d_recent_F = new std.a_function("builder", "d_recent", d_recent, track_d_recent);
const d_recent_cell_F= new std.a_function("builder", "d_recent_cell", d_recent_cell);
const d_var_summary_F = new std.a_function("builder", "d_var_summary", d_var_summary);
const do_modal_cancel_F = new std.a_function("builder", "do_modal_cancel", do_modal_cancel);
const do_namelist_del_F = new std.a_function("builder", "do_namelist_del", do_namelist_del);
const d_font_example_4242_F = new std.a_function("builder", "d_font_example_4242", d_font_example_4242);
const d_gutter_F = new std.a_function("builder", "d_gutter", d_gutter);
const delta_grad_pos_F = new std.a_function("builder", "delta_grad_pos", delta_grad_pos);
const main_draw2_F = new std.a_function("builder", "main_draw2", main_draw2);
const toolbar_1935_F = new std.a_function("builder", "toolbar_1935", toolbar_1935);
const draw_font_entry_F = new std.a_function("builder", "draw_font_entry", draw_font_entry);
const default_radial_ctl_F = new std.a_function("builder", "default_radial_ctl", default_radial_ctl);
const do_open_F = new std.a_function("builder", "do_open", do_open);
const do_block_dup_F = new std.a_function("builder", "do_block_dup", do_block_dup);
const icon_rect_F = new std.a_function("builder", "icon_rect", icon_rect);
const d_dtriangle_F = new std.a_function("builder", "d_dtriangle", d_dtriangle);
const d_sectdivB_F = new std.a_function("builder", "d_sectdivB", d_sectdivB);
const d_enum_spec_F = new std.a_function("builder", "d_enum_spec", d_enum_spec, track_d_enum_spec);
const draw_dropdown_F = new std.a_function("builder", "draw_dropdown", draw_dropdown);
const d_slider_rack_F = new std.a_function("builder", "d_slider_rack", d_slider_rack, track_d_slider_rack);
const html_palette_init_F = new std.a_function("builder", "html_palette_init", html_palette_init);
const icon_text_F = new std.a_function("builder", "icon_text", icon_text);
const build_namelist_F = new std.a_function("builder", "build_namelist", build_namelist);
const d_sectdiv_F = new std.a_function("builder", "d_sectdiv", d_sectdiv);
const do_namelist_add_F = new std.a_function("builder", "do_namelist_add", do_namelist_add);
const d_sectprompt_F = new std.a_function("builder", "d_sectprompt", d_sectprompt);
const add_tool_slider_F = new std.a_function("builder", "add_tool_slider", add_tool_slider);
const d_rec_field_F = new std.a_function("builder", "d_rec_field", d_rec_field);
const d_pulldown_F = new std.a_function("builder", "d_pulldown", d_pulldown, track_d_pulldown);
const section3_F = new std.a_function("builder", "section3", section3);
const do_enum_add_F = new std.a_function("builder", "do_enum_add", do_enum_add);
const store_repetitions_F = new std.a_function("builder", "store_repetitions", store_repetitions);
const draw_oneshot_F = new std.a_function("builder", "draw_oneshot", draw_oneshot, track_draw_oneshot);
const d_slider_minus_F = new std.a_function("builder", "d_slider_minus", d_slider_minus, track_d_slider_minus);
const draw_color_entry_F = new std.a_function("builder", "draw_color_entry", draw_color_entry);
const d_modal_dtype_picker_F = new std.a_function("builder", "d_modal_dtype_picker", d_modal_dtype_picker, track_d_modal_dtype_picker);
const do_lang_F = new std.a_function("builder", "do_lang", do_lang);
const butt_modal_cancel_F = new std.a_function("builder", "butt_modal_cancel", butt_modal_cancel, track_butt_modal_cancel);
const d_color_spec_F = new std.a_function("builder", "d_color_spec", d_color_spec, track_d_color_spec);
const d_name_entry_2748_F = new std.a_function("builder", "d_name_entry_2748", d_name_entry_2748);
const d_double_arrows_F = new std.a_function("builder", "d_double_arrows", d_double_arrows);
const d_data_editarea_F = new std.a_function("builder", "d_data_editarea", d_data_editarea);
const d_work_var_hdr_1202_F = new std.a_function("builder", "d_work_var_hdr_1202", d_work_var_hdr_1202);
const open_header_1796_F = new std.a_function("builder", "open_header_1796", open_header_1796);
const d_gradient_spec_F = new std.a_function("builder", "d_gradient_spec", d_gradient_spec, track_d_gradient_spec);
const ferr_ramp_chip_F = new std.a_function("builder", "ferr_ramp_chip", ferr_ramp_chip, track_ferr_ramp_chip);
const draw_font_sample_F = new std.a_function("builder", "draw_font_sample", draw_font_sample, track_draw_font_sample);
const d_gradient_spec_2252_F = new std.a_function("builder", "d_gradient_spec_2252", d_gradient_spec_2252);
const ferrari_palette_draw_F = new std.a_function("builder", "ferrari_palette_draw", ferrari_palette_draw);
const d_asset_spec_F = new std.a_function("builder", "d_asset_spec", d_asset_spec, track_d_asset_spec);
const do_block_del_F = new std.a_function("builder", "do_block_del", do_block_del);
const add_tool_fill_2899_F = new std.a_function("builder", "add_tool_fill_2899", add_tool_fill_2899);
const d_prog_version_2713_F = new std.a_function("builder", "d_prog_version_2713", d_prog_version_2713);
const d_asset_spec_2177_F = new std.a_function("builder", "d_asset_spec_2177", d_asset_spec_2177);
const draw_color_sample_F = new std.a_function("builder", "draw_color_sample", draw_color_sample, track_draw_color_sample);
const d_asset_spec_2191_F = new std.a_function("builder", "d_asset_spec_2191", d_asset_spec_2191);
const d_prog_version_2720_F = new std.a_function("builder", "d_prog_version_2720", d_prog_version_2720);
const angle_to_graddir_F = new std.a_function("builder", "angle_to_graddir", angle_to_graddir);
const d_name_entry_2750_F = new std.a_function("builder", "d_name_entry_2750", d_name_entry_2750);
const draw_tabs2_F = new std.a_function("builder", "draw_tabs2", draw_tabs2, track_draw_tabs2);
const d_prog_version_2718_F = new std.a_function("builder", "d_prog_version_2718", d_prog_version_2718);
const do_color_add_F = new std.a_function("builder", "do_color_add", do_color_add);
const d_slider_assy_F = new std.a_function("builder", "d_slider_assy", d_slider_assy);
const draw_font_picker_F = new std.a_function("builder", "draw_font_picker", draw_font_picker, track_draw_font_picker);
const draw_font_picker_cell_F= new std.a_function("builder", "draw_font_picker_cell", draw_font_picker_cell);
const ferr_first_ramp_4574_F = new std.a_function("builder", "ferr_first_ramp_4574", ferr_first_ramp_4574);
const store_graddir_F = new std.a_function("builder", "store_graddir", store_graddir);
const d_asset_path_F = new std.a_function("builder", "d_asset_path", d_asset_path);
const d_timer_rep_2418_F = new std.a_function("builder", "d_timer_rep_2418", d_timer_rep_2418);
const add_tool_color_F = new std.a_function("builder", "add_tool_color", add_tool_color);
const ferr_first_ramp_4576_F = new std.a_function("builder", "ferr_first_ramp_4576", ferr_first_ramp_4576);
const d_data_editarea_1178_F = new std.a_function("builder", "d_data_editarea_1178", d_data_editarea_1178);
const d_enum_spec_2222_F = new std.a_function("builder", "d_enum_spec_2222", d_enum_spec_2222);
const add_tool_linecap_2815_F = new std.a_function("builder", "add_tool_linecap_2815", add_tool_linecap_2815);
const d_dtype_picker_1070_F = new std.a_function("builder", "d_dtype_picker_1070", d_dtype_picker_1070);
const add_tool_corner_2956_F = new std.a_function("builder", "add_tool_corner_2956", add_tool_corner_2956);
const do_stop_del_F = new std.a_function("builder", "do_stop_del", do_stop_del);
const d_gradient_spec_2250_F = new std.a_function("builder", "d_gradient_spec_2250", d_gradient_spec_2250);
const add_tool_color_2911_F = new std.a_function("builder", "add_tool_color_2911", add_tool_color_2911);
const html_color_chip_4796_F = new std.a_function("builder", "html_color_chip_4796", html_color_chip_4796);
const do_block_add_F = new std.a_function("builder", "do_block_add", do_block_add);
const d_div_del_F = new std.a_function("builder", "d_div_del", d_div_del);
const d_data_recpick_F = new std.a_function("builder", "d_data_recpick", d_data_recpick);
const gen_code_F = new std.a_function("builder", "gen_code", gen_code);
const d_pulldown_1252_F = new std.a_function("builder", "d_pulldown_1252", d_pulldown_1252);
const draw_choice_grid_F = new std.a_function("builder", "draw_choice_grid", draw_choice_grid, track_draw_choice_grid);
const draw_choice_grid_cell_F= new std.a_function("builder", "draw_choice_grid_cell", draw_choice_grid_cell);
const d_color_spec_2233_F = new std.a_function("builder", "d_color_spec_2233", d_color_spec_2233);
const default_linear_ctl_F = new std.a_function("builder", "default_linear_ctl", default_linear_ctl);
const delta_const_choices_F = new std.a_function("builder", "delta_const_choices", delta_const_choices);
const add_tool_image_2883_F = new std.a_function("builder", "add_tool_image_2883", add_tool_image_2883);
const func_header_F = new std.a_function("builder", "func_header", func_header);
const d_timer_interval_2433_F = new std.a_function("builder", "d_timer_interval_2433", d_timer_interval_2433);
const not_yet_F = new std.a_function("builder", "not_yet", not_yet);
const open_butts_F = new std.a_function("builder", "open_butts", open_butts);
const draw_toggle_F = new std.a_function("builder", "draw_toggle", draw_toggle, track_draw_toggle);
const ferr_first_ramp_F = new std.a_function("builder", "ferr_first_ramp", ferr_first_ramp);
const d_botbar_F = new std.a_function("builder", "d_botbar", d_botbar);
const do_gradient_add_F = new std.a_function("builder", "do_gradient_add", do_gradient_add);
const do_block_skip_F = new std.a_function("builder", "do_block_skip", do_block_skip);
const d_work_var_1216_F = new std.a_function("builder", "d_work_var_1216", d_work_var_1216);
const draw_entry_F = new std.a_function("builder", "draw_entry", draw_entry);
const add_textsize_slider_2985_F = new std.a_function("builder", "add_textsize_slider_2985", add_textsize_slider_2985);
const add_tool_point_3267_F = new std.a_function("builder", "add_tool_point_3267", add_tool_point_3267);
const d_name_close_F = new std.a_function("builder", "d_name_close", d_name_close);
const html_palette_draw_F = new std.a_function("builder", "html_palette_draw", html_palette_draw, track_html_palette_draw);
const html_palette_draw_cell_F= new std.a_function("builder", "html_palette_draw_cell", html_palette_draw_cell);
const add_tool_just_2833_F = new std.a_function("builder", "add_tool_just_2833", add_tool_just_2833);
const store_gradshape_F = new std.a_function("builder", "store_gradshape", store_gradshape);
const add_tool_num_2932_F = new std.a_function("builder", "add_tool_num_2932", add_tool_num_2932);
const add_tool_bbox_2875_F = new std.a_function("builder", "add_tool_bbox_2875", add_tool_bbox_2875);
const d_dtype_picker_F = new std.a_function("builder", "d_dtype_picker", d_dtype_picker);
const d_asset_spec_2194_F = new std.a_function("builder", "d_asset_spec_2194", d_asset_spec_2194);
const opening_menu_F = new std.a_function("builder", "opening_menu", opening_menu);
const butt_grad_stop_F = new std.a_function("builder", "butt_grad_stop", butt_grad_stop);
const do_var_add_F = new std.a_function("builder", "do_var_add", do_var_add);
const d_work_var_hdr_F = new std.a_function("builder", "d_work_var_hdr", d_work_var_hdr);
const do_work_ok_F = new std.a_function("builder", "do_work_ok", do_work_ok);
const main_draw3_F = new std.a_function("builder", "main_draw3", main_draw3);
const d_timer_rep_2422_F = new std.a_function("builder", "d_timer_rep_2422", d_timer_rep_2422);
const d_color_sample_3410_F = new std.a_function("builder", "d_color_sample_3410", d_color_sample_3410);
const clear_work_name_F = new std.a_function("builder", "clear_work_name", clear_work_name);
const d_color_spec_2237_F = new std.a_function("builder", "d_color_spec_2237", d_color_spec_2237);
const d_div_add_F = new std.a_function("builder", "d_div_add", d_div_add);
const d_gradient_kind_assy_F = new std.a_function("builder", "d_gradient_kind_assy", d_gradient_kind_assy);
const d_prog_version_F = new std.a_function("builder", "d_prog_version", d_prog_version);
const do_close_doc_F = new std.a_function("builder", "do_close_doc", do_close_doc);
const grad_work_init_F = new std.a_function("builder", "grad_work_init", grad_work_init);
const butt_work_cancel_F = new std.a_function("builder", "butt_work_cancel", butt_work_cancel, track_butt_work_cancel);
const draw_tabs_F = new std.a_function("builder", "draw_tabs", draw_tabs);
const icon_oval_F = new std.a_function("builder", "icon_oval", icon_oval);
const d_rec_name_F = new std.a_function("builder", "d_rec_name", d_rec_name);
const d_prog_version_2722_F = new std.a_function("builder", "d_prog_version_2722", d_prog_version_2722);
//-------  top nodes
const ICON_IMAGE = new std.a_image("art/icon_image.png", "");
const CHECKERBOARD = new std.a_image("art/checkerboard8.png", "",544,16);

const CLICK = new std.a_sound("art/click.mp3");
const BEEP = new std.a_sound("art/beep.mp3");
const THUD = new std.a_sound("art/thud.mp3");

const TRACE_HOTSPOT = N;
const TRACE_SLIDER = N;
const TRACE_INDICES = N;
const TRACE_GRAD = N;
const TRACE_STOPS = N;
const TRACE_PALETTE = N;
const TRACE_CPICK = N;
const TRACE_WORK = Y;
const TRACE_ONESHOT = N;
const TRACE_VALIDATE = N;
const SCAFFOLDING = Y;
const TYPE_TO_STR = new std.a_tree("builder","TYPE_TO_STR", std.NF_TOPLEVEL); std.merge_lit(_M, 38, TYPE_TO_STR, std.TYPE_ANY, VAL, "any", std.TYPE_BITS, VAL, "bits", std.TYPE_BYTES
  , VAL, "bytes", std.TYPE_COLOR, VAL, "color", std.TYPE_ENUM, VAL, "enum", std.TYPE_ERR, VAL, "ERR", std.TYPE_FUNC, VAL, "func", std.TYPE_IMAGE, VAL, "image", std.TYPE_MEAS
  , VAL, "meas", std.TYPE_NUM, VAL, "num", std.TYPE_OBJECT, VAL, "object", std.TYPE_PATTERN, VAL, "pattern", std.TYPE_PTR, VAL, "ptr", std.TYPE_SOUND, VAL, "sound", std.TYPE_STR
  , VAL, "str", std.TYPE_TREE, VAL, "tree", std.TYPE_U, VAL, "U", std.TYPE_VIDEO, VAL, "video", std.TYPE_VOID, VAL, "void", std.TYPE_YESNO, VAL, "yesno", std.TYPE_ARRAY, VAL
  , "array", std.TYPE_ARRAY2, VAL, "array^2", std.TYPE_ARRAY3, VAL, "array^3", std.TYPE_ARRAY4, VAL, "array^4", std.TYPE_RECORD, VAL, "record");
const GRAD1 = new std.a_tree("builder","GRAD1", std.NF_TOPLEVEL); std.merge_lit(_M, 67, GRAD1, std.F_grad_shape, VAL, std.LINEAR_GRADIENT, std.F_grad_angle, VAL, std.GRAD_TO_BOTTOM
  , std.F_grad_stops, 1, std.F_stop_pos, VAL, 0, std.F_stop_color, VAL, std.CHOCOLATE, POP, 2, std.F_stop_pos, VAL, 48, std.F_stop_color, VAL, std.BEIGE, POP, 3, std.F_stop_pos
  , VAL, 52, std.F_stop_color, VAL, std.BEIGE, POP, 4, std.F_stop_pos, VAL, 100, std.F_stop_color, VAL, std.CHOCOLATE, POP, POP);
const GRAD2 = new std.a_tree("builder","GRAD2", std.NF_TOPLEVEL); std.merge_lit(_M, 73, GRAD2, std.F_grad_shape, VAL, std.LINEAR_GRADIENT, std.F_grad_angle, VAL, std.GRAD_TO_RIGHT
  , std.F_grad_stops, 1, std.F_stop_pos, VAL, 0, std.F_stop_color, VAL, std.RED, POP, 2, std.F_stop_pos, VAL, 49, std.F_stop_color, VAL, std.BEIGE, POP, 3, std.F_stop_pos, VAL
  , 64, std.F_stop_color, VAL, std.LAVENDER, POP, 4, std.F_stop_pos, VAL, 100, std.F_stop_color, VAL, std.GREEN, POP, POP);
const DEFAULT_GRADIENT = new std.a_tree("builder","DEFAULT_GRADIENT", std.NF_TOPLEVEL); std.merge_lit(_M, 80, DEFAULT_GRADIENT, std.F_grad_shape, VAL, std.LINEAR_GRADIENT, 
  std.F_grad_angle, VAL, std.GRAD_TO_RIGHT, std.F_grad_stops, 1, std.F_stop_pos, VAL, 0, std.F_stop_color, VAL, std.WHITE, POP, 2, std.F_stop_pos, VAL, 100, std.F_stop_color
  , VAL, std.BLACK, POP, POP);
const DEAD_COLOR = std.GRAY8;
const GRAY8L = 0x3F3F3F;
const C_TAB_UND = 0x93443;
const TAB_LO_BACK = 0x7F6B6B;
const TAB_LO_BORD = 0x54056;
const TAB_LO_TEXT = 0xF0F0EA;
const TAB_HI_BACK = 0xF6F7CA;
const TAB_HI_BORD = 0x54056;
const TAB_HI_TEXT = 0x2B2927;
const BUTT_LO_BACK = TAB_LO_BACK;
const BUTT_LO_BORD = TAB_LO_BORD;
const BUTT_LO_TEXT = TAB_LO_TEXT;
const SECTD_BACK = 0x607074;
const BUTT_HI_BACK = TAB_HI_BACK;
const BUTT_HI_BORD = TAB_HI_BORD;
const BUTT_HI_TEXT = TAB_HI_TEXT;
const BUTT_HI_FILL = 0x8AC8DC;
const C_TOOL_LABEL = BUTT_LO_TEXT;
const C_TOOL_LABEL_SEL_BACK = 0x7E7F0D;
const DROPDOWN_ARROW_BACK = 0xD1744;
const DROPDOWN_ARROW_TEXT = 0xE3E7F8;
const ENTRY_LO_BACK = std.GRAY7;
const ENTRY_LO_BORD = std.GRAY5;
const ENTRY_LO_TEXT = BUTT_LO_TEXT;
const BUTT_FLASH = 0.2;
const BUTT_THICK = 1.5;
const DIMMED = 0.3;
const CHOICE_V = 20;
const CHOICE_CORNER = 4;
const TOGGLE_CORNER = 6;
const ONESHOT_CORNER = 6;
const SLIDER_CORNER = 7;
const SECTION_V = 22;
const ENTRY_V = 20;
const GUTTER = 6;
const ITEM_DV = 8;
const TABV = 20;
const TAB_UND = 2;
const TAB_CORNER = 10;
const TAB_BORD = 1.5;
const MODE_PROJECT = 1;
const MODE_DATA = 2;
const MODE_CODE = 3;
const MODE_BUILD = 4;
const BKIND_PLAIN = 1;
const BKIND_HORZ = 2;
const BKIND_VERT = 3;
const BKIND_GRID = 4;
const BKIND_REPORT = 5;
const BKINDSL_SLICE = 1;
const BKINDSL_SCROLL = 2;
const PICKER_COLOR_TABS = 1;
const PICKER_FONT_TABS = 2;
const UNIT_AL = 1;
const UNIT_PT = 2;
const UNIT_PX = 3;
const DRAWT_TEXT = 1;
const DRAWT_RECT = 2;
const DRAWT_OVAL = 3;
const DRAWT_POLY = 4;
const DRAWT_LINE = 5;
const DRAWT_IMAGE = 6;
const FILL_COLOR = 1;
const FILL_GRAD = 2;
const FILL_TILE = 3;
const TOOL_LINDENT = 1;
const TOOL_LABEL = 23;
const TOOL_MID_INDENT = 1;
const TOOL_ENTRYBOX = 73;
const TOOL_RINDENT = 2;
const TOOL_ROWV = 14;
const TOOL_TSIZE = 0.65;
const FONTLIST = new std.a_tree("builder","FONTLIST", std.NF_TOPLEVEL); std.merge_lit(_M, 187, FONTLIST, 1, VAL, "_sans", 2, VAL, "_serif", 3, VAL, "_typewriter", 4, VAL, 
  "Arial Black", 5, VAL, "Arial", 6, VAL, "Comic Sans MS", 7, VAL, "Courier", 8, VAL, "Garamond", 9, VAL, "Georgia", 10, VAL, "Impact", 11, VAL, "Palatino", 12, VAL, "Times"
  , 13, VAL, "Trebuchet MS", 14, VAL, "Verdana");
const NFONTS = std.tree_count(addr(FONTLIST));
const PATT_RANGE_0_100 = /^(?:|[0-9]|[0-9][0-9]|100)$/g;
const PATT_CARDINAL = /^[0-9]*$/g;
const INDENT_PER = 14;
const TAB = "   ";
const FUNC_DIVIDER = "\n===============";
const TRACE_COLORS = N;
const TRACE_FUDGE = N;
const TRACE_SIZING = N;
const SET2 = new std.a_tree("builder","SET2", std.NF_TOPLEVEL); std.merge_lit(_M, 4401, SET2, 1, F_name, VAL, "GRAY1", F_color, VAL, std.GRAY1, POP, 2, F_name, VAL, "GRAY2"
  , F_color, VAL, std.GRAY2, POP, 3, F_name, VAL, "GRAY3", F_color, VAL, std.GRAY3, POP, 4, F_name, VAL, "GRAY4", F_color, VAL, std.GRAY4, POP, 5, F_name, VAL, "GRAY5", F_color
  , VAL, std.GRAY5, POP, 6, F_name, VAL, "GRAY6", F_color, VAL, std.GRAY6, POP, 7, F_name, VAL, "GRAY7", F_color, VAL, std.GRAY7, POP, 8, F_name, VAL, "GRAY8", F_color, VAL, 
  std.GRAY8, POP, 9, F_name, VAL, "GRAY9", F_color, VAL, std.GRAY9, POP, 10, F_name, VAL, "BLACK", F_color, VAL, std.BLACK, POP, 11, F_name, VAL, "WHITE", F_color, VAL, std.WHITE
  , POP);
const hue_fudge = 150;
const AREA_THRESHOLD = 140000;
const TARG_WIDTH = 100;
const C_PALTEXT = std.MINT_CREAM;
const FERRARI = new std.a_tree("builder","FERRARI", std.NF_TOPLEVEL); std.merge_lit(_M, 4439, FERRARI, 1, VAL, 0x0, 2, VAL, 0xFFFFFF, 3, VAL, 0x290000, 4, VAL, 0x330000, 5
  , VAL, 0x420000, 6, VAL, 0x560000, 7, VAL, 0x6F0001, 8, VAL, 0x8B0001, 9, VAL, 0xA70001, 10, VAL, 0xC10100, 11, VAL, 0xDB0101, 12, VAL, 0xEF0101, 13, VAL, 0xFE0101, 14, VAL, 
  0xFE1111, 15, VAL, 0xFF2626, 16, VAL, 0xFE403F, 17, VAL, 0xFE5C5C, 18, VAL, 0xFF7A7A, 19, VAL, 0xFE9999, 20, VAL, 0xFFB6B5, 21, VAL, 0xFFCFCF, 22, VAL, 0xFFE5E4, 23, VAL, 
  0xFFF4F4, 24, VAL, 0x330F00, 25, VAL, 0x401300, 26, VAL, 0x521800, 27, VAL, 0x671E01, 28, VAL, 0x802600, 29, VAL, 0x992D00, 30, VAL, 0xB23400, 31, VAL, 0xC93B01, 32, VAL, 
  0xDF4101, 33, VAL, 0xF14601, 34, VAL, 0xFE4A01, 35, VAL, 0xFE5511, 36, VAL, 0xFE6526, 37, VAL, 0xFE7740, 38, VAL, 0xFF8B5C, 39, VAL, 0xFFA07A, 40, VAL, 0xFFB699, 41, VAL, 
  0xFFCAB5, 42, VAL, 0xFFDCCF, 43, VAL, 0xFFECE5, 44, VAL, 0xFFF7F4, 45, VAL, 0x331900, 46, VAL, 0x402800, 47, VAL, 0x513100, 48, VAL, 0x673A00, 49, VAL, 0x7F4500, 50, VAL, 
  0x984F01, 51, VAL, 0xB25A01, 52, VAL, 0xCA6601, 53, VAL, 0xDF6E01, 54, VAL, 0xF17602, 55, VAL, 0xFE7C02, 56, VAL, 0xFE8411, 57, VAL, 0xFE8F27, 58, VAL, 0xFE9C41, 59, VAL, 
  0xFEAB5D, 60, VAL, 0xFFBB7B, 61, VAL, 0xFFCA99, 62, VAL, 0xFFD9B6, 63, VAL, 0xFFE6CF, 64, VAL, 0xFFF1E4, 65, VAL, 0xFFF9F4, 66, VAL, 0x332300, 67, VAL, 0x402B00, 68, VAL, 
  0x523600, 69, VAL, 0x674400, 70, VAL, 0x805401, 71, VAL, 0x996301, 72, VAL, 0xB27301, 73, VAL, 0xC98201, 74, VAL, 0xDF9001, 75, VAL, 0xF19B02, 76, VAL, 0xFEA302, 77, VAL, 
  0xFFA912, 78, VAL, 0xFEB027, 79, VAL, 0xFEBA40, 80, VAL, 0xFEC45D, 81, VAL, 0xFFCF7B, 82, VAL, 0xFEDA99, 83, VAL, 0xFEE4B6, 84, VAL, 0xFFEED0, 85, VAL, 0xFFF5E5, 86, VAL, 
  0xFFFBF4, 87, VAL, 0x332A00, 88, VAL, 0x403C00, 89, VAL, 0x524A01, 90, VAL, 0x685C01, 91, VAL, 0x7F7001, 92, VAL, 0x998501, 93, VAL, 0xB29901, 94, VAL, 0xCAAD02, 95, VAL, 
  0xDFBF02, 96, VAL, 0xF1CD02, 97, VAL, 0xFED802, 98, VAL, 0xFEDA12, 99, VAL, 0xFEDD27, 100, VAL, 0xFEE241, 101, VAL, 0xFFE65D, 102, VAL, 0xFEEA7B, 103, VAL, 0xFFEF99, 104, VAL, 
  0xFFF4B6, 105, VAL, 0xFFF7CF, 106, VAL, 0xFFFBE4, 107, VAL, 0xFFFDF4, 108, VAL, 0x333100, 109, VAL, 0x403E00, 110, VAL, 0x525001, 111, VAL, 0x686600, 112, VAL, 0x807E01, 113
  , VAL, 0x989801, 114, VAL, 0xB1B101, 115, VAL, 0xCAC902, 116, VAL, 0xDFDF01, 117, VAL, 0xF1F002, 118, VAL, 0xFEFE02, 119, VAL, 0xFEFE12, 120, VAL, 0xFEFE27, 121, VAL, 0xFEFE40
  , 122, VAL, 0xFEFE5D, 123, VAL, 0xFEFE7B, 124, VAL, 0xFEFF99, 125, VAL, 0xFFFFB5, 126, VAL, 0xFEFFCF, 127, VAL, 0xFFFFE4, 128, VAL, 0xFFFFF4, 129, VAL, 0x2A3200, 130, VAL, 
  0x353F01, 131, VAL, 0x435100, 132, VAL, 0x556601, 133, VAL, 0x687E02, 134, VAL, 0x7C9702, 135, VAL, 0x91B003, 136, VAL, 0xA4C803, 137, VAL, 0xB6DD04, 138, VAL, 0xC4EF03, 139
  , VAL, 0xCFFC04, 140, VAL, 0xD2FC13, 141, VAL, 0xD6FC28, 142, VAL, 0xDBFC42, 143, VAL, 0xE0FD5E, 144, VAL, 0xE6FD7C, 145, VAL, 0xEBFE9A, 146, VAL, 0xF2FEB6, 147, VAL, 0xF6FED0
  , 148, VAL, 0xFAFFE5, 149, VAL, 0xFDFFF4, 150, VAL, 0x1A3400, 151, VAL, 0x204100, 152, VAL, 0x2A5300, 153, VAL, 0x356801, 154, VAL, 0x427F01, 155, VAL, 0x4F9801, 156, VAL, 
  0x5CB202, 157, VAL, 0x68C903, 158, VAL, 0x74DF03, 159, VAL, 0x7DF003, 160, VAL, 0x84FD03, 161, VAL, 0x94FD24, 162, VAL, 0x9FFE3A, 163, VAL, 0xACFE54, 164, VAL, 0xB9FE6F, 165
  , VAL, 0xC6FE8B, 166, VAL, 0xD4FEA6, 167, VAL, 0xE0FFBF, 168, VAL, 0xEBFFD6, 169, VAL, 0xF5FEE9, 170, VAL, 0xFBFFF7, 171, VAL, 0x33500, 172, VAL, 0x34200, 173, VAL, 0x55401
  , 174, VAL, 0x56800, 175, VAL, 0x78001, 176, VAL, 0x99801, 177, VAL, 0xAB101, 178, VAL, 0xBC801, 179, VAL, 0xDDD02, 180, VAL, 0xDEF02, 181, VAL, 0xEFB02, 182, VAL, 0x2EFC23
  , 183, VAL, 0x43FC39, 184, VAL, 0x5CFC53, 185, VAL, 0x75FD6F, 186, VAL, 0x90FD8B, 187, VAL, 0xAAFEA6, 188, VAL, 0xC2FEBF, 189, VAL, 0xD8FED6, 190, VAL, 0xEAFFE9, 191, VAL, 
  0xF7FFF7, 192, VAL, 0x360F, 193, VAL, 0x360F, 194, VAL, 0x4513, 195, VAL, 0x5819, 196, VAL, 0x17121, 197, VAL, 0x18C29, 198, VAL, 0x1A630, 199, VAL, 0x1C138, 200, VAL, 0x2D940
  , 201, VAL, 0x2ED46, 202, VAL, 0x2FC4A, 203, VAL, 0x23FC62, 204, VAL, 0x39FC72, 205, VAL, 0x53FD85, 206, VAL, 0x6FFD98, 207, VAL, 0x8BFEAC, 208, VAL, 0xA6FEBF, 209, VAL, 0xBFFED1
  , 210, VAL, 0xD6FFE1, 211, VAL, 0xE9FFEF, 212, VAL, 0xF7FFF9, 213, VAL, 0x3425, 214, VAL, 0x3526, 215, VAL, 0x14430, 216, VAL, 0x583F, 217, VAL, 0x17051, 218, VAL, 0x28C63
  , 219, VAL, 0x3A677, 220, VAL, 0x3C189, 221, VAL, 0x3D99B, 222, VAL, 0x4ECA9, 223, VAL, 0x4FBB3, 224, VAL, 0x25FBBD, 225, VAL, 0x3BFCC4, 226, VAL, 0x55FDCC, 227, VAL, 0x70FDD4
  , 228, VAL, 0x8BFDDD, 229, VAL, 0xA7FEE5, 230, VAL, 0xC0FEEC, 231, VAL, 0xD6FFF3, 232, VAL, 0xE9FEF9, 233, VAL, 0xF7FFFD, 234, VAL, 0x3333, 235, VAL, 0x3333, 236, VAL, 0x4242
  , 237, VAL, 0x15656, 238, VAL, 0x16E6E, 239, VAL, 0x18A8A, 240, VAL, 0x1A5A5, 241, VAL, 0x3C0C0, 242, VAL, 0x3D8D8, 243, VAL, 0x3EDEC, 244, VAL, 0x3FBFB, 245, VAL, 0x24FCFC
  , 246, VAL, 0x3BFCFC, 247, VAL, 0x54FDFC, 248, VAL, 0x6FFDFD, 249, VAL, 0x8BFEFD, 250, VAL, 0xA6FDFE, 251, VAL, 0xC0FEFE, 252, VAL, 0xD6FFFF, 253, VAL, 0xE9FFFE, 254, VAL, 
  0xF7FFFF, 255, VAL, 0x12633, 256, VAL, 0x12633, 257, VAL, 0x23142, 258, VAL, 0x24056, 259, VAL, 0x1536F, 260, VAL, 0x2688A, 261, VAL, 0x27DA6, 262, VAL, 0x292C2, 263, VAL, 
  0x3A4DA, 264, VAL, 0x3B4EE, 265, VAL, 0x3BFFD, 266, VAL, 0x12C3FD, 267, VAL, 0x28C9FD, 268, VAL, 0x42CFFD, 269, VAL, 0x5FD6FE, 270, VAL, 0x7DDEFE, 271, VAL, 0x9CE6FE, 272, VAL, 
  0xB8EDFE, 273, VAL, 0xD2F4FF, 274, VAL, 0xE8F9FF, 275, VAL, 0xF7FDFF, 276, VAL, 0x1633, 277, VAL, 0x1633, 278, VAL, 0x1C41, 279, VAL, 0x2556, 280, VAL, 0x1306F, 281, VAL, 
  0x13B8A, 282, VAL, 0x147A6, 283, VAL, 0x253C1, 284, VAL, 0x25DDA, 285, VAL, 0x266EF, 286, VAL, 0x26CFD, 287, VAL, 0x1175FD, 288, VAL, 0x2781FD, 289, VAL, 0x4291FE, 290, VAL, 
  0x5EA2FE, 291, VAL, 0x7CB3FE, 292, VAL, 0x9BC4FE, 293, VAL, 0xB7D5FE, 294, VAL, 0xD2E5FF, 295, VAL, 0xE7F1FF, 296, VAL, 0xF7FAFF, 297, VAL, 0x233, 298, VAL, 0x240, 299, VAL, 
  0x10352, 300, VAL, 0x10468, 301, VAL, 0x10580, 302, VAL, 0x10599, 303, VAL, 0x106B3, 304, VAL, 0x207CB, 305, VAL, 0x207E0, 306, VAL, 0x208F2, 307, VAL, 0x208FF, 308, VAL, 
  0x1118FF, 309, VAL, 0x272DFF, 310, VAL, 0x4146FF, 311, VAL, 0x5E62FF, 312, VAL, 0x7C7FFF, 313, VAL, 0x9B9DFF, 314, VAL, 0xB8B9FF, 315, VAL, 0xD2D3FF, 316, VAL, 0xE7E7FF, 317
  , VAL, 0xF7F7FF, 318, VAL, 0xE0034, 319, VAL, 0x120141, 320, VAL, 0x170052, 321, VAL, 0x1D0068, 322, VAL, 0x240180, 323, VAL, 0x2B0199, 324, VAL, 0x3301B2, 325, VAL, 0x3A01CA
  , 326, VAL, 0x4002DF, 327, VAL, 0x4502F1, 328, VAL, 0x4902FE, 329, VAL, 0x5412FE, 330, VAL, 0x6427FE, 331, VAL, 0x7741FF, 332, VAL, 0x8B5EFE, 333, VAL, 0xA17CFE, 334, VAL, 
  0xB79BFF, 335, VAL, 0xCCB7FE, 336, VAL, 0xDED2FF, 337, VAL, 0xEEE7FE, 338, VAL, 0xF9F7FF, 339, VAL, 0x240034, 340, VAL, 0x240034, 341, VAL, 0x2E0043, 342, VAL, 0x3D0157, 343
  , VAL, 0x4F0170, 344, VAL, 0x62018B, 345, VAL, 0x7602A6, 346, VAL, 0x8902C2, 347, VAL, 0x9B02DA, 348, VAL, 0xA903EF, 349, VAL, 0xB403FD, 350, VAL, 0xB913FD, 351, VAL, 0xBF29FD
  , 352, VAL, 0xC742FE, 353, VAL, 0xD05FFD, 354, VAL, 0xD87DFE, 355, VAL, 0xE29CFE, 356, VAL, 0xEAB8FE, 357, VAL, 0xF2D2FF, 358, VAL, 0xF8E8FF, 359, VAL, 0xFDF7FF, 360, VAL, 
  0x330032, 361, VAL, 0x40003F, 362, VAL, 0x520051, 363, VAL, 0x680066, 364, VAL, 0x7F017E, 365, VAL, 0x990197, 366, VAL, 0xB201B0, 367, VAL, 0xCB02C8, 368, VAL, 0xE002DD, 369
  , VAL, 0xF202EF, 370, VAL, 0xFF02FC, 371, VAL, 0xFF23FD, 372, VAL, 0xFF3AFC, 373, VAL, 0xFF53FD, 374, VAL, 0xFF6EFE, 375, VAL, 0xFF8AFE, 376, VAL, 0xFFA6FE, 377, VAL, 0xFFC0FE
  , 378, VAL, 0xFFD7FE, 379, VAL, 0xFFE9FF, 380, VAL, 0xFFF7FF, 381, VAL, 0x330023, 382, VAL, 0x330023, 383, VAL, 0x42002D, 384, VAL, 0x57013B, 385, VAL, 0x70004D, 386, VAL, 
  0x8A0160, 387, VAL, 0xA70173, 388, VAL, 0xC20186, 389, VAL, 0xDC0297, 390, VAL, 0xF002A6, 391, VAL, 0xFF02B0, 392, VAL, 0xFF23BA, 393, VAL, 0xFF39C1, 394, VAL, 0xFF53C9, 395
  , VAL, 0xFF6FD2, 396, VAL, 0xFF8ADB, 397, VAL, 0xFFA6E3, 398, VAL, 0xFFBFEB, 399, VAL, 0xFFD6F2, 400, VAL, 0xFFE9F8, 401, VAL, 0xFFF7FD, 402, VAL, 0x330014, 403, VAL, 0x400019
  , 404, VAL, 0x520020, 405, VAL, 0x670029, 406, VAL, 0x800131, 407, VAL, 0x99013C, 408, VAL, 0xB20245, 409, VAL, 0xCB024E, 410, VAL, 0xE00257, 411, VAL, 0xF2025E, 412, VAL, 
  0xFF0263, 413, VAL, 0xFF126D, 414, VAL, 0xFF277A, 415, VAL, 0xFF418A, 416, VAL, 0xFF5F9C, 417, VAL, 0xFF7CAF, 418, VAL, 0xFF9BC2, 419, VAL, 0xFFB8D3, 420, VAL, 0xFFD2E3, 421
  , VAL, 0xFFE7F1, 422, VAL, 0xFFF7FA, 423, VAL, 0x211212, 424, VAL, 0x2A1717, 425, VAL, 0x331C1C, 426, VAL, 0x3F2322, 427, VAL, 0x4F2B2B, 428, VAL, 0x5F3333, 429, VAL, 0x703D3C
  , 430, VAL, 0x804646, 431, VAL, 0x904D4E, 432, VAL, 0x9C5455, 433, VAL, 0xA55959, 434, VAL, 0xAA6363, 435, VAL, 0xB27171, 436, VAL, 0xBA8281, 437, VAL, 0xC49494, 438, VAL, 
  0xCFA8A8, 439, VAL, 0xD9BCBB, 440, VAL, 0xE3CFCF, 441, VAL, 0xEDDFDF, 442, VAL, 0xF4EDED, 443, VAL, 0xF9F7F7, 444, VAL, 0x211612, 445, VAL, 0x2A1D17, 446, VAL, 0x33231B, 447
  , VAL, 0x402C23, 448, VAL, 0x4F362B, 449, VAL, 0x5F4034, 450, VAL, 0x714C3C, 451, VAL, 0x815745, 452, VAL, 0x90614E, 453, VAL, 0x9D6A55, 454, VAL, 0xA56F59, 455, VAL, 0xAB7863
  , 456, VAL, 0xB28471, 457, VAL, 0xBB9282, 458, VAL, 0xC5A295, 459, VAL, 0xCFB3A8, 460, VAL, 0xDAC4BC, 461, VAL, 0xE3D4CE, 462, VAL, 0xECE3DF, 463, VAL, 0xF4EFED, 464, VAL, 
  0xF9F8F7, 465, VAL, 0x211912, 466, VAL, 0x2B2017, 467, VAL, 0x34271C, 468, VAL, 0x403123, 469, VAL, 0x503D2B, 470, VAL, 0x604A34, 471, VAL, 0x72573D, 472, VAL, 0x826547, 473
  , VAL, 0x91704E, 474, VAL, 0x9E7956, 475, VAL, 0xA67F5A, 476, VAL, 0xAB8764, 477, VAL, 0xB39172, 478, VAL, 0xBC9E82, 479, VAL, 0xC5AD95, 480, VAL, 0xD0BBA9, 481, VAL, 0xDACBBC
  , 482, VAL, 0xE4D9CF, 483, VAL, 0xECE6DF, 484, VAL, 0xF4F1ED, 485, VAL, 0xF9F8F7, 486, VAL, 0x211C12, 487, VAL, 0x2B2417, 488, VAL, 0x342C1B, 489, VAL, 0x413723, 490, VAL, 
  0x4F432B, 491, VAL, 0x605134, 492, VAL, 0x71613D, 493, VAL, 0x826E47, 494, VAL, 0x917A4E, 495, VAL, 0x9E8456, 496, VAL, 0xA68A5A, 497, VAL, 0xAB9164, 498, VAL, 0xB39A72, 499
  , VAL, 0xBCA782, 500, VAL, 0xC5B495, 501, VAL, 0xD0C1A9, 502, VAL, 0xDACFBC, 503, VAL, 0xE3DBCE, 504, VAL, 0xEDE7DF, 505, VAL, 0xF3F1ED, 506, VAL, 0xF9F8F7, 507, VAL, 0x211F12
  , 508, VAL, 0x2B2817, 509, VAL, 0x34311B, 510, VAL, 0x403C23, 511, VAL, 0x504C2B, 512, VAL, 0x605C34, 513, VAL, 0x726D3E, 514, VAL, 0x837C46, 515, VAL, 0x91894F, 516, VAL, 
  0x9E9456, 517, VAL, 0xA69A5A, 518, VAL, 0xACA064, 519, VAL, 0xB3A872, 520, VAL, 0xBBB382, 521, VAL, 0xC5BE95, 522, VAL, 0xD0CAA9, 523, VAL, 0xDAD5BC, 524, VAL, 0xE3E0CF, 525
  , VAL, 0xECEADF, 526, VAL, 0xF4F3ED, 527, VAL, 0xF9F9F7, 528, VAL, 0x212112, 529, VAL, 0x2A2B17, 530, VAL, 0x33341C, 531, VAL, 0x404123, 532, VAL, 0x4E4F2B, 533, VAL, 0x606033
  , 534, VAL, 0x71713D, 535, VAL, 0x818147, 536, VAL, 0x90914E, 537, VAL, 0x9D9D55, 538, VAL, 0xA6A65A, 539, VAL, 0xABAC64, 540, VAL, 0xB3B372, 541, VAL, 0xBBBB83, 542, VAL, 
  0xC6C595, 543, VAL, 0xD0CFA9, 544, VAL, 0xDADABC, 545, VAL, 0xE4E3CE, 546, VAL, 0xEDEDDF, 547, VAL, 0xF4F4ED, 548, VAL, 0xF9F9F7, 549, VAL, 0x1E2112, 550, VAL, 0x272A17, 551
  , VAL, 0x2F331C, 552, VAL, 0x3A3F23, 553, VAL, 0x484E2B, 554, VAL, 0x585F34, 555, VAL, 0x66703E, 556, VAL, 0x758146, 557, VAL, 0x83904E, 558, VAL, 0x8F9C55, 559, VAL, 0x97A55A
  , 560, VAL, 0x9EAA64, 561, VAL, 0xA6B271, 562, VAL, 0xB0BB82, 563, VAL, 0xBCC495, 564, VAL, 0xC8CFA9, 565, VAL, 0xD4DABC, 566, VAL, 0xDFE4CF, 567, VAL, 0xEAECE0, 568, VAL, 
  0xF2F4ED, 569, VAL, 0xF9F9F7, 570, VAL, 0x1A2112, 571, VAL, 0x212B17, 572, VAL, 0x28341C, 573, VAL, 0x324022, 574, VAL, 0x3D4F2B, 575, VAL, 0x4A6034, 576, VAL, 0x58713D, 577
  , VAL, 0x658147, 578, VAL, 0x70904E, 579, VAL, 0x7A9C55, 580, VAL, 0x81A55A, 581, VAL, 0x89AA64, 582, VAL, 0x93B271, 583, VAL, 0x9FBA82, 584, VAL, 0xADC595, 585, VAL, 0xBCCFA8
  , 586, VAL, 0xCBD9BC, 587, VAL, 0xD9E4CF, 588, VAL, 0xE6ECDF, 589, VAL, 0xF1F4ED, 590, VAL, 0xF8F9F7, 591, VAL, 0x132112, 592, VAL, 0x182B17, 593, VAL, 0x1D341C, 594, VAL, 
  0x244022, 595, VAL, 0x2C4F2B, 596, VAL, 0x365F33, 597, VAL, 0x3F703D, 598, VAL, 0x488045, 599, VAL, 0x518F4D, 600, VAL, 0x589B54, 601, VAL, 0x5DA459, 602, VAL, 0x67A963, 603
  , VAL, 0x74B171, 604, VAL, 0x85BA82, 605, VAL, 0x97C494, 606, VAL, 0xAACEA8, 607, VAL, 0xBDD9BC, 608, VAL, 0xCFE3CE, 609, VAL, 0xDFECDF, 610, VAL, 0xEDF3ED, 611, VAL, 0xF7F9F7
  , 612, VAL, 0x122116, 613, VAL, 0x172A1D, 614, VAL, 0x1C3323, 615, VAL, 0x223F2B, 616, VAL, 0x2B4E35, 617, VAL, 0x345F40, 618, VAL, 0x3D6F4B, 619, VAL, 0x468056, 620, VAL, 
  0x4D8F60, 621, VAL, 0x549B69, 622, VAL, 0x59A46E, 623, VAL, 0x63AA77, 624, VAL, 0x71B183, 625, VAL, 0x82BA92, 626, VAL, 0x94C4A2, 627, VAL, 0xA8CEB3, 628, VAL, 0xBCD9C4, 629
  , VAL, 0xCEE3D5, 630, VAL, 0xDFECE3, 631, VAL, 0xEDF3EF, 632, VAL, 0xF7F9F8, 633, VAL, 0x12211C, 634, VAL, 0x172B24, 635, VAL, 0x1C342C, 636, VAL, 0x224037, 637, VAL, 0x2B4F43
  , 638, VAL, 0x335F51, 639, VAL, 0x3D6F60, 640, VAL, 0x47806E, 641, VAL, 0x4E8F7B, 642, VAL, 0x559B86, 643, VAL, 0x5AA48E, 644, VAL, 0x64AA95, 645, VAL, 0x71B19E, 646, VAL, 
  0x83BAAA, 647, VAL, 0x95C4B5, 648, VAL, 0xA9CFC3, 649, VAL, 0xBCD9D0, 650, VAL, 0xCFE3DC, 651, VAL, 0xDFECE7, 652, VAL, 0xEDF4F1, 653, VAL, 0xF7F9F8, 654, VAL, 0x122121, 655
  , VAL, 0x172B2B, 656, VAL, 0x1C3434, 657, VAL, 0x224140, 658, VAL, 0x2B4F4E, 659, VAL, 0x33605F, 660, VAL, 0x3C7070, 661, VAL, 0x468080, 662, VAL, 0x4E8F8F, 663, VAL, 0x549B9B
  , 664, VAL, 0x59A4A4, 665, VAL, 0x63AAAA, 666, VAL, 0x71B1B1, 667, VAL, 0x82BABA, 668, VAL, 0x95C4C4, 669, VAL, 0xA8CECF, 670, VAL, 0xBBD9D9, 671, VAL, 0xCEE3E3, 672, VAL, 
  0xDFECEC, 673, VAL, 0xECF4F4, 674, VAL, 0xF7F9F9, 675, VAL, 0x121D21, 676, VAL, 0x17252B, 677, VAL, 0x1C2D34, 678, VAL, 0x233840, 679, VAL, 0x2B454F, 680, VAL, 0x33545F, 681
  , VAL, 0x3D6370, 682, VAL, 0x467181, 683, VAL, 0x4E7F90, 684, VAL, 0x558A9C, 685, VAL, 0x5A92A5, 686, VAL, 0x6498AB, 687, VAL, 0x72A1B2, 688, VAL, 0x82ACBA, 689, VAL, 0x95B8C4
  , 690, VAL, 0xA8C5CF, 691, VAL, 0xBCD2D9, 692, VAL, 0xCFDEE3, 693, VAL, 0xDFE8EC, 694, VAL, 0xEDF2F3, 695, VAL, 0xF7F8F9, 696, VAL, 0x121821, 697, VAL, 0x171F2B, 698, VAL, 
  0x1C2634, 699, VAL, 0x232F40, 700, VAL, 0x2B3A4F, 701, VAL, 0x34465F, 702, VAL, 0x3D5371, 703, VAL, 0x465F81, 704, VAL, 0x4F6B90, 705, VAL, 0x55739C, 706, VAL, 0x5A7AA5, 707
  , VAL, 0x6483AB, 708, VAL, 0x728DB2, 709, VAL, 0x839BBB, 710, VAL, 0x95AAC5, 711, VAL, 0xA9B9CF, 712, VAL, 0xBCC9D9, 713, VAL, 0xCFD7E3, 714, VAL, 0xDFE5EC, 715, VAL, 0xEDF0F3
  , 716, VAL, 0xF7F8F9, 717, VAL, 0x121221, 718, VAL, 0x17172B, 719, VAL, 0x1C1C34, 720, VAL, 0x232341, 721, VAL, 0x2B2B4F, 722, VAL, 0x343560, 723, VAL, 0x3D3E71, 724, VAL, 
  0x464881, 725, VAL, 0x4F5090, 726, VAL, 0x55579D, 727, VAL, 0x5A5CA6, 728, VAL, 0x6466AB, 729, VAL, 0x7273B3, 730, VAL, 0x8284BB, 731, VAL, 0x9596C5, 732, VAL, 0xA8AACF, 733
  , VAL, 0xBCBDDA, 734, VAL, 0xCFCFE4, 735, VAL, 0xDFE0ED, 736, VAL, 0xEDEDF4, 737, VAL, 0xF7F7F9, 738, VAL, 0x161221, 739, VAL, 0x1D172B, 740, VAL, 0x231C34, 741, VAL, 0x2B2340
  , 742, VAL, 0x352B50, 743, VAL, 0x403460, 744, VAL, 0x4B3D71, 745, VAL, 0x574682, 746, VAL, 0x614E90, 747, VAL, 0x69569D, 748, VAL, 0x6F5AA6, 749, VAL, 0x7864AC, 750, VAL, 
  0x8472B3, 751, VAL, 0x9283BB, 752, VAL, 0xA395C6, 753, VAL, 0xB3A9D0, 754, VAL, 0xC5BCD9, 755, VAL, 0xD5CFE4, 756, VAL, 0xE4DFEC, 757, VAL, 0xEFEDF4, 758, VAL, 0xF8F7F9, 759
  , VAL, 0x1D1221, 760, VAL, 0x26172B, 761, VAL, 0x2E1C34, 762, VAL, 0x382340, 763, VAL, 0x452B4F, 764, VAL, 0x543460, 765, VAL, 0x623D71, 766, VAL, 0x704681, 767, VAL, 0x7C4E90
  , 768, VAL, 0x87559D, 769, VAL, 0x8F5AA5, 770, VAL, 0x9664AB, 771, VAL, 0x9F72B2, 772, VAL, 0xAA82BB, 773, VAL, 0xB795C5, 774, VAL, 0xC4A8CF, 775, VAL, 0xD0BCDA, 776, VAL, 
  0xDDCFE4, 777, VAL, 0xE8DFEC, 778, VAL, 0xF1EDF4, 779, VAL, 0xF8F7F9, 780, VAL, 0x29162A, 781, VAL, 0x351D35, 782, VAL, 0x3E223D, 783, VAL, 0x492749, 784, VAL, 0x562F56, 785
  , VAL, 0x663865, 786, VAL, 0x764075, 787, VAL, 0x844884, 788, VAL, 0x924F91, 789, VAL, 0x9D569D, 790, VAL, 0xA65AA5, 791, VAL, 0xAC64AA, 792, VAL, 0xB372B2, 793, VAL, 0xBB83BB
  , 794, VAL, 0xC595C5, 795, VAL, 0xD0A8CF, 796, VAL, 0xD9BCDA, 797, VAL, 0xE4CEE3, 798, VAL, 0xECDFEC, 799, VAL, 0xF4EDF3, 800, VAL, 0xF9F7F9, 801, VAL, 0x21121C, 802, VAL, 
  0x2A1724, 803, VAL, 0x331C2C, 804, VAL, 0x402236, 805, VAL, 0x4F2B43, 806, VAL, 0x5F3452, 807, VAL, 0x713D60, 808, VAL, 0x81466E, 809, VAL, 0x904F7B, 810, VAL, 0x9D5686, 811
  , VAL, 0xA65A8E, 812, VAL, 0xAB6495, 813, VAL, 0xB3729E, 814, VAL, 0xBC82AA, 815, VAL, 0xC595B6, 816, VAL, 0xD0A8C3, 817, VAL, 0xDABCD0, 818, VAL, 0xE3CFDD, 819, VAL, 0xECDFE8
  , 820, VAL, 0xF4EDF1, 821, VAL, 0xF9F7F8, 822, VAL, 0x211218, 823, VAL, 0x2B171F, 824, VAL, 0x341C26, 825, VAL, 0x40222F, 826, VAL, 0x502B39, 827, VAL, 0x603445, 828, VAL, 
  0x713D51, 829, VAL, 0x82465D, 830, VAL, 0x914E68, 831, VAL, 0x9D5571, 832, VAL, 0xA65A77, 833, VAL, 0xAC647F, 834, VAL, 0xB3728A, 835, VAL, 0xBB8298, 836, VAL, 0xC595A8, 837
  , VAL, 0xD0A8B7, 838, VAL, 0xDABCC7, 839, VAL, 0xE3CED7, 840, VAL, 0xECE0E4, 841, VAL, 0xF4EDF0, 842, VAL, 0xF9F7F8, 843, VAL, 0x0, 844, VAL, 0x70706, 845, VAL, 0xF0F0F, 846
  , VAL, 0x191918, 847, VAL, 0x232424, 848, VAL, 0x2F3030, 849, VAL, 0x3C3D3C, 850, VAL, 0x494949, 851, VAL, 0x585858, 852, VAL, 0x676666, 853, VAL, 0x757575, 854, VAL, 0x848484
  , 855, VAL, 0x939393, 856, VAL, 0xA1A1A1, 857, VAL, 0xAFAFAF, 858, VAL, 0xBDBDBD, 859, VAL, 0xCACAC9, 860, VAL, 0xD5D6D6, 861, VAL, 0xE0E0E1, 862, VAL, 0xEAEAEA, 863, VAL, 
  0xF2F2F2);
const FERR_NROW = 7;
const FERR_NCOL = 6;
const FERR_NRAMPS = 42;
const CHIPS_PER_RAMP = 21;
const CHIPS_PER_ROW = std.mul(FERR_NCOL, CHIPS_PER_RAMP);


let g = new std.a_tree("builder","g", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED);
let doc = new std.a_tree("builder","doc", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED);
let sorted_syms = new std.a_tree("builder","sorted_syms", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED);
let lib_syms = new std.a_tree("builder","lib_syms", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED);
let SLIDER_BORD_THICK = new std.a_tree("builder","SLIDER_BORD_THICK", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 535, SLIDER_BORD_THICK, F_prompt, VAL
  , "border thickness", F_default_, VAL, 0, F_digits, VAL, 1, F_minval, VAL, 0, F_maxval, VAL, 20, F_step, VAL, 1);
let SLIDER_BORD_POS = new std.a_tree("builder","SLIDER_BORD_POS", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 536, SLIDER_BORD_POS, F_prompt, VAL, "border position"
  , F_default_, VAL, 50, F_digits, VAL, 0, F_minval, VAL, 0, F_maxval, VAL, 100, F_step, VAL, 10);
let SLIDER_OPACITY = new std.a_tree("builder","SLIDER_OPACITY", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 537, SLIDER_OPACITY, F_prompt, VAL, "opacity"
  , F_default_, VAL, 1, F_digits, VAL, 0, F_minval, VAL, 0, F_maxval, VAL, 1, F_step, VAL, 0.05, F_sunit, VAL, SUNIT_PERCENT);
let SLIDER_TEXT_SIZE_REL = new std.a_tree("builder","SLIDER_TEXT_SIZE_REL", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 538, SLIDER_TEXT_SIZE_REL, F_prompt
  , VAL, "relative size", F_default_, VAL, 60, F_digits, VAL, 1, F_minval, VAL, 10, F_maxval, VAL, 1.5, F_step, VAL, 0.05, F_sunit, VAL, SUNIT_PERCENT);
let SLIDER_TEXT_SIZE_ABS = new std.a_tree("builder","SLIDER_TEXT_SIZE_ABS", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 539, SLIDER_TEXT_SIZE_ABS, F_prompt
  , VAL, "size (pts)", F_default_, VAL, 10, F_digits, VAL, 0, F_minval, VAL, 6, F_maxval, VAL, 150, F_step, VAL, 2, F_sunit, VAL, SUNIT_POINTS);
let SLIDER_TEXT_INDENT = new std.a_tree("builder","SLIDER_TEXT_INDENT", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 540, SLIDER_TEXT_INDENT, F_prompt
  , VAL, "indent", F_default_, VAL, 0, F_digits, VAL, 0, F_minval, VAL, 0, F_maxval, VAL, 50, F_step, VAL, 1, F_sunit, VAL, SUNIT_POINTS);
let SLIDER_TEXT_SPACING = new std.a_tree("builder","SLIDER_TEXT_SPACING", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 541, SLIDER_TEXT_SPACING, F_prompt
  , VAL, "spacing", F_default_, VAL, 0, F_digits, VAL, 0, F_minval, VAL, -10, F_maxval, VAL, 10, F_step, VAL, 1);
let SLIDER_TEXT_LEADING = new std.a_tree("builder","SLIDER_TEXT_LEADING", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 542, SLIDER_TEXT_LEADING, F_prompt
  , VAL, "leading", F_default_, VAL, 112, F_digits, VAL, 0, F_minval, VAL, 80, F_maxval, VAL, 300, F_step, VAL, 10);
let SLIDER_TEXT_VPOS = new std.a_tree("builder","SLIDER_TEXT_VPOS", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 543, SLIDER_TEXT_VPOS, F_prompt, VAL, 
  "vertical pos", F_default_, VAL, 50, F_digits, VAL, 0, F_minval, VAL, 0, F_maxval, VAL, 100, F_step, VAL, 10);
let SLIDER_LINE_THICK = new std.a_tree("builder","SLIDER_LINE_THICK", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 544, SLIDER_LINE_THICK, F_prompt, VAL
  , "thickness", F_default_, VAL, 1, F_digits, VAL, 1, F_minval, VAL, 0.1, F_maxval, VAL, 20, F_step, VAL, 1, F_sunit, VAL, SUNIT_POINTS);
let SLIDER_IMAGE_INDENT = new std.a_tree("builder","SLIDER_IMAGE_INDENT", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 545, SLIDER_IMAGE_INDENT, F_prompt
  , VAL, "indent", F_default_, VAL, 0, F_digits, VAL, 0, F_minval, VAL, 0, F_maxval, VAL, 40, F_step, VAL, 1, F_sunit, VAL, SUNIT_POINTS);
let SLIDER_IMAGE_CORNER = new std.a_tree("builder","SLIDER_IMAGE_CORNER", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 546, SLIDER_IMAGE_CORNER, F_prompt
  , VAL, "corner", F_default_, VAL, 0, F_digits, VAL, 0, F_minval, VAL, 0, F_maxval, VAL, 40, F_step, VAL, 1, F_sunit, VAL, SUNIT_POINTS);
let SLIDER_RECT_CORNER = new std.a_tree("builder","SLIDER_RECT_CORNER", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 547, SLIDER_RECT_CORNER, F_prompt
  , VAL, "corner", F_default_, VAL, 0, F_digits, VAL, 0, F_minval, VAL, 0, F_maxval, VAL, 40, F_step, VAL, 1, F_sunit, VAL, SUNIT_POINTS);
let SLIDER_GRAD_ANGLE = new std.a_tree("builder","SLIDER_GRAD_ANGLE", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 550, SLIDER_GRAD_ANGLE, F_val_ptr, 
  VAL, addr(g, F_work_grad, std.F_grad_angle), F_prompt, VAL, "angle", F_default_, VAL, 0, F_digits, VAL, 0, F_minval, VAL, 0, F_maxval, VAL, 360, F_step, VAL, 5, F_action, 
  VAL, angle_to_graddir_F);
let SLIDER_GRAD_CENTERX = new std.a_tree("builder","SLIDER_GRAD_CENTERX", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 552, SLIDER_GRAD_CENTERX, F_val_ptr
  , VAL, addr(g, F_work_grad, std.F_grad_centerx), F_prompt, VAL, "center x", F_default_, VAL, 0.5, F_digits, VAL, 1, F_minval, VAL, 0, F_maxval, VAL, 1, F_step, VAL, 1);
let SLIDER_GRAD_CENTERY = new std.a_tree("builder","SLIDER_GRAD_CENTERY", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 554, SLIDER_GRAD_CENTERY, F_val_ptr
  , VAL, addr(g, F_work_grad, std.F_grad_centery), F_prompt, VAL, "center y", F_default_, VAL, 0.5, F_digits, VAL, 1, F_minval, VAL, 0, F_maxval, VAL, 1, F_step, VAL, 1);
let SLIDER_GRAD_INNER = new std.a_tree("builder","SLIDER_GRAD_INNER", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 556, SLIDER_GRAD_INNER, F_val_ptr, 
  VAL, addr(g, F_work_grad, std.F_grad_radius_inner), F_prompt, VAL, "inner radius", F_default_, VAL, 0, F_digits, VAL, 1, F_minval, VAL, 0, F_maxval, VAL, 0.5, F_step, VAL, 
  1);
let SLIDER_GRAD_OUTER = new std.a_tree("builder","SLIDER_GRAD_OUTER", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 558, SLIDER_GRAD_OUTER, F_val_ptr, 
  VAL, addr(g, F_work_grad, std.F_grad_radius_outer), F_prompt, VAL, "outer radius", F_default_, VAL, 1, F_digits, VAL, 1, F_minval, VAL, 0.5, F_maxval, VAL, 1, F_step, VAL, 
  0.1);
let SLIDER_GRAD_FOCUSX = new std.a_tree("builder","SLIDER_GRAD_FOCUSX", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 560, SLIDER_GRAD_FOCUSX, F_val_ptr
  , VAL, addr(g, F_work_grad, std.F_grad_focusx), F_prompt, VAL, "focus x", F_default_, VAL, 0.5, F_digits, VAL, 1, F_minval, VAL, 0, F_maxval, VAL, 1, F_step, VAL, 0.1);
let SLIDER_GRAD_FOCUSY = new std.a_tree("builder","SLIDER_GRAD_FOCUSY", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 562, SLIDER_GRAD_FOCUSY, F_val_ptr
  , VAL, addr(g, F_work_grad, std.F_grad_focusy), F_prompt, VAL, "focus y", F_default_, VAL, 0.5, F_digits, VAL, 1, F_minval, VAL, 0, F_maxval, VAL, 1, F_step, VAL, 0.1);
let SLIDER_GRAD_OPACITY = new std.a_tree("builder","SLIDER_GRAD_OPACITY", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 566, SLIDER_GRAD_OPACITY, F_prompt
  , VAL, "opacity", F_default_, VAL, 1, F_digits, VAL, 0, F_minval, VAL, 0, F_maxval, VAL, 1, F_step, VAL, 0.05, F_sunit, VAL, SUNIT_PERCENT);
let SLIDER_GRAD_POS = new std.a_tree("builder","SLIDER_GRAD_POS", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 568, SLIDER_GRAD_POS, F_prompt, VAL, "position"
  , F_default_, VAL, 50, F_digits, VAL, 0, F_minval, VAL, 0, F_maxval, VAL, 100, F_step, VAL, 1, F_action, VAL, delta_grad_pos_F, F_skip_reset, VAL, Y);
let SLIDER_TIMER_RATE = new std.a_tree("builder","SLIDER_TIMER_RATE", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 572, SLIDER_TIMER_RATE, F_prompt, VAL
  , "rate/sec", F_default_, VAL, 1, F_digits, VAL, 0, F_minval, VAL, 1, F_maxval, VAL, 60, F_step, VAL, 1);
let SLIDER_TIMER_DELAY = new std.a_tree("builder","SLIDER_TIMER_DELAY", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 574, SLIDER_TIMER_DELAY, F_prompt
  , VAL, "delay", F_default_, VAL, 0, F_digits, VAL, 0, F_minval, VAL, 0, F_maxval, VAL, 600, F_step, VAL, 10);
let TOOLBARH = U;
let g_stop_centerx = new std.a_tree("builder","g_stop_centerx", std.NF_TOPLEVEL);
let g_stop_centery = new std.a_tree("builder","g_stop_centery", std.NF_TOPLEVEL);
let g_stop_ndy = new std.a_tree("builder","g_stop_ndy", std.NF_TOPLEVEL);
let g_code = null;
let fresh = Y;
let indent = 0;
let GRID_NPARTS = U;
let GRID_NROWS = U;
let GRID_NCOLS = U;
let c_back = U;
let c_text = U;
let SET1 = new std.a_tree("builder","SET1", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED); std.merge_lit(_M, 4261, SET1, 1, F_name, VAL, "ALICE_BLUE", F_color, VAL, std.ALICE_BLUE
  , POP, 2, F_name, VAL, "ANTIQUE_WHITE", F_color, VAL, std.ANTIQUE_WHITE, POP, 3, F_name, VAL, "AQUA", F_color, VAL, std.AQUA, POP, 4, F_name, VAL, "AQUAMARINE", F_color, VAL
  , std.AQUAMARINE, POP, 5, F_name, VAL, "AZURE", F_color, VAL, std.AZURE, POP, 6, F_name, VAL, "BEIGE", F_color, VAL, std.BEIGE, POP, 7, F_name, VAL, "BISQUE", F_color, VAL
  , std.BISQUE, POP, 8, F_name, VAL, "BLANCHED_ALMOND", F_color, VAL, std.BLANCHED_ALMOND, POP, 9, F_name, VAL, "BLUE", F_color, VAL, std.BLUE, POP, 10, F_name, VAL, "BLUE_VIOLET"
  , F_color, VAL, std.BLUE_VIOLET, POP, 11, F_name, VAL, "BROWN", F_color, VAL, std.BROWN, POP, 12, F_name, VAL, "BURLY_WOOD", F_color, VAL, std.BURLY_WOOD, POP, 13, F_name, 
  VAL, "CADET_BLUE", F_color, VAL, std.CADET_BLUE, POP, 14, F_name, VAL, "CHARTREUSE", F_color, VAL, std.CHARTREUSE, POP, 15, F_name, VAL, "CHOCOLATE", F_color, VAL, std.CHOCOLATE
  , POP, 16, F_name, VAL, "CORAL", F_color, VAL, std.CORAL, POP, 17, F_name, VAL, "CORNFLOWER_BLUE", F_color, VAL, std.CORNFLOWER_BLUE, POP, 18, F_name, VAL, "CORNSILK", F_color
  , VAL, std.CORNSILK, POP, 19, F_name, VAL, "CRIMSON", F_color, VAL, std.CRIMSON, POP, 20, F_name, VAL, "CYAN", F_color, VAL, std.CYAN, POP, 21, F_name, VAL, "DARK_BLUE", F_color
  , VAL, std.DARK_BLUE, POP, 22, F_name, VAL, "DARK_CYAN", F_color, VAL, std.DARK_CYAN, POP, 23, F_name, VAL, "DARK_GOLDENROD", F_color, VAL, std.DARK_GOLDENROD, POP, 24, F_name
  , VAL, "DARK_GRAY", F_color, VAL, std.DARK_GRAY, POP, 25, F_name, VAL, "DARK_GREEN", F_color, VAL, std.DARK_GREEN, POP, 26, F_name, VAL, "DARK_KHAKI", F_color, VAL, std.DARK_KHAKI
  , POP, 27, F_name, VAL, "DARK_MAGENTA", F_color, VAL, std.DARK_MAGENTA, POP, 28, F_name, VAL, "DARK_OLIVE_GREEN", F_color, VAL, std.DARK_OLIVE_GREEN, POP, 29, F_name, VAL, 
  "DARK_ORANGE", F_color, VAL, std.DARK_ORANGE, POP, 30, F_name, VAL, "DARK_ORCHID", F_color, VAL, std.DARK_ORCHID, POP, 31, F_name, VAL, "DARK_RED", F_color, VAL, std.DARK_RED
  , POP, 32, F_name, VAL, "DARK_SALMON", F_color, VAL, std.DARK_SALMON, POP, 33, F_name, VAL, "DARK_SEA_GREEN", F_color, VAL, std.DARK_SEA_GREEN, POP, 34, F_name, VAL, "DARK_SLATE_BLUE"
  , F_color, VAL, std.DARK_SLATE_BLUE, POP, 35, F_name, VAL, "DARK_SLATE_GRAY", F_color, VAL, std.DARK_SLATE_GRAY, POP, 36, F_name, VAL, "DARK_TURQUOISE", F_color, VAL, std.DARK_TURQUOISE
  , POP, 37, F_name, VAL, "DARK_VIOLET", F_color, VAL, std.DARK_VIOLET, POP, 38, F_name, VAL, "DEEP_PINK", F_color, VAL, std.DEEP_PINK, POP, 39, F_name, VAL, "DEEP_SKY_BLUE"
  , F_color, VAL, std.DEEP_SKY_BLUE, POP, 40, F_name, VAL, "DIM_GRAY", F_color, VAL, std.DIM_GRAY, POP, 41, F_name, VAL, "DODGER_BLUE", F_color, VAL, std.DODGER_BLUE, POP, 42
  , F_name, VAL, "FIREBRICK", F_color, VAL, std.FIREBRICK, POP, 43, F_name, VAL, "FLORAL_WHITE", F_color, VAL, std.FLORAL_WHITE, POP, 44, F_name, VAL, "FOREST_GREEN", F_color
  , VAL, std.FOREST_GREEN, POP, 45, F_name, VAL, "FUCHSIA", F_color, VAL, std.FUCHSIA, POP, 46, F_name, VAL, "GAINSBORO", F_color, VAL, std.GAINSBORO, POP, 47, F_name, VAL, 
  "GHOST_WHITE", F_color, VAL, std.GHOST_WHITE, POP, 48, F_name, VAL, "GOLD", F_color, VAL, std.GOLD, POP, 49, F_name, VAL, "GOLDENROD", F_color, VAL, std.GOLDENROD, POP, 50
  , F_name, VAL, "GRAY", F_color, VAL, std.GRAY, POP, 51, F_name, VAL, "GREEN", F_color, VAL, std.GREEN, POP, 52, F_name, VAL, "GREEN_YELLOW", F_color, VAL, std.GREEN_YELLOW
  , POP, 53, F_name, VAL, "HONEYDEW", F_color, VAL, std.HONEYDEW, POP, 54, F_name, VAL, "HOT_PINK", F_color, VAL, std.HOT_PINK, POP, 55, F_name, VAL, "INDIAN_RED", F_color, 
  VAL, std.INDIAN_RED, POP, 56, F_name, VAL, "INDIGO", F_color, VAL, std.INDIGO, POP, 57, F_name, VAL, "IVORY", F_color, VAL, std.IVORY, POP, 58, F_name, VAL, "KHAKI", F_color
  , VAL, std.KHAKI, POP, 59, F_name, VAL, "LAVENDER", F_color, VAL, std.LAVENDER, POP, 60, F_name, VAL, "LAVENDER_BLUSH", F_color, VAL, std.LAVENDER_BLUSH, POP, 61, F_name, 
  VAL, "LAWN_GREEN", F_color, VAL, std.LAWN_GREEN, POP, 62, F_name, VAL, "LEMON_CHIFFON", F_color, VAL, std.LEMON_CHIFFON, POP, 63, F_name, VAL, "LIGHT_BLUE", F_color, VAL, 
  std.LIGHT_BLUE, POP, 64, F_name, VAL, "LIGHT_CORAL", F_color, VAL, std.LIGHT_CORAL, POP, 65, F_name, VAL, "LIGHT_CYAN", F_color, VAL, std.LIGHT_CYAN, POP, 66, F_name, VAL, 
  "LIGHT_GOLDENROD", F_color, VAL, std.LIGHT_GOLDENROD, POP, 67, F_name, VAL, "LIGHT_GREEN", F_color, VAL, std.LIGHT_GREEN, POP, 68, F_name, VAL, "LIGHT_GREY", F_color, VAL, 
  std.LIGHT_GREY, POP, 69, F_name, VAL, "LIGHT_PINK", F_color, VAL, std.LIGHT_PINK, POP, 70, F_name, VAL, "LIGHT_SALMON", F_color, VAL, std.LIGHT_SALMON, POP, 71, F_name, VAL
  , "LIGHT_SEA_GREEN", F_color, VAL, std.LIGHT_SEA_GREEN, POP, 72, F_name, VAL, "LIGHT_SKY_BLUE", F_color, VAL, std.LIGHT_SKY_BLUE, POP, 73, F_name, VAL, "LIGHT_SLATE_GRAY", 
  F_color, VAL, std.LIGHT_SLATE_GRAY, POP, 74, F_name, VAL, "LIGHT_STEEL_BLUE", F_color, VAL, std.LIGHT_STEEL_BLUE, POP, 75, F_name, VAL, "LIGHT_YELLOW", F_color, VAL, std.LIGHT_YELLOW
  , POP, 76, F_name, VAL, "LIME", F_color, VAL, std.LIME, POP, 77, F_name, VAL, "LIME_GREEN", F_color, VAL, std.LIME_GREEN, POP, 78, F_name, VAL, "LINEN", F_color, VAL, std.LINEN
  , POP, 79, F_name, VAL, "MAGENTA", F_color, VAL, std.MAGENTA, POP, 80, F_name, VAL, "MAROON", F_color, VAL, std.MAROON, POP, 81, F_name, VAL, "MEDIUM_AQUAMARINE", F_color, 
  VAL, std.MEDIUM_AQUAMARINE, POP, 82, F_name, VAL, "MEDIUM_BLUE", F_color, VAL, std.MEDIUM_BLUE, POP, 83, F_name, VAL, "MEDIUM_ORCHID", F_color, VAL, std.MEDIUM_ORCHID, POP
  , 84, F_name, VAL, "MEDIUM_PURPLE", F_color, VAL, std.MEDIUM_PURPLE, POP, 85, F_name, VAL, "MEDIUM_SEA_GREEN", F_color, VAL, std.MEDIUM_SEA_GREEN, POP, 86, F_name, VAL, "MEDIUM_SLATE_BLUE"
  , F_color, VAL, std.MEDIUM_SLATE_BLUE, POP, 87, F_name, VAL, "MEDIUM_SPRING_GREEN", F_color, VAL, std.MEDIUM_SPRING_GREEN, POP, 88, F_name, VAL, "MEDIUM_TURQUOISE", F_color
  , VAL, std.MEDIUM_TURQUOISE, POP, 89, F_name, VAL, "MEDIUM_VIOLET_RED", F_color, VAL, std.MEDIUM_VIOLET_RED, POP, 90, F_name, VAL, "MIDNIGHT_BLUE", F_color, VAL, std.MIDNIGHT_BLUE
  , POP, 91, F_name, VAL, "MINT_CREAM", F_color, VAL, std.MINT_CREAM, POP, 92, F_name, VAL, "MISTY_ROSE", F_color, VAL, std.MISTY_ROSE, POP, 93, F_name, VAL, "MOCCASIN", F_color
  , VAL, std.MOCCASIN, POP, 94, F_name, VAL, "NAVAJO_WHITE", F_color, VAL, std.NAVAJO_WHITE, POP, 95, F_name, VAL, "NAVY", F_color, VAL, std.NAVY, POP, 96, F_name, VAL, "OLD_LACE"
  , F_color, VAL, std.OLD_LACE, POP, 97, F_name, VAL, "OLIVE", F_color, VAL, std.OLIVE, POP, 98, F_name, VAL, "OLIVE_DRAB", F_color, VAL, std.OLIVE_DRAB, POP, 99, F_name, VAL
  , "ORANGE", F_color, VAL, std.ORANGE, POP, 100, F_name, VAL, "ORANGE_RED", F_color, VAL, std.ORANGE_RED, POP, 101, F_name, VAL, "ORCHID", F_color, VAL, std.ORCHID, POP, 102
  , F_name, VAL, "PALE_GOLDENROD", F_color, VAL, std.PALE_GOLDENROD, POP, 103, F_name, VAL, "PALE_GREEN", F_color, VAL, std.PALE_GREEN, POP, 104, F_name, VAL, "PALE_TURQUOISE"
  , F_color, VAL, std.PALE_TURQUOISE, POP, 105, F_name, VAL, "PALE_VIOLET_RED", F_color, VAL, std.PALE_VIOLET_RED, POP, 106, F_name, VAL, "PAPAYA_WHIP", F_color, VAL, std.PAPAYA_WHIP
  , POP, 107, F_name, VAL, "PEACH_PUFF", F_color, VAL, std.PEACH_PUFF, POP, 108, F_name, VAL, "PERU", F_color, VAL, std.PERU, POP, 109, F_name, VAL, "PINK", F_color, VAL, std.PINK
  , POP, 110, F_name, VAL, "PLUM", F_color, VAL, std.PLUM, POP, 111, F_name, VAL, "POWDER_BLUE", F_color, VAL, std.POWDER_BLUE, POP, 112, F_name, VAL, "PURPLE", F_color, VAL
  , std.PURPLE, POP, 113, F_name, VAL, "REBECCA_PURPLE", F_color, VAL, std.REBECCA_PURPLE, POP, 114, F_name, VAL, "RED", F_color, VAL, std.RED, POP, 115, F_name, VAL, "ROSY_BROWN"
  , F_color, VAL, std.ROSY_BROWN, POP, 116, F_name, VAL, "ROYAL_BLUE", F_color, VAL, std.ROYAL_BLUE, POP, 117, F_name, VAL, "SADDLE_BROWN", F_color, VAL, std.SADDLE_BROWN, POP
  , 118, F_name, VAL, "SALMON", F_color, VAL, std.SALMON, POP, 119, F_name, VAL, "SANDY_BROWN", F_color, VAL, std.SANDY_BROWN, POP, 120, F_name, VAL, "SEA_GREEN", F_color, VAL
  , std.SEA_GREEN, POP, 121, F_name, VAL, "SEASHELL", F_color, VAL, std.SEASHELL, POP, 122, F_name, VAL, "SIENNA", F_color, VAL, std.SIENNA, POP, 123, F_name, VAL, "SILVER", 
  F_color, VAL, std.SILVER, POP, 124, F_name, VAL, "SKY_BLUE", F_color, VAL, std.SKY_BLUE, POP, 125, F_name, VAL, "SLATE_BLUE", F_color, VAL, std.SLATE_BLUE, POP, 126, F_name
  , VAL, "SLATE_GRAY", F_color, VAL, std.SLATE_GRAY, POP, 127, F_name, VAL, "SNOW", F_color, VAL, std.SNOW, POP, 128, F_name, VAL, "SPRING_GREEN", F_color, VAL, std.SPRING_GREEN
  , POP, 129, F_name, VAL, "STEEL_BLUE", F_color, VAL, std.STEEL_BLUE, POP, 130, F_name, VAL, "TAN", F_color, VAL, std.TAN, POP, 131, F_name, VAL, "TEAL", F_color, VAL, std.TEAL
  , POP, 132, F_name, VAL, "THISTLE", F_color, VAL, std.THISTLE, POP, 133, F_name, VAL, "TOMATO", F_color, VAL, std.TOMATO, POP, 134, F_name, VAL, "TURQUOISE", F_color, VAL, 
  std.TURQUOISE, POP, 135, F_name, VAL, "VIOLET", F_color, VAL, std.VIOLET, POP, 136, F_name, VAL, "WHEAT", F_color, VAL, std.WHEAT, POP, 137, F_name, VAL, "WHITE_SMOKE", F_color
  , VAL, std.WHITE_SMOKE, POP, 138, F_name, VAL, "YELLOW", F_color, VAL, std.YELLOW, POP, 139, F_name, VAL, "YELLOW_GREEN", F_color, VAL, std.YELLOW_GREEN, POP);
let NCOLS = U;
let NROWS = U;
let NCELLS = U;
let BARV = U;
let slotlist = new std.a_tree("builder","slotlist", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED);
let gsc = new std.a_tree("builder","gsc", std.NF_TOPLEVEL|std.NF_STATEFUL|std.NF_LOGGED);
let chip_h = U;
let hilite = U;

//====================
//   add_textsize_slider
//====================
function add_textsize_slider(b, ctl) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, TOOL_LABEL, std.al, add_textsize_slider_2985_F, 0, [ctl]);
  k.div_add(b, U, 0, 9, std.al, draw_choice_grid_F, 0, [addr(g, F_text_size_grid), 0.5]);
  k.div_spa(b, 0, TOOL_MID_INDENT, std.al);
  k.div_add(b, U, 0, TOOL_ENTRYBOX, std.al, d_slider_assy_F, 0, [ctl]);
  if (std.eq2(slider_getv(ctl), getn(ctl, F_default_))) {
    k.div_spa(b, 0, TOOL_RINDENT, std.al);
  } else {
    k.div_add(b, U, 0, TOOL_RINDENT, std.al, d_resetdot_F, 0, [ctl]);
  }
k.div_end(b);
k.k_leave(b);
}


//====================
//   add_tool_bbox
//====================
function add_tool_bbox(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, TOOL_LABEL, std.al, add_tool_bbox_2875_F, 0);
  k.div_add(b, U, 0, TOOL_ENTRYBOX, std.al, draw_entry_F, 0, [{ hint:gets(g, F_intf_bbox) }]);
  k.div_spa(b, 0, TOOL_RINDENT, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   add_tool_color
//====================
function add_tool_color(b, label, ctl) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, TOOL_LABEL, std.al, add_tool_color_2911_F, 0, [label, ctl]);
  k.div_add(b, U, 0, TOOL_ENTRYBOX, std.al, draw_color_entry_F, 0, [ctl]);
  k.div_spa(b, 0, TOOL_RINDENT, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   add_tool_corner
//====================
function add_tool_corner(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, TOOL_LABEL, std.al, add_tool_corner_2956_F, 0);
  k.div_add(b, U, 0, 9, std.al, draw_choice_grid_F, 0, [addr(g, F_ncorner_grid), 0.5]);
  k.div_spa(b, 0, TOOL_MID_INDENT, std.al);
  const VV = std.div(std.sub(TOOL_ENTRYBOX, 3), 4);
  if (std.eq2(getn(g, F_ncorner_grid, F_selx), 1)) {
    k.div_add(b, U, 0, TOOL_ENTRYBOX, std.al, d_slider_assy_F, 0, [addr(SLIDER_RECT_CORNER)]);
  } else {
    k.div_add(b, U, 0, VV, std.al, draw_entry_F, 0, [{ hint:gets(g, F_intf_corner1) }]);
    k.div_spa(b, 0, 1, std.al);
    k.div_add(b, U, 0, VV, std.al, draw_entry_F, 0, [{ hint:gets(g, F_intf_corner2) }]);
    k.div_spa(b, 0, 1, std.al);
    k.div_add(b, U, 0, VV, std.al, draw_entry_F, 0, [{ hint:gets(g, F_intf_corner3) }]);
    k.div_spa(b, 0, 1, std.al);
    k.div_add(b, U, 0, VV, std.al, draw_entry_F, 0, [{ hint:gets(g, F_intf_corner4) }]);
  }
  k.div_spa(b, 0, TOOL_RINDENT, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   add_tool_effects1
//====================
function add_tool_effects1(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, 12, std.al, draw_toggle_F, 0, ["HTML", addr(g, F_intf_text_html)]);
  k.div_spa(b, 0, 2, std.al);
  k.div_add(b, U, 0, 12, std.al, draw_toggle_F, 0, ["Bold", addr(g, F_intf_text_bold)]);
  k.div_spa(b, 0, 2, std.al);
  k.div_add(b, U, 0, 12, std.al, draw_toggle_F, 0, ["Italic", addr(g, F_intf_text_italic)]);
  k.div_spa(b, 0, TOOL_RINDENT, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   add_tool_effects2
//====================
function add_tool_effects2(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, 12, std.al, draw_toggle_F, 0, ["Wrap", addr(g, F_intf_text_wrap)]);
  k.div_spa(b, 0, 2, std.al);
  k.div_add(b, U, 0, 12, std.al, draw_toggle_F, 0, ["Hide U", addr(g, F_intf_text_hideu)]);
  k.div_spa(b, 0, 2, std.al);
  k.div_add(b, U, 0, 12, std.al, draw_toggle_F, 0, ["Shrink", addr(g, F_intf_text_shrink)]);
  k.div_spa(b, 0, TOOL_RINDENT, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   add_tool_fill
//====================
function add_tool_fill(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, TOOL_LABEL, std.al, add_tool_fill_2899_F, 0);
  k.div_add(b, U, 0, TOOL_ENTRYBOX, std.al, draw_color_entry_F, 0, [addr(g, F_intf_fill_color)]);
  k.div_spa(b, 0, TOOL_RINDENT, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   add_tool_font
//====================
function add_tool_font(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, TOOL_LABEL, std.al, add_tool_font_2919_F, 0);
  k.div_add(b, U, 0, TOOL_ENTRYBOX, std.al, draw_font_entry_F, 0, [addr(g, F_intf_font)]);
  k.div_spa(b, 0, TOOL_RINDENT, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   add_tool_image
//====================
function add_tool_image(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, TOOL_LABEL, std.al, add_tool_image_2883_F, 0);
  k.div_add(b, U, 0, TOOL_ENTRYBOX, std.al, draw_entry_F, 0);
  k.div_spa(b, 0, TOOL_RINDENT, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   add_tool_imagef
//====================
function add_tool_imagef(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, 12, std.al, draw_toggle_F, 0, ["Allow shrink", addr(g, F_intf_image_shrink)]);
  k.div_spa(b, 0, 1, std.al);
  k.div_add(b, U, 0, 12, std.al, draw_toggle_F, 0, ["Allow grow", addr(g, F_intf_image_grow)]);
  k.div_spa(b, 0, 1, std.al);
  k.div_add(b, U, 0, 16, std.al, draw_toggle_F, 0, ["Keep aspect ratio", addr(g, F_intf_image_aspect)]);
  k.div_spa(b, 0, TOOL_RINDENT, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   add_tool_just
//====================
function add_tool_just(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, TOOL_LABEL, std.al, add_tool_just_2833_F, 0);
  k.div_add(b, U, 0, TOOL_ENTRYBOX, std.al, draw_choice_grid_F, 0, [addr(g, F_text_just_grid), 0.5]);
  k.div_spa(b, 0, TOOL_RINDENT, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   add_tool_linecap
//====================
function add_tool_linecap(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, TOOL_LABEL, std.al, add_tool_linecap_2815_F, 0);
  k.div_add(b, U, 0, TOOL_ENTRYBOX, std.al, draw_choice_grid_F, 0, [addr(g, F_line_cap_grid), 0.5]);
  k.div_spa(b, 0, TOOL_RINDENT, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   add_tool_num
//====================
function add_tool_num(b, prompt, data, _o=null) {
var min = U; if ((_o != null) && _o.hasOwnProperty("min")) min = _o.min;
var max = U; if ((_o != null) && _o.hasOwnProperty("max")) max = _o.max;
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, TOOL_LABEL, std.al, add_tool_num_2932_F, 0, [prompt, data, min, max, {}]);
  k.div_add(b, U, 0, TOOL_ENTRYBOX, std.al, draw_entry_F, 0, [{ hint:data }]);
  k.div_spa(b, 0, TOOL_RINDENT, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   add_tool_point
//====================
function add_tool_point(b, prompt) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, TOOL_LABEL, std.al, add_tool_point_3267_F, 0, [prompt]);
  k.div_spa(b, 0, TOOL_MID_INDENT, std.al);
  k.div_add(b, U, 0, TOOL_ENTRYBOX, std.al, draw_entry_F, 0);
  k.div_spa(b, 0, TOOL_RINDENT, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   add_tool_slider
//====================
function add_tool_slider(b, ctl) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, TOOL_LABEL, std.al, add_tool_slider_2942_F, 0, [ctl]);
  k.div_add(b, U, 0, TOOL_ENTRYBOX, std.al, d_slider_assy_F, 0, [ctl]);
  if ((std.eq2(slider_getv(ctl), getn(ctl, F_default_)) || getn(ctl, F_skip_reset) === Y)) {
    k.div_spa(b, 0, TOOL_RINDENT, std.al);
  } else {
    k.div_add(b, U, 0, TOOL_RINDENT, std.al, d_resetdot_F, 0, [ctl]);
  }
k.div_end(b);
k.k_leave(b);
}


//====================
//   add_tool_str
//====================
function add_tool_str(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, TOOL_LABEL, std.al, add_tool_str_2891_F, 0);
  k.div_add(b, U, 0, TOOL_ENTRYBOX, std.al, draw_entry_F, 0);
  k.div_spa(b, 0, TOOL_RINDENT, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   butt_block_add
//====================
function butt_block_add(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 10, std.al);
  k.div_add(b, U, 0, 40, std.al, draw_oneshot_F, 0, ["Add", do_block_add_F, {}]);
  k.div_spa(b, 0, 10, std.al);
  k.div_add(b, U, 0, 50, std.al, draw_entry_F, 0);
  k.div_spa(b, 0, 3, std.al);
  k.div_add(b, U, 0, 40, std.al, draw_dropdown_F, 0, [addr(g, F_block_add_unit_grid)]);
  k.div_spa(b, 0, 5, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   butt_block_dup
//====================
function butt_block_dup(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 10, std.al);
  k.div_add(b, U, 0, 40, std.al, draw_oneshot_F, 0, ["Dup", do_block_dup_F, {}]);
  k.div_spa(b, 0, 10, std.al);
  k.div_add(b, U, 0, 40, std.al, draw_oneshot_F, 0, ["Del", do_block_del_F, {}]);
  k.div_spa(b, 0, 3, std.al);
  k.div_spa(b, 0, 55, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   butt_block_skip
//====================
function butt_block_skip(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 10, std.al);
  k.div_add(b, U, 0, 40, std.al, draw_oneshot_F, 0, ["Skip", do_block_skip_F, {}]);
  k.div_spa(b, 0, 10, std.al);
  k.div_add(b, U, 0, 50, std.al, draw_entry_F, 0);
  k.div_spa(b, 0, 3, std.al);
  k.div_add(b, U, 0, 40, std.al, draw_dropdown_F, 0, [addr(g, F_block_skip_unit_grid)]);
  k.div_spa(b, 0, 5, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   butt_grad_stop
//====================
function butt_grad_stop(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 8, std.al);
  k.div_add(b, U, 0, 14, std.al, draw_oneshot_F, 0, ["Add stop", do_stop_add_F, {}]);
  k.div_spa(b, 0, 8, std.al);
  if ((getn(g, F_work_grad_stopx) !== U && std.gt2(std.tree_count(addr(g, F_work_grad, std.F_grad_stops)), 2))) {
    k.div_add(b, U, 0, 14, std.al, draw_oneshot_F, 0, ["Del stop", do_stop_del_F, {}]);
  } else {
    k.div_spa(b, 0, 14, std.al);
  }
  k.div_spa(b, 0, 8, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   butt_modal_cancel
//====================
function butt_modal_cancel(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 30, std.al);
  k.div_add(b, U, 0, 120, std.pt, d_oneshot_F, 0, ["Cancel", do_modal_cancel_F]);
  k.div_spa(b, 0, 30, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   track_butt_modal_cancel
//====================
function track_butt_modal_cancel(b, e) {
  //---------------
  //   on EV_KEYBOARD
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_KEYBOARD) {
    if (std.eq2(getn(e, std.F_keycode), std.KEYCODE_ESC)) {
      do_modal_cancel();
    }
  return Y;
  }
  return N;
}

//====================
//   butt_work_cancel
//====================
function butt_work_cancel(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  const GAP = 8;
  k.div_spa(b, 0, GAP, std.al);
  k.div_add(b, U, 0, 12, std.al, draw_oneshot_F, 0, ["Cancel", do_work_cancel_F, {}]);
  k.div_spa(b, 0, GAP, std.al);
  if (std.ne2(gets(g, F_work_name_in, std.F_in_value), "")) {
    k.div_add(b, U, 0, 12, std.al, draw_oneshot_F, 0, ["OK", do_work_ok_F, { enterkey:Y }]);
  } else {
    k.div_spa(b, 0, 12, std.al);
  }
  k.div_spa(b, 0, GAP, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   track_butt_work_cancel
//====================
function track_butt_work_cancel(b, e) {
  //---------------
  //   on EV_KEYBOARD
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_KEYBOARD) {
    if (std.eq2(getn(e, std.F_keycode), std.KEYCODE_ESC)) {
      do_work_cancel();
    }
  return Y;
  }
  return N;
}

//====================
//   d_arrow_down
//====================
function d_arrow_down(b, V) {
k.k_enter(b);
  const ARROWV = std.mul(8, V);
  const ARROWH = std.mul(10, V);
  const HALF = std.mul(5, V);
  let left = b.bounds.left;
  let top = std.add(b.bounds.top, std.mul(10, V));
  let lower = new std.a_tree("builder","lower"); std.merge_tree(_M, 1284, std.table_litP(std.F_x, std.F_y, VAL, std.add(left, HALF), std.add(top, ARROWV), VAL, std.add(left, 
    ARROWH), top, VAL, std.add(left, 0), top), addr(lower));
  std.draw_polygon(b, addr(lower), { fill:BUTT_LO_TEXT });
k.k_leave(b);
}


//====================
//   d_asset_path
//====================
function d_asset_path(b, fpath) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), fpath, { size:0.7, just:std.LEFT, indent:std.pt_to_dots(b, 4), color:C_TOOL_LABEL, shrink_min:std.pt_to_dots(b, 10) });
k.k_leave(b);
}


//====================
//   d_asset_spec
//====================
function d_asset_spec(b, localfolder, item) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 15, std.al);
  k.div_add(b, U, 0, 14, std.al, d_asset_spec_2177_F, 0, [localfolder, item]);
  k.div_add(b, U, 0, 91, std.al, d_asset_spec_2191_F, 0, [localfolder, item]);
  if (getn(item, std.F_width) !== U) {
    k.div_add(b, U, 0, 30, std.al, d_asset_spec_2194_F, 0, [localfolder, item]);
  } else {
    k.div_spa(b, 0, 30, std.al);
  }
k.div_end(b);
k.k_leave(b);
}


//====================
//   track_d_asset_spec
//====================
function track_d_asset_spec(b, e, localfolder, item) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    var case1387 = str_suffix(gets(item, F_fpath));
    if (case1387 === ".mp3" || case1387 === ".aac" || case1387 === ".wav") {
      std.sound_play_file(std.cat(localfolder, gets(item, F_fpath)));
    }
  return Y;
  }
  return N;
}

//====================
//   d_botbar
//====================
function d_botbar(b) {
k.k_enter(b);
  var case1388 = getn(g, F_bar_tabx);
  if (case1388 === PICKER_COLOR_TABS) {
    var case1389 = getn(g, F_bar_tabs, PICKER_COLOR_TABS, F_selx);
    if (case1389 === 1) {
      not_yet(b);
    } else if (case1389 === 2) {
      html_palette_init();
      html_palette_resize(b);
      k.k_isolate(b, b.bounds, "html_palette_draw", html_palette_draw_F, []);
    } else if (case1389 === 3) {
      ferrari_palette_draw(b);
    }
  } else if (case1388 === PICKER_FONT_TABS) {
    k.k_isolate(b, b.bounds, "draw_font_picker", draw_font_picker_F, []);
  }
k.k_leave(b);
}


//====================
//   d_color_sample
//====================
function d_color_sample(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 20, std.al);
  k.div_add(b, U, 0, 80, std.al, d_color_sample_3410_F, 0);
  k.div_spa(b, 0, 20, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_color_spec
//====================
function d_color_spec(b, sym) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 15, std.al);
  k.div_add(b, U, 0, 90, std.al, d_color_spec_2233_F, 0, [sym]);
  k.div_add(b, U, 0, 33, std.al, d_color_spec_2237_F, 0, [sym]);
  k.div_spa(b, 0, 12, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   track_d_color_spec
//====================
function track_d_color_spec(b, e, sym) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    do_color_edit(sym);
  return Y;
  }
  return N;
}

//====================
//   d_data_editarea
//====================
function d_data_editarea(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, true);
  std.path_setv(_M, 1174, addr(g, F_work_var, F_name), "foobar");
  if (std.ne2(getn(g, F_work_state), WORK_CLOSED)) {
    k.div_spa(b, 1, 5, std.pt);
    k.div_add(b, U, 1, 16, std.pt, d_data_editarea_1178_F, 0);
    k.div_spa(b, 1, 10, std.pt);
    k.div_add(b, U, 1, 16, std.pt, d_work_var_hdr_F, 0, [addr(g, F_work_var)]);
    k.div_add(b, U, 1, CHOICE_V, std.pt, d_work_var_F, 0, [addr(g, F_work_var)]);
    k.div_spa(b, 1, std.mul(ITEM_DV, 5), std.pt);
    k.div_add(b, U, 1, CHOICE_V, std.pt, butt_work_cancel_F, 0);
    k.div_spa(b, 1, 4, std.pt);
  }
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_data_recpick
//====================
function d_data_recpick(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, true);
  let nlev = U;
  k.div_spa(b, 1, 2, std.pt);
  k.div_add(b, U, 1, SECTION_V, std.pt, d_sectdiv_F, 0, [addr(g, F_div_recs)]);
  if (getn(g, F_div_recs, F_is_expanded) === Y) {
    k.div_spa(b, 1, 1, std.pt);
    var loop1390 = new std.a_loop({ across:addr(doc, F_syms, std.NK_RECORD), sort_mode:4, sort_field:F_name });
    while (loop1390.next()) {
    var ix = loop1390.index;
    var recsym = loop1390.path.clone();
      if (getn(recsym, F_is_stdlib) !== Y) {
        nlev = 1;
        k.div_add(b, U, 1, TOOL_ROWV, std.pt, d_rec_name_F, 0, [nlev, gets(recsym, F_name)]);
        if (getn(recsym, F_rec_spec, F_is_expanded) === Y) {
          nlev = std.add(nlev, 1);
          var loop1391 = new std.a_loop({ across:addr(recsym, F_rec_spec, F_fields) });
          while (loop1391.next()) {
          var fieldp = loop1391.path.clone();
            k.div_add(b, U, 1, 14, std.pt, d_rec_field_F, 0, [nlev, fieldp]);
          }
          nlev = std.sub(nlev, 1);
        }
        k.div_spa(b, 1, 5, std.pt);
      }
    }
  }
  k.div_spa(b, 1, 2, std.pt);
  k.div_add(b, U, 1, SECTION_V, std.pt, d_sectdiv_F, 0, [addr(g, F_div_recs2)]);
  if (getn(g, F_div_recs2, F_is_expanded) === Y) {
    k.div_spa(b, 1, 1, std.pt);
    var loop1392 = new std.a_loop({ across:addr(lib_syms, std.NK_RECORD), sort_mode:4, sort_field:F_name });
    while (loop1392.next()) {
    var ix = loop1392.index;
    var recsym = loop1392.path.clone();
      if (getn(recsym, F_is_stdlib) === Y) {
        nlev = 1;
        k.div_add(b, U, 1, TOOL_ROWV, std.pt, d_rec_name_F, 0, [nlev, gets(recsym, F_name)]);
        if (getn(recsym, F_rec_spec, F_is_expanded) === Y) {
          nlev = std.add(nlev, 1);
          var loop1393 = new std.a_loop({ across:addr(recsym, F_rec_spec, F_fields) });
          while (loop1393.next()) {
          var fieldp = loop1393.path.clone();
            k.div_add(b, U, 1, 14, std.pt, d_rec_field_F, 0, [nlev, fieldp]);
          }
          nlev = std.sub(nlev, 1);
        }
        k.div_spa(b, 1, 5, std.pt);
      }
    }
  }
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_div_add
//====================
function d_div_add(b, div) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_add(b, U, 1, 84, std.al, draw_oneshot_F, 0, ["Add", std.get_func(div, F_action_add), {}]);
  k.div_spa(b, 1, 16, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_div_del
//====================
function d_div_del(b, div) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_add(b, U, 1, 84, std.al, draw_oneshot_F, 0, ["Del", std.get_func(div, F_action_del), {}]);
  k.div_spa(b, 1, 16, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_double_arrows
//====================
function d_double_arrows(b, V) {
k.k_enter(b);
  const ARROWV = std.mul(8, V);
  const ARROWH = std.mul(8, V);
  const HALF = std.mul(ARROWH, 0.5);
  let r = new std.a_tree("builder","r"); std.merge_tree(_M, 1298, std.solve_rect({ basis:addr(b.extra, std.F_box), pin:5, inset_y:std.mul(3, V), width:std.mul(10, V) }), addr(
  r));
  let upper = new std.a_tree("builder","upper"); std.merge_tree(_M, 1300, std.table_litP(std.F_x, std.F_y, VAL, std.add(getn(r, std.F_left), HALF), std.add(getn(r, std.F_top
    ), std.mul(2, V)), VAL, std.add(getn(r, std.F_left), ARROWH), std.add(getn(r, std.F_top), ARROWV), VAL, std.add(getn(r, std.F_left), 0), std.add(getn(r, std.F_top), ARROWV
    )), addr(upper));
  std.draw_polygon(b, addr(upper), { fill:BUTT_LO_TEXT });
  let bot = std.add(getn(r, std.F_top), getn(r, std.F_height));
  let lower = new std.a_tree("builder","lower"); std.merge_tree(_M, 1308, std.table_litP(std.F_x, std.F_y, VAL, std.add(getn(r, std.F_left), HALF), std.sub(bot, std.mul(2, V
    )), VAL, std.add(getn(r, std.F_left), ARROWH), std.sub(bot, ARROWV), VAL, std.add(getn(r, std.F_left), 0), std.sub(bot, ARROWV)), addr(lower));
  std.draw_polygon(b, addr(lower), { fill:BUTT_LO_TEXT });
k.k_leave(b);
}


//====================
//   d_dtriangle
//====================
function d_dtriangle(b, expandf, indentx, indenty) {
k.k_enter(b);
  let r = new std.a_tree("builder","r");
  if (expandf === Y) {
    std.copy_tree(_M, 2352, std.solve_rect({ basis:addr(b.extra, std.F_box), pin:5, inset_x:std.mul(b.bounds.width, indentx), inset_y:std.add(std.mul(b.bounds.height, indenty)
    , std.pt_to_dots(b, 1)), dy:std.pt_to_dots(b, 1) }), addr(r));
  } else {
    std.copy_tree(_M, 2355, std.solve_rect({ basis:addr(b.extra, std.F_box), pin:5, inset_x:std.mul(b.bounds.width, indentx), inset_y:std.add(std.mul(b.bounds.height, indenty)
    , std.pt_to_dots(b, 1)) }), addr(r));
  }
  let rr = std.add(getn(r, std.F_left), getn(r, std.F_width));
  let rb = std.add(getn(r, std.F_top), getn(r, std.F_height));
  if (expandf === Y) {
    const F = std.pt_to_dots(b, 2);
    let t_down = new std.a_tree("builder","t_down"); std.merge_lit(_M, 2362, t_down, 1, std.F_x, VAL, getn(r, std.F_left), std.F_y, VAL, getn(r, std.F_top), POP, 2, std.F_x, VAL
      , rr, std.F_y, VAL, getn(r, std.F_top), POP, 3, std.F_x, VAL, std.add(getn(r, std.F_left), std.mul(getn(r, std.F_width), 0.5)), std.F_y, VAL, rb, POP);
    std.draw_polygon(b, addr(t_down), { fill:0x11CA2A });
  } else {
    let t_right = new std.a_tree("builder","t_right"); std.merge_lit(_M, 2366, t_right, 1, std.F_x, VAL, getn(r, std.F_left), std.F_y, VAL, getn(r, std.F_top), POP, 2, std.F_x
      , VAL, getn(r, std.F_left), std.F_y, VAL, rb, POP, 3, std.F_x, VAL, rr, std.F_y, VAL, std.add(getn(r, std.F_top), std.mul(getn(r, std.F_height), 0.5)), POP);
    std.draw_polygon(b, addr(t_right), { fill:BUTT_LO_TEXT });
  }
k.k_leave(b);
}


//====================
//   d_dtype_picker
//====================
function d_dtype_picker(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:0x507D99, corner:std.pt_to_dots(b, 10), color:BUTT_LO_BORD, pos:0, thick:std.pt_to_dots(b, 4) });
  k.div_spa(b, 1, 8, std.pt);
  k.div_add(b, U, 1, CHOICE_V, std.pt, draw_tabs_F, 0, [addr(g, F_dtype_set_tabs), 10]);
  k.div_add(b, U, 1, 2, std.pt, d_dtype_picker_1070_F, 0);
  k.div_add(b, U, 1, 100, std.al, pick_dtype_F, 0, [addr(g, F_dtype_choices, getn(g, F_dtype_set_tabs, F_selx))]);
  k.div_spa(b, 1, 8, std.pt);
  k.div_add(b, U, 1, CHOICE_V, std.pt, butt_modal_cancel_F, 0);
  k.div_spa(b, 1, 8, std.pt);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_enum_spec
//====================
function d_enum_spec(b, sym) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 15, std.al);
  k.div_add(b, U, 0, 135, std.al, d_enum_spec_2222_F, 0, [sym]);
k.div_end(b);
k.k_leave(b);
}


//====================
//   track_d_enum_spec
//====================
function track_d_enum_spec(b, e, sym) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    do_enum_edit(sym);
  return Y;
  }
  return N;
}

//====================
//   d_ferrari_grid
//====================
function d_ferrari_grid(b) {
k.k_enter(b);
k.div_begin(b, true, true, false, false);
  var loop1394 = new std.a_loop({ limit:FERR_NCOL });
  while (loop1394.next()) {
    k.div_add(b, U, 0, 10, std.al, d_ferrari_grid_cell_F, 0);
  }
  var loop1395 = new std.a_loop({ limit:FERR_NROW });
  while (loop1395.next()) {
    k.div_add(b, U, 1, 10, std.al, d_ferrari_grid_cell_F, 0);
  }
  k.div_end(b);
  k.draw_grid(b);
k.k_leave(b);
}


//====================
//   d_ferrari_grid_cell
//====================
function d_ferrari_grid_cell(b) {
  k.k_enter(b);
  if (std.eq2(getn(b.extra, std.F_cell_seq), 1)) {
    ferr_first_ramp(b);
  } else {
    ferr_ramp(b, getn(b.extra, std.F_cell_seq));
  }
  k.k_leave(b);
}

//====================
//   d_font_example
//====================
function d_font_example(b, fontname) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  if (std.eq2(fontname, gets(g, F_fontpicker_targ_ptr, std.FOL, F_font_exp))) {
    c_back = BUTT_HI_BACK;
    c_text = BUTT_HI_TEXT;
  } else {
    c_back = std.GRAY7;
    c_text = BUTT_LO_TEXT;
  }
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:c_back });
  k.div_spa(b, 0, 10, std.pt);
  k.div_add(b, U, 0, 100, std.pt, d_font_example_4239_F, 0, [fontname]);
  k.div_spa(b, 0, 14, std.pt);
  k.div_add(b, U, 0, 100, std.al, d_font_example_4242_F, 0, [fontname]);
  k.div_spa(b, 0, 4, std.pt);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_gradient_bar
//====================
function d_gradient_bar(b) {
k.k_enter(b);
  let total = new std.a_tree("builder","total"); std.merge_tree(_M, 2456, std.solve_rect({ basis:addr(b.extra, std.F_box), inset_x:std.pt_to_dots(b, 6), round:Y }), addr(total
  ));
  let bar = new std.a_tree("builder","bar"); std.merge_tree(_M, 2457, std.solve_rect({ basis:addr(total), pin:2, height:std.pt_to_dots(b, 20), round:Y }), addr(bar));
  let bot = new std.a_tree("builder","bot"); std.merge_tree(_M, 2458, std.solve_rect({ basis:addr(total), top:getn(bar, std.F_height), round:Y }), addr(bot));
  let tempg = new std.a_tree("builder","tempg"); std.merge_tree(_M, 2462, addr(g, F_work_grad), addr(tempg));
  std.path_setv(_M, 2463, addr(tempg, std.F_grad_shape), std.LINEAR_GRADIENT);
  std.path_setv(_M, 2464, addr(tempg, std.F_grad_angle), std.GRAD_TO_RIGHT);
  std.draw_rect(b, addr(bar), { grad:addr(tempg) });
  var loop1396 = new std.a_loop({ across:addr(g, F_work_grad, std.F_grad_stops) });
  while (loop1396.next()) {
  var cx = loop1396.count;
  var ix = loop1396.index;
    d_stop_icon(b, addr(bar), addr(bot), ix, cx, std.eq4(ix, getn(g, F_work_grad_stopx)));
  }
k.k_leave(b);
}


//====================
//   track_d_gradient_bar
//====================
function track_d_gradient_bar(b, e) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    let closest_dist = std.INFINITY;
    let closest_ix = U;
    let dist = U;
    let dx = U;
    let dy = U;
    var loop1397 = new std.a_loop({ across:addr(g_stop_centerx) });
    while (loop1397.next()) {
    var cx = loop1397.count;
    var ix = loop1397.index;
      dx = std.sub(getn(e, std.F_x), getn(g_stop_centerx, cx));
      dy = std.sub(getn(e, std.F_y), getn(g_stop_centery, cx));
      dist = std.add(std.mul(dx, dx), std.mul(dy, dy));
      if (std.lt2(dist, closest_dist)) {
        closest_dist = dist;
        closest_ix = ix;
      }
    }
    intf_load_band(closest_ix);
  return Y;
  }
  return N;
}

//====================
//   d_gradient_kind_assy
//====================
function d_gradient_kind_assy(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 8, std.al);
  k.div_add(b, U, 0, 100, std.al, draw_choice_grid_F, 0, [addr(g, F_work_grad_shape), 0.65]);
  k.div_spa(b, 0, 12, std.al);
  if (std.eq2(getn(g, F_work_grad_shape, F_selx), 1)) {
    k.div_add(b, U, 0, 140, std.al, draw_choice_grid_F, 0, [addr(g, F_work_grad_dir), 0.75]);
  } else {
    k.div_spa(b, 0, 140, std.al);
  }
  k.div_spa(b, 0, 8, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_gradient_sample
//====================
function d_gradient_sample(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  let outer = new std.a_tree("builder","outer"); std.merge_tree(_M, 2696, std.solve_rect({ basis:addr(b.extra, std.F_box), inset_x:std.div(b.bounds.width, 8) }), addr(outer)
  );
  let inner = new std.a_tree("builder","inner"); std.merge_tree(_M, 2697, std.solve_rect({ basis:addr(outer), inset:std.div(getn(outer, std.F_height), 8) }), addr(inner));
  std.draw_rect(b, addr(outer), { tile:CHECKERBOARD });
  var case1398 = getn(g, F_work_grad, std.F_grad_shape);
  if (case1398 === std.LINEAR_GRADIENT) {
    std.draw_rect(b, addr(inner), { grad:addr(g, F_work_grad), thick:std.pt_to_dots(b, 1), color:std.BLACK, corner:std.pt_to_dots(b, 10) });
  } else if (case1398 === std.RADIAL_GRADIENT) {
    std.draw_oval(b, addr(inner), { grad:addr(g, F_work_grad), thick:std.pt_to_dots(b, 1), color:std.BLACK });
  }
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_gradient_spec
//====================
function d_gradient_spec(b, sym) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 15, std.al);
  k.div_add(b, U, 0, 90, std.al, d_gradient_spec_2250_F, 0, [sym]);
  k.div_add(b, U, 0, 33, std.al, d_gradient_spec_2252_F, 0, [sym]);
  k.div_spa(b, 0, 12, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   track_d_gradient_spec
//====================
function track_d_gradient_spec(b, e, sym) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    do_gradient_edit(sym);
  return Y;
  }
  return N;
}

//====================
//   d_gutter
//====================
function d_gutter(b) {
k.k_enter(b);
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:0x202020 });
k.k_leave(b);
}


//====================
//   d_modal_dtype_picker
//====================
function d_modal_dtype_picker(b) {
k.k_enter(b);
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:DEAD_COLOR, opacity:0.8 });
  let ww = std.min(std.mul(b.bounds.width, 0.9), std.pt_to_dots(b, 600));
  let hh = std.min(std.mul(b.bounds.height, 0.8), std.pt_to_dots(b, 280));
  let tt = std.mul(std.sub(b.bounds.height, hh), 0.2);
  let r = new std.a_tree("builder","r"); std.merge_tree(_M, 1057, std.solve_rect({ basis:addr(b.extra, std.F_box), pin:5, width:ww, height:hh, top:tt }), addr(r));
  var b33=k.k_layer(b, d_dtype_picker_F, { area:r });
  d_dtype_picker(b33);
k.k_leave(b);
}


//====================
//   track_d_modal_dtype_picker
//====================
function track_d_modal_dtype_picker(b, e) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    std.sound_play(THUD, {});
  return Y;
  }
  return N;
}

//====================
//   d_name_close
//====================
function d_name_close(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, TOOL_LABEL, std.al, d_name_close_2731_F, 0);
  k.div_add(b, U, 0, 52, std.al, d_name_close_2733_F, 0);
  k.div_spa(b, 0, 2, std.al);
  k.div_add(b, U, 0, 20, std.al, draw_oneshot_F, 0, ["Close", do_close_doc_F, {}]);
  k.div_spa(b, 0, 2, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_name_entry
//====================
function d_name_entry(b, field) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, TOOL_LABEL, std.al, d_name_entry_2748_F, 0, [field]);
  k.div_add(b, U, 0, 71, std.al, d_name_entry_2750_F, 0, [field]);
  k.div_spa(b, 0, TOOL_RINDENT, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_namelist
//====================
function d_namelist(b) {
k.k_enter(b);
k.div_begin(b, true, false, false, true);
  build_namelist();
  k.div_spa(b, 0, 10, std.pt);
  k.div_add(b, U, 0, 14, std.al, d_namelist_cell_F, 0);
  k.div_spa(b, 0, 10, std.pt);
  k.div_add(b, U, 0, 10, std.al, d_namelist_cell_F, 0);
  k.div_spa(b, 0, 10, std.pt);
  let vv = std.le2(std.tree_count(addr(sorted_syms)), 40) ? 16 : 12;
  var loop1399 = new std.a_loop({ across:addr(sorted_syms) });
  while (loop1399.next()) {
    k.div_add(b, U, 1, vv, std.pt, d_namelist_cell_F, 0);
    k.div_spa(b, 1, 2, std.pt);
  }
  k.div_end(b);
  k.draw_grid(b);
k.k_leave(b);
}


//====================
//   d_namelist_cell
//====================
function d_namelist_cell(b) {
  k.k_enter(b);
  let sym = std.get_ptr(sorted_syms, getn(b.extra, std.F_cell, std.F_y));
  var case1400 = getn(b.extra, std.F_cell, std.F_x);
  if (case1400 === 1) {
    let name = gets(sym, F_name);
    if (std.eq2(sym, std.get_ptr(g, F_work_sym))) {
      std.draw_rect(b, addr(b.extra, std.F_box), { fill:std.FIREBRICK });
    }
    std.draw_str(b, addr(b.extra, std.F_box), name, { just:std.LEFT, size:0.7, indent:std.pt_to_dots(b, 20), color:C_TOOL_LABEL });
    if (std.eq2(name, gets(g, F_intf_namelist_mru))) {
      std.draw_str(b, addr(b.extra, std.F_box), "", { just:std.LEFT, size:0.7, color:std.GREEN });
    }
  } else if (case1400 === 2) {
    var case1401 = getn(g, F_work_nk);
    if (case1401 === std.NK_GRAD) {
      std.draw_rect(b, addr(b.extra, std.F_box), { grad:addr(sym, F_grad) });
    }
  }
  k.k_leave(b);
}

//====================
//   track_d_namelist
//====================
function track_d_namelist(b, e) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    if (getn(b.extra, std.F_cell, std.F_y) === U) {
      std.sound_play(BEEP, {});
    } else {
      std.path_setv(_M, 3483, addr(g, F_intf_namelist_mru), U);
      std.path_setv(_M, 3484, addr(g, F_work_sym), std.get_ptr(sorted_syms, getn(b.extra, std.F_cell, std.F_y)));
      std.log(std.cat("changing selected name to ", gets(g, F_work_sym, std.FOL, F_name)));
    }
  return Y;
  }
  return N;
}

//====================
//   d_namelist_butts
//====================
function d_namelist_butts(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  const GAP = 8;
  const BUTT = 40;
  k.div_spa(b, 0, GAP, std.al);
  k.div_add(b, U, 0, BUTT, std.al, draw_oneshot_F, 0, ["Add", do_namelist_add_F, {}]);
  k.div_spa(b, 0, GAP, std.al);
  if (std.get_ptr(g, F_work_sym) !== null) {
    k.div_add(b, U, 0, BUTT, std.al, draw_oneshot_F, 0, ["Dup", do_namelist_dup_F, {}]);
    k.div_spa(b, 0, GAP, std.al);
    k.div_add(b, U, 0, BUTT, std.al, draw_oneshot_F, 0, ["Del", do_namelist_del_F, {}]);
  } else {
    k.div_spa(b, 0, BUTT, std.al);
    k.div_spa(b, 0, GAP, std.al);
    k.div_spa(b, 0, BUTT, std.al);
  }
  k.div_spa(b, 0, GAP, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_oneshot
//====================
function d_oneshot(b, prompt, action) {
k.k_enter(b);
  std.draw_rect(b, addr(b.extra, std.F_box), { corner:std.div(b.bounds.height, 4), fill:BUTT_LO_BACK, color:BUTT_LO_BORD, thick:std.pt_to_dots(b, 3) });
  std.draw_str(b, addr(b.extra, std.F_box), prompt, { size:0.6, indent:std.pt_to_dots(b, 1.5), color:BUTT_LO_TEXT });
k.k_leave(b);
}


//====================
//   track_d_oneshot
//====================
function track_d_oneshot(b, e, prompt, action) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    exec_action(prompt, action);
  return Y;
  }
  return N;
}

//====================
//   d_prog_version
//====================
function d_prog_version(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 1, std.al);
  k.div_add(b, U, 0, 12, std.al, d_prog_version_2713_F, 0);
  k.div_spa(b, 0, 1, std.al);
  k.div_add(b, U, 0, 7, std.al, d_prog_version_2716_F, 0);
  k.div_add(b, U, 0, 1.5, std.al, d_prog_version_2718_F, 0);
  k.div_add(b, U, 0, 7, std.al, d_prog_version_2720_F, 0);
  k.div_add(b, U, 0, 1.5, std.al, d_prog_version_2722_F, 0);
  k.div_add(b, U, 0, 7, std.al, d_prog_version_2724_F, 0);
  k.div_spa(b, 0, 5, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_pulldown
//====================
function d_pulldown(b, slotx, label) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  const V = std.div(b.bounds.height, 27);
  const ARROW_TOTH = std.mul(V, 13);
  const LABELH = std.sub(b.bounds.width, ARROW_TOTH);
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:BUTT_LO_BACK, color:BUTT_LO_BORD, thick:std.pt_to_dots(b, 1), corner:std.pt_to_dots(b, 5) });
  k.div_add(b, U, 0, LABELH, std.px, d_pulldown_1252_F, 0, [slotx, label]);
  k.div_add(b, U, 0, ARROW_TOTH, std.px, d_double_arrows_F, 0, [V]);
k.div_end(b);
k.k_leave(b);
}


//====================
//   track_d_pulldown
//====================
function track_d_pulldown(b, e, slotx, label) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    std.path_setv(_M, 1257, addr(g, F_is_modal_dtype), Y);
    std.path_setv(_M, 1258, addr(g, F_dtype_slot), slotx);
    std.path_setv(_M, 1260, addr(g, F_dtype_set_tabs, F_selx), 1);
    std.trunc_tree(_M, 1264, addr(g, F_dtype_choices, 3));
    var loop1402 = new std.a_loop({ across:addr(doc, F_syms, std.NK_RECORD) });
    while (loop1402.next()) {
    var sym = loop1402.path.clone();
      std.append_tree(_M, 1266, std.tree_lit(_M, 1266, F_name, VAL, gets(sym, F_name), F_type, VAL, std.TYPE_RECORD, F_symp, VAL, sym), addr(g, F_dtype_choices, 3));
    }
    std.trunc_tree(_M, 1269, addr(g, F_dtype_choices, 4));
    var loop1403 = new std.a_loop({ across:addr(lib_syms, std.NK_RECORD) });
    while (loop1403.next()) {
    var sym = loop1403.path.clone();
      std.append_tree(_M, 1271, std.tree_lit(_M, 1271, F_name, VAL, gets(sym, F_name), F_type, VAL, std.TYPE_RECORD, F_symp, VAL, sym), addr(g, F_dtype_choices, 4));
    }
  return Y;
  }
  return N;
}

//====================
//   d_rec_field
//====================
function d_rec_field(b, nlev, field) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), std.cat("", gets(field, F_name), " : ", dtype_ss(addr(field, F_dtype))), { size:0.78, just:std.LEFT, indent:std.mul(nlev, std.pt_to_dots(
  b, INDENT_PER)), color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   d_rec_name
//====================
function d_rec_name(b, nlev, name) {
k.k_enter(b);
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:GRAY8L });
  std.draw_str(b, addr(b.extra, std.F_box), name, { size:0.8, just:std.LEFT, indent:std.mul(nlev, std.pt_to_dots(b, INDENT_PER)), color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   d_recent
//====================
function d_recent(b) {
k.k_enter(b);
k.div_begin(b, true, false, false, false);
  k.div_spa(b, 0, 1, std.al);
  var loop1404 = new std.a_loop({ limit:4 });
  while (loop1404.next()) {
    k.div_add(b, U, 0, 12, std.al, d_recent_cell_F, 0);
    k.div_spa(b, 0, 1, std.al);
  }
  var loop1405 = new std.a_loop({ limit:3 });
  while (loop1405.next()) {
  var cx = loop1405.count;
    if (std.gt2(cx, 1)) {
      k.div_spa(b, 1, 1, std.al);
    }
    k.div_add(b, U, 1, 12, std.al, d_recent_cell_F, 0);
  }
  k.div_end(b);
  k.draw_grid(b);
k.k_leave(b);
}


//====================
//   d_recent_cell
//====================
function d_recent_cell(b) {
  k.k_enter(b);
  std.draw_rect(b, addr(b.extra, std.F_box), { corner:std.pt_to_dots(b, 6), fill:std.DARK_SLATE_GRAY });
  if (std.eq2(getn(b.extra, std.F_cell_seq), 1)) {
    let r = new std.a_tree("builder","r"); std.merge_tree(_M, 1779, std.solve_rect({ basis:addr(b.extra, std.F_box), pin:5, inset:std.pt_to_dots(b, 10), aspect:1.7 }), addr(r)
    );
    std.draw_rect(b, addr(r), { corner:std.pt_to_dots(b, 12), fill:BUTT_LO_BACK, color:BUTT_LO_BORD, thick:std.pt_to_dots(b, 3) });
    std.draw_str(b, addr(r), "New\nProject", { size:std.pt_to_dots(b, 24), color:BUTT_LO_TEXT });
  } else {
  }
  k.k_leave(b);
}

//====================
//   track_d_recent
//====================
function track_d_recent(b, e) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    if (std.eq2(getn(b.extra, std.F_cell_seq), 1)) {
      std.path_setv(_M, 1788, addr(doc, F_is_doc_open), Y);
    } else {
    }
  return Y;
  }
  return N;
}

//====================
//   d_resetdot
//====================
function d_resetdot(b, ctl) {
k.k_enter(b);
  const diam = std.mul(b.bounds.height, 0.4);
  let r = new std.a_tree("builder","r"); std.merge_tree(_M, 3002, std.solve_rect({ basis:addr(b.extra, std.F_box), pin:5, width:diam, height:diam }), addr(r));
  std.draw_oval(b, addr(r), { fill:std.SIENNA });
k.k_leave(b);
}


//====================
//   track_d_resetdot
//====================
function track_d_resetdot(b, e, ctl) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    std.sound_play(CLICK, {});
    slider_reset(ctl);
  return Y;
  }
  return N;
}

//====================
//   d_sectdiv
//====================
function d_sectdiv(b, div) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  let w1 = std.round(std.mul(b.bounds.width, 0.6), {});
  let w2 = std.sub(b.bounds.width, w1);
  k.div_add(b, U, 0, w1, std.px, d_sectdivA_F, 0, [div]);
  k.div_add(b, U, 0, w2, std.px, d_sectdivB_F, 0, [div]);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_sectdivA
//====================
function d_sectdivA(b, div) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  let r1 = new std.a_tree("builder","r1"); std.merge_tree(_M, 2274, std.solve_rect({ basis:addr(b.extra, std.F_box), pin:7, height:std.mul(b.bounds.height, 0.85) }), addr(r1
  ));
  std.draw_rect(b, addr(r1), { fill:SECTD_BACK, corner_tl:std.pt_to_dots(b, 8), corner_tr:std.pt_to_dots(b, 8) });
  k.div_spa(b, 0, 6, std.pt);
  k.div_add(b, U, 0, 14, std.pt, d_dtriangle_F, 0, [getn(div, F_is_expanded), 0.1, 0.2]);
  k.div_spa(b, 0, 6, std.pt);
  k.div_add(b, U, 0, 120, std.al, d_sectprompt_F, 0, [gets(div, F_prompt)]);
k.div_end(b);
k.k_leave(b);
}


//====================
//   track_d_sectdivA
//====================
function track_d_sectdivA(b, e, div) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    std.toggle(_M, 2284, addr(div, F_is_expanded));
    std.log(std.cat("toggle expandf=", str.to_str(getn(div, F_is_expanded), {show_u:Y})));
  return Y;
  }
  return N;
}

//====================
//   d_sectdivB
//====================
function d_sectdivB(b, div) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  if (getn(div, F_is_expanded) === Y) {
    let r2 = new std.a_tree("builder","r2"); std.merge_tree(_M, 2292, std.solve_rect({ basis:addr(b.extra, std.F_box), pin:8, height:std.mul(b.bounds.height, 0.12) }), addr(r2
    ));
    std.draw_rect(b, addr(r2), { fill:SECTD_BACK });
  }
  k.div_spa(b, 0, 3, std.al);
  if ((std.eq2(getn(g, F_work_state), WORK_EDITING) && (std.eq2(getn(div, F_nk), getn(g, F_work_nk)) && getn(div, F_is_readonly) !== Y))) {
    k.div_add(b, U, 0, 24, std.al, d_div_del_F, 0, [div]);
  } else {
    k.div_spa(b, 0, 24, std.al);
  }
  k.div_spa(b, 0, 3, std.al);
  if ((getn(div, F_is_readonly) !== Y && (getn(div, F_is_expanded) === Y && std.eq2(getn(g, F_work_state), WORK_CLOSED)))) {
    k.div_add(b, U, 0, 24, std.al, d_div_add_F, 0, [div]);
  } else {
    k.div_spa(b, 0, 24, std.al);
  }
  k.div_spa(b, 0, 5, std.pt);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_sectprompt
//====================
function d_sectprompt(b, prompt) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), prompt, { size:0.6, just:std.LEFT, color:BUTT_LO_TEXT });
k.k_leave(b);
}


//====================
//   d_slice_stack
//====================
function d_slice_stack(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 15, std.al);
  k.div_add(b, U, 0, 40, std.al, draw_choice_grid_F, 0, [addr(g, F_block_slice_grid), 0.5]);
  k.div_spa(b, 0, 15, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_slider_assy
//====================
function d_slider_assy(b, ctl) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  let hint = slider_getss(ctl);
  k.div_add(b, U, 0, 50, std.al, draw_entry_F, 0, [{ hint:hint }]);
  k.div_spa(b, 0, 5, std.al);
  k.div_add(b, U, 0, 120, std.al, d_slider_rack_F, 0, [ctl]);
  k.div_spa(b, 0, 5, std.al);
  k.div_add(b, U, 0, 25, std.al, d_slider_minus_F, 0, [ctl]);
  k.div_spa(b, 0, 5, std.al);
  k.div_add(b, U, 0, 25, std.al, d_slider_plus_F, 0, [ctl]);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_slider_minus
//====================
function d_slider_minus(b, ctl) {
k.k_enter(b);
  let back = U;
  let bord = U;
  let text = U;
  const CORNER = std.pt_to_dots(b, SLIDER_CORNER);
  if (false) {
    back = BUTT_HI_BACK;
    bord = BUTT_HI_BORD;
    text = BUTT_HI_TEXT;
  } else {
    back = BUTT_LO_BACK;
    bord = BUTT_LO_BORD;
    text = BUTT_LO_TEXT;
  }
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:back, color:bord, thick:std.pt_to_dots(b, BUTT_THICK), corner_tl:CORNER, corner_bl:CORNER });
  std.draw_str(b, addr(b.extra, std.F_box), "", { color:text, size:0.5 });
k.k_leave(b);
}


//====================
//   track_d_slider_minus
//====================
function track_d_slider_minus(b, e, ctl) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    do_slider_minus(ctl, getn(e, std.F_is_shift));
  return Y;
  }
  return N;
}

//====================
//   d_slider_plus
//====================
function d_slider_plus(b, ctl) {
k.k_enter(b);
  let back = U;
  let bord = U;
  let text = U;
  const CORNER = std.pt_to_dots(b, SLIDER_CORNER);
  if (false) {
    back = BUTT_HI_BACK;
    bord = BUTT_HI_BORD;
    text = BUTT_HI_TEXT;
  } else {
    back = BUTT_LO_BACK;
    bord = BUTT_LO_BORD;
    text = BUTT_LO_TEXT;
  }
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:back, color:bord, thick:std.pt_to_dots(b, BUTT_THICK), corner_tr:CORNER, corner_br:CORNER });
  std.draw_str(b, addr(b.extra, std.F_box), "", { color:text, size:0.5 });
k.k_leave(b);
}


//====================
//   track_d_slider_plus
//====================
function track_d_slider_plus(b, e, ctl) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    do_slider_plus(ctl, getn(e, std.F_is_shift));
  return Y;
  }
  return N;
}

//====================
//   d_slider_rack
//====================
function d_slider_rack(b, ctl) {
k.k_enter(b);
  const RACKV = std.mul(b.bounds.height, 0.1);
  let rackr = new std.a_tree("builder","rackr"); std.merge_tree(_M, 3085, std.solve_rect({ basis:addr(b.extra, std.F_box), pin:5, height:RACKV }), addr(rackr));
  std.draw_rect(b, addr(rackr), { fill:BUTT_LO_BACK });
  const BALLD = std.mul(b.bounds.height, 0.5);
  std.path_setv(_M, 3092, addr(ctl, F_rack_h), b.bounds.width);
  std.path_setv(_M, 3093, addr(ctl, F_ball_d), BALLD);
  std.path_setv(_M, 3094, addr(ctl, F_ball_x), calc_ball_x(ctl));
  let ballr = new std.a_tree("builder","ballr"); std.merge_tree(_M, 3095, std.solve_rect({ basis:addr(b.extra, std.F_box), pin:4, inset_w:getn(ctl, F_ball_x), width:BALLD, height
  :BALLD }), addr(ballr));
  let ballc = getn(ctl, F_in_drag) === Y ? 0xF93175 : 0xC71350;
  std.draw_oval(b, addr(ballr), { fill:ballc });
k.k_leave(b);
}


//====================
//   track_d_slider_rack
//====================
function track_d_slider_rack(b, e, ctl) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    if (std.lt2(getn(e, std.F_x), getn(ctl, F_ball_x))) {
      do_slider_minus(ctl, getn(e, std.F_is_shift));
    } else if (std.gt2(getn(e, std.F_x), std.add(getn(ctl, F_ball_x), getn(ctl, F_ball_d)))) {
      do_slider_plus(ctl, getn(e, std.F_is_shift));
    }
  return Y;
  } else 
  //---------------
  //   on EV_DRAG_BEGIN
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_DRAG_BEGIN) {
    std.path_setv(_M, 3112, addr(ctl, F_in_drag), Y);
    std.path_setv(_M, 3113, addr(ctl, F_start_mouse_x), getn(e, std.F_global_x));
    std.path_setv(_M, 3114, addr(ctl, F_start_ball_x), getn(ctl, F_ball_x));
  return Y;
  } else 
  //---------------
  //   on EV_DRAG_END
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_DRAG_END) {
    std.path_setv(_M, 3118, addr(ctl, F_in_drag), N);
  return Y;
  } else 
  //---------------
  //   on EV_DRAG_MOVE
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_DRAG_MOVE) {
    std.path_setv(_M, 3122, addr(ctl, F_old_val), slider_getv(ctl));
    let dx = std.sub(getn(e, std.F_global_x), getn(ctl, F_start_mouse_x));
    let newval = std.interpolate(std.add(getn(ctl, F_start_ball_x), dx), 0, std.sub(getn(ctl, F_rack_h), getn(ctl, F_ball_d)), getn(ctl, F_minval), getn(ctl, F_maxval), { clamp
    :Y });
    slider_setv(ctl, newval);
    if (std.get_func(ctl, F_action) !== null) {
      std.get_func(ctl, F_action).code(ctl);
    }
  return Y;
  }
  return N;
}

//====================
//   d_stop_icon
//====================
function d_stop_icon(b, bar, bot, bandx, countx, hilite) {
k.k_enter(b);
  const ICON_V = std.round(std.mul(getn(bot, std.F_height), 0.3), {});
  const ICON_H = std.mul(getn(bot, std.F_height), 0.35);
  const ICON_HALF = std.div(ICON_H, 2);
  const DY = std.round_down(std.div(std.sub(getn(bot, std.F_height), ICON_V), 3), {});
  let pos = getn(g, F_work_grad, std.F_grad_stops, bandx, std.F_stop_pos);
  let chip = getn(g, F_work_grad, std.F_grad_stops, bandx, std.F_stop_color);
  let center = std.interpolate(pos, 0, 100, getn(bot, std.F_left), std.add(getn(bot, std.F_left), getn(bot, std.F_width)), { round:Y });
  let ndy = 0;
  if (std.le2(std.abs(std.sub(center, getn(g_stop_centerx, std.sub(countx, 1)))), ICON_H)) {
    var case1406 = getn(g_stop_ndy, std.sub(countx, 1));
    if (case1406 === 0) {
      ndy = 1;
    } else if (case1406 === 1) {
      ndy = 2;
    } else if (case1406 === 2) {
      ndy = 3;
    } else if (case1406 === 3) {
      ndy = -2;
    } else if (case1406 === -2) {
      ndy = -1;
    } else if (case1406 === -1) {
      ndy = 0;
    }
  }
  let frame = hilite === Y ? std.ORANGE : std.GRAY5;
  let topy = std.add(getn(bot, std.F_top), std.mul(std.abs(ndy), DY));
  let triangle = new std.a_tree("builder","triangle"); std.merge_lit(_M, 2532, triangle, 1, std.F_x, VAL, center, std.F_y, VAL, topy, POP, 2, std.F_x, VAL, std.add(center, ICON_HALF
    ), std.F_y, VAL, std.add(topy, ICON_V), POP, 3, std.F_x, VAL, std.sub(center, ICON_HALF), std.F_y, VAL, std.add(topy, ICON_V), POP);
  std.draw_polygon(b, addr(triangle), { fill:chip, thick:2, color:frame });
  if (hilite === Y) {
    let wire = new std.a_tree("builder","wire"); std.merge_tree(_M, 2539, std.solve_rect({ top:getn(bar, std.F_top), left:std.sub(center, 1), bottom:topy, width:3 }), addr(wire
    ));
    std.draw_rect(b, addr(wire), { fill:frame });
  }
  std.path_setv(_M, 2543, addr(g_stop_ndy, countx), ndy);
  std.path_setv(_M, 2544, addr(g_stop_centerx, countx), center);
  std.path_setv(_M, 2545, addr(g_stop_centery, countx), std.add(topy, std.mul(ICON_V, 0.6)));
k.k_leave(b);
}


//====================
//   d_timer_interval
//====================
function d_timer_interval(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, 12, std.al, d_timer_interval_2433_F, 0);
  k.div_add(b, U, 0, 10, std.al, draw_entry_F, 0, [{ hint:"" }]);
  k.div_spa(b, 0, 1, std.al);
  k.div_add(b, U, 0, 30, std.al, draw_choice_grid_F, 0, [addr(g, F_timer_time_grid), 0.5]);
  k.div_spa(b, 0, TOOL_RINDENT, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_timer_rep
//====================
function d_timer_rep(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, TOOL_LINDENT, std.al);
  k.div_add(b, U, 0, TOOL_LABEL, std.al, d_timer_rep_2418_F, 0);
  k.div_add(b, U, 0, 140, std.al, draw_choice_grid_F, 0, [addr(g, F_timer_nreps_grid), 0.5]);
  k.div_spa(b, 0, 2, std.pt);
  k.div_add(b, U, 0, 100, std.al, d_timer_rep_2422_F, 0);
  k.div_spa(b, 0, TOOL_RINDENT, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_var_summary
//====================
function d_var_summary(b, sym) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  let ss = std.get_generic(sym, F_var_spec, F_initval) !== null ? std.cat(" = ", val_summary(addr(sym, F_var_spec))) : "";
  std.draw_str(b, addr(b.extra, std.F_box), std.cat("", gets(sym, F_name), " : ", dtype_ss(addr(sym, F_var_spec, F_dtype)), "", ss), { size:0.78, just:std.LEFT, indent:std.pt_to_dots(
  b, 10), shrink:N, color:C_TOOL_LABEL });
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_work_dtype
//====================
function d_work_dtype(b, spec) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  let name = null;
  var loop1407 = new std.a_loop({ across:addr(spec, F_dtype) });
  while (loop1407.next()) {
  var slotx = loop1407.count;
  var type_chunk = loop1407.val;
    if (std.gt2(slotx, 1)) {
      k.div_spa(b, 0, 4, std.pt);
    }
    if (std.eq2(type_chunk, std.TYPE_RECORD)) {
      name = gets(spec, F_subrec, std.FOL, F_name);
    } else {
      name = gets(TYPE_TO_STR, type_chunk);
    }
    k.div_add(b, U, 0, 10, std.al, d_pulldown_F, 0, [slotx, name]);
  }
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_work_var
//====================
function d_work_var(b, spec) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 8, std.pt);
  k.div_add(b, U, 0, 60, std.al, d_work_var_1210_F, 0, [spec]);
  k.div_add(b, U, 0, 10, std.pt, d_work_var_1212_F, 0, [spec]);
  let w = std.mul(std.max(1, std.tree_count(addr(spec, F_dtype))), 35);
  w = 70;
  k.div_add(b, U, 0, w, std.al, d_work_var_1216_F, 0, [spec]);
  k.div_add(b, U, 0, 15, std.pt, d_work_var_1218_F, 0, [spec]);
  k.div_add(b, U, 0, 70, std.al, d_work_var_1220_F, 0, [spec]);
  k.div_spa(b, 0, 6, std.pt);
k.div_end(b);
k.k_leave(b);
}


//====================
//   d_work_var_hdr
//====================
function d_work_var_hdr(b, spec) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 8, std.pt);
  k.div_add(b, U, 0, 60, std.al, d_work_var_hdr_1193_F, 0, [spec]);
  k.div_spa(b, 0, 10, std.pt);
  let w = std.mul(std.max(1, std.tree_count(addr(spec, F_dtype))), 35);
  w = 70;
  k.div_add(b, U, 0, w, std.al, d_work_var_hdr_1199_F, 0, [spec]);
  k.div_spa(b, 0, 15, std.pt);
  k.div_add(b, U, 0, 70, std.al, d_work_var_hdr_1202_F, 0, [spec]);
  k.div_spa(b, 0, 6, std.pt);
k.div_end(b);
k.k_leave(b);
}


//====================
//   draw_1_toggle
//====================
function draw_1_toggle(b, label, result_ptr) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 10, std.al);
  k.div_add(b, U, 0, 120, std.pt, draw_toggle_F, 0, [label, result_ptr]);
  k.div_spa(b, 0, 10, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   draw_choice_grid
//====================
function draw_choice_grid(b, o, textsize) {
k.k_enter(b);
k.div_begin(b, true, false, false, false);
  GRID_NPARTS = std.tree_count(addr(o, F_label_list));
  GRID_NROWS = getn(o, F_nrows) !== U ? getn(o, F_nrows) : 1;
  GRID_NCOLS = std.div(GRID_NPARTS, GRID_NROWS);
  var loop1408 = new std.a_loop({ limit:GRID_NCOLS });
  while (loop1408.next()) {
    k.div_add(b, U, 0, 12, std.al, draw_choice_grid_cell_F, 0);
  }
  var loop1409 = new std.a_loop({ limit:GRID_NROWS });
  while (loop1409.next()) {
    k.div_add(b, U, 1, 12, std.al, draw_choice_grid_cell_F, 0);
  }
  k.div_end(b);
  k.draw_grid(b, o, textsize);
k.k_leave(b);
}


//====================
//   draw_choice_grid_cell
//====================
function draw_choice_grid_cell(b, o, textsize) {
  k.k_enter(b);
  let opacity = getn(o, F_enabled) === N ? DIMMED : 1;
  let back = U;
  let bord = U;
  let text = U;
  let tl = 0;
  let tr = 0;
  let bl = 0;
  let br = 0;
  if (std.eq2(getn(b.extra, std.F_cell_seq), choice_get_selx(o))) {
    back = BUTT_HI_BACK;
    bord = BUTT_HI_BORD;
    text = BUTT_HI_TEXT;
  } else {
    back = BUTT_LO_BACK;
    bord = BUTT_LO_BORD;
    text = BUTT_LO_TEXT;
  }
  if (std.eq2(getn(b.extra, std.F_cell, std.F_x), 1)) {
    if (std.eq2(getn(b.extra, std.F_cell, std.F_y), 1)) {
      tl = std.pt_to_dots(b, CHOICE_CORNER);
    }
    if (std.eq2(getn(b.extra, std.F_cell, std.F_y), GRID_NROWS)) {
      bl = std.pt_to_dots(b, CHOICE_CORNER);
    }
  }
  if (std.eq2(getn(b.extra, std.F_cell, std.F_x), GRID_NCOLS)) {
    if (std.eq2(getn(b.extra, std.F_cell, std.F_y), 1)) {
      tr = std.pt_to_dots(b, CHOICE_CORNER);
    }
    if (std.eq2(getn(b.extra, std.F_cell, std.F_y), GRID_NROWS)) {
      br = std.pt_to_dots(b, CHOICE_CORNER);
    }
  }
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:back, color:bord, thick:std.pt_to_dots(b, BUTT_THICK), pos:0, corner_tl:tl, corner_tr:tr, corner_bl:bl, corner_br:br, opacity
  :opacity });
  let f = std.get_func(o, F_label_func, getn(b.extra, std.F_cell_seq));
  if (f !== null) {
    f.code(b, addr(b.extra, std.F_box));
  } else {
    std.draw_str(b, addr(b.extra, std.F_box), gets(o, F_label_list, getn(b.extra, std.F_cell_seq)), { color:text, indent:std.pt_to_dots(b, 1.5), size:textsize, opacity:opacity
     });
  }
  k.k_leave(b);
}

//====================
//   track_draw_choice_grid
//====================
function track_draw_choice_grid(b, e, o, textsize) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    choice_set_selx(o, getn(b.extra, std.F_cell_seq));
    if (std.get_func(o, F_choice_func) !== null) {
      std.get_func(o, F_choice_func).code();
    }
  return Y;
  }
  return N;
}

//====================
//   draw_color_entry
//====================
function draw_color_entry(b, ctl) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_add(b, U, 0, 30, std.al, draw_entry_F, 0, [{ hint:gets(ctl, F_color_ss) }]);
  k.div_spa(b, 0, 1, std.al);
  k.div_add(b, U, 0, 10, std.al, draw_color_sample_F, 0, [ctl]);
k.div_end(b);
k.k_leave(b);
}


//====================
//   draw_color_sample
//====================
function draw_color_sample(b, ctl) {
k.k_enter(b);
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:color_ctl_getv(ctl) });
  if (std.eq2(std.get_ptr(g, F_palette_targ_ptr), ctl)) {
    std.draw_rect(b, addr(b.extra, std.F_box), { color:BUTT_HI_BACK, thick:std.pt_to_dots(b, 3.5) });
  }
  std.draw_rect(b, addr(b.extra, std.F_box), { color:ENTRY_LO_BORD, thick:std.pt_to_dots(b, BUTT_THICK) });
k.k_leave(b);
}


//====================
//   track_draw_color_sample
//====================
function track_draw_color_sample(b, e, ctl) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    std.path_setv(_M, 3790, addr(g, F_bar_tabx), PICKER_COLOR_TABS);
    sync_palette(ctl);
  return Y;
  }
  return N;
}

//====================
//   draw_dropdown
//====================
function draw_dropdown(b, c) {
k.k_enter(b);
  let r_arrow = new std.a_tree("builder","r_arrow");
  let r_label = new std.a_tree("builder","r_label");
  let arrow_h = std.pt_to_dots(b, 20);
  if (getn(c, F_is_open) === Y) {
    std.draw_rect(b, addr(b.extra, std.F_box), { fill:std.PINK });
  } else {
    std.draw_rect(b, addr(b.extra, std.F_box), { fill:BUTT_LO_BACK, corner:std.pt_to_dots(b, CHOICE_CORNER) });
    std.copy_tree(_M, 3911, std.solve_rect({ basis:addr(b.extra, std.F_box), pin:6, width:arrow_h }), addr(r_arrow));
    std.draw_rect(b, addr(r_arrow), { fill:DROPDOWN_ARROW_BACK, corner_tr:std.pt_to_dots(b, CHOICE_CORNER), corner_br:std.pt_to_dots(b, CHOICE_CORNER) });
    std.draw_str(b, addr(r_arrow), "", { color:DROPDOWN_ARROW_TEXT, size:0.6 });
    std.draw_rect(b, addr(b.extra, std.F_box), { color:BUTT_LO_BORD, thick:std.pt_to_dots(b, BUTT_THICK), corner:std.pt_to_dots(b, CHOICE_CORNER) });
    std.copy_tree(_M, 3918, std.solve_rect({ basis:addr(b.extra, std.F_box), pin:4, width:std.sub(b.bounds.width, arrow_h) }), addr(r_label));
    let selx = choice_get_selx(c);
    std.draw_str(b, addr(r_label), gets(c, F_label_list, selx), { size:0.6, color:BUTT_LO_TEXT });
  }
k.k_leave(b);
}


//====================
//   draw_entry
//====================
function draw_entry(b, _o=null) {
var hint = "..."; if ((_o != null) && _o.hasOwnProperty("hint")) hint = _o.hint;
k.k_enter(b);
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:ENTRY_LO_BACK, color:ENTRY_LO_BORD, thick:std.pt_to_dots(b, BUTT_THICK) });
  std.draw_str(b, addr(b.extra, std.F_box), hint, { color:ENTRY_LO_TEXT, size:0.55, just:std.LEFT, indent:std.pt_to_dots(b, 4) });
k.k_leave(b);
}


//====================
//   draw_font_entry
//====================
function draw_font_entry(b, data) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_add(b, U, 0, 30, std.al, draw_entry_F, 0, [{ hint:gets(data, F_font_exp) }]);
  k.div_spa(b, 0, 1, std.al);
  k.div_add(b, U, 0, 10, std.al, draw_font_sample_F, 0, [data]);
k.div_end(b);
k.k_leave(b);
}


//====================
//   draw_font_picker
//====================
function draw_font_picker(b) {
k.k_enter(b);
k.div_begin(b, true, true, false, false);
  const NCOLS = 3;
  const NROWS = std.round_up(std.div(NFONTS, NCOLS), {});
  const FONTV = 24;
  const GAP = 2;
  var loop1410 = new std.a_loop({ limit:NCOLS });
  while (loop1410.next()) {
    k.div_spa(b, 0, 8, std.pt);
    k.div_add(b, U, 0, 10, std.al, draw_font_picker_cell_F, 0);
  }
  k.div_spa(b, 0, 8, std.pt);
  var loop1411 = new std.a_loop({ limit:NROWS });
  while (loop1411.next()) {
    k.div_spa(b, 1, 4, std.pt);
    k.div_add(b, U, 1, 10, std.al, draw_font_picker_cell_F, 0);
  }
  k.div_spa(b, 1, 4, std.pt);
  k.div_end(b);
  k.draw_grid(b);
k.k_leave(b);
}


//====================
//   draw_font_picker_cell
//====================
function draw_font_picker_cell(b) {
  k.k_enter(b);
  if (std.le2(getn(b.extra, std.F_cell_seq), NFONTS)) {
    d_font_example(b, std.get_generic(FONTLIST, getn(b.extra, std.F_cell_seq)));
  }
  k.k_leave(b);
}

//====================
//   track_draw_font_picker
//====================
function track_draw_font_picker(b, e) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    if ((getn(b.extra, std.F_cell_seq) === U || std.gt2(getn(b.extra, std.F_cell_seq), NFONTS))) {
      std.sound_play(BEEP, {});
    } else {
      std.sound_play(CLICK, {});
      let ix = getn(b.extra, std.F_cell_seq);
      std.log(std.cat("selected font ", str.to_str(ix, {show_u:Y})));
      std.path_setv(_M, 4210, addr(g, F_fontpicker_targ_ptr, std.FOL, F_font_exp), std.get_generic(FONTLIST, ix));
      std.path_setv(_M, 4211, addr(g, F_fontpicker_targ_ptr, std.FOL, F_font_net), std.get_generic(FONTLIST, ix));
    }
  return Y;
  } else 
  //---------------
  //   on EV_HOVER
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_HOVER) {
    if (std.le2(getn(b.extra, std.F_cell_seq), NFONTS)) {
      std.cursor_set(std.CURS_FINGER);
    } else {
      std.cursor_set(std.CURS_ARROW);
    }
  return Y;
  }
  return N;
}

//====================
//   draw_font_sample
//====================
function draw_font_sample(b, p) {
k.k_enter(b);
  if (gets(p, F_font_net) !== null) {
    std.draw_str(b, addr(b.extra, std.F_box), "abcEFG", { size:0.5, font:gets(p, F_font_net), color:ENTRY_LO_TEXT });
  }
  if (std.eq2(std.get_ptr(g, F_fontpicker_targ_ptr), p)) {
    std.draw_rect(b, addr(b.extra, std.F_box), { color:BUTT_HI_BACK, thick:std.pt_to_dots(b, 3.5) });
  }
  std.draw_rect(b, addr(b.extra, std.F_box), { color:ENTRY_LO_BORD, thick:std.pt_to_dots(b, BUTT_THICK) });
k.k_leave(b);
}


//====================
//   track_draw_font_sample
//====================
function track_draw_font_sample(b, e, p) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    std.path_setv(_M, 3810, addr(g, F_bar_tabx), PICKER_FONT_TABS);
  return Y;
  }
  return N;
}

//====================
//   draw_oneshot
//====================
function draw_oneshot(b, label, action, _o=null) {
var enterkey = N; if ((_o != null) && _o.hasOwnProperty("enterkey")) enterkey = _o.enterkey;
k.k_enter(b);
  let back = U;
  let bord = U;
  let text = U;
  if (false) {
    back = BUTT_HI_BACK;
    bord = BUTT_HI_BORD;
    text = BUTT_HI_TEXT;
  } else {
    back = BUTT_LO_BACK;
    bord = BUTT_LO_BORD;
    text = BUTT_LO_TEXT;
  }
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:back, color:bord, thick:std.pt_to_dots(b, BUTT_THICK), corner:std.pt_to_dots(b, ONESHOT_CORNER) });
  std.draw_str(b, addr(b.extra, std.F_box), label, { color:text, size:0.6, indent:std.pt_to_dots(b, 4) });
k.k_leave(b);
}


//====================
//   track_draw_oneshot
//====================
function track_draw_oneshot(b, e, label, action, _o=null) {
var enterkey = N; if ((_o != null) && _o.hasOwnProperty("enterkey")) enterkey = _o.enterkey;
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    exec_action(label, action);
  return Y;
  } else 
  //---------------
  //   on EV_KEYBOARD
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_KEYBOARD) {
    if ((enterkey === Y && std.eq2(getn(e, std.F_keycode), std.KEYCODE_ENTER))) {
      exec_action(label, action);
      return Y;
    } else {
      return N;
    }
  return Y;
  }
  return N;
}

//====================
//   draw_tabs
//====================
function draw_tabs(b, tabs, deadspace) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  const tabw = std.div(std.sub(100, deadspace), std.tree_count(tabs));
  const skip_per_side = std.div(deadspace, 2);
  k.div_spa(b, 0, skip_per_side, std.al);
  var loop1412 = new std.a_loop({ across:addr(tabs, F_label_list) });
  while (loop1412.next()) {
  var ix = loop1412.index;
    k.div_add(b, U, 0, tabw, std.al, draw_tabs2_F, 0, [tabs, ix]);
  }
  k.div_spa(b, 0, skip_per_side, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   draw_tabs2
//====================
function draw_tabs2(b, tabs, ix) {
k.k_enter(b);
  let back = U;
  let text = U;
  let bord = U;
  if (std.eq2(getn(tabs, F_selx), ix)) {
    back = TAB_HI_BACK;
    bord = TAB_HI_BORD;
    text = TAB_HI_TEXT;
  } else {
    back = TAB_LO_BACK;
    bord = TAB_LO_BORD;
    text = TAB_LO_TEXT;
  }
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:back, color:bord, thick:std.pt_to_dots(b, TAB_BORD), corner_tl:std.pt_to_dots(b, TAB_CORNER), corner_tr:std.pt_to_dots(b, 
  TAB_CORNER) });
  std.draw_str(b, addr(b.extra, std.F_box), gets(tabs, F_label_list, ix), { indent:std.pt_to_dots(b, 1.5), size:0.6, color:text });
k.k_leave(b);
}


//====================
//   track_draw_tabs2
//====================
function track_draw_tabs2(b, e, tabs, ix) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    if (std.ne2(ix, getn(tabs, F_selx))) {
      std.path_setv(_M, 4002, addr(tabs, F_selx), ix);
      if (std.get_func(tabs, F_action) !== null) {
        std.get_func(tabs, F_action).code();
      }
    }
  return Y;
  }
  return N;
}

//====================
//   draw_toggle
//====================
function draw_toggle(b, label, val) {
k.k_enter(b);
  let c_back = U;
  let c_bord = U;
  let c_text = U;
  let prefix = null;
  if (getn(val) === Y) {
    c_back = BUTT_HI_BACK;
    c_bord = BUTT_HI_BORD;
    c_text = BUTT_HI_TEXT;
    prefix = "";
  } else {
    c_back = BUTT_LO_BACK;
    c_bord = BUTT_LO_BORD;
    c_text = BUTT_LO_TEXT;
    prefix = "";
  }
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:c_back, color:c_bord, thick:std.pt_to_dots(b, BUTT_THICK), corner:std.pt_to_dots(b, TOGGLE_CORNER) });
  std.draw_str(b, addr(b.extra, std.F_box), prefix, { color:c_text, size:0.75, indent:std.pt_to_dots(b, 5), just:std.LEFT, shrink:N });
  std.draw_str(b, addr(b.extra, std.F_box), label, { color:c_text, size:0.45, indent:std.pt_to_dots(b, 22), just:std.LEFT });
k.k_leave(b);
}


//====================
//   track_draw_toggle
//====================
function track_draw_toggle(b, e, label, val) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    std.toggle(_M, 3870, val);
  return Y;
  }
  return N;
}

//====================
//   ferr_first_ramp
//====================
function ferr_first_ramp(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_add(b, U, 0, 10, std.al, ferr_first_ramp_4574_F, 0);
  k.div_add(b, U, 0, 10, std.al, ferr_first_ramp_4576_F, 0);
k.div_end(b);
k.k_leave(b);
}


//====================
//   ferr_hilite_chip
//====================
function ferr_hilite_chip(b, box) {
k.k_enter(b);
  std.draw_rect(b, addr(b.extra, std.F_box), { thick:4, pos:0, color:std.BLACK });
  std.draw_rect(b, addr(b.extra, std.F_box), { thick:2, pos:0, color:std.RED });
k.k_leave(b);
}


//====================
//   ferr_ramp
//====================
function ferr_ramp(b, rampx) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  var loop1413 = new std.a_loop({ limit:CHIPS_PER_RAMP });
  while (loop1413.next()) {
  var chipx = loop1413.count;
    let colorx = std.add(std.add(2, std.mul(std.sub(rampx, 2), CHIPS_PER_RAMP)), chipx);
    k.div_add(b, U, 0, 10, std.al, ferr_ramp_chip_F, 0, [colorx]);
  }
k.div_end(b);
k.k_leave(b);
}


//====================
//   ferr_ramp_chip
//====================
function ferr_ramp_chip(b, colorx) {
k.k_enter(b);
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:getn(FERRARI, colorx) });
  if (std.eq2(getn(g, F_palette_ferrari_selx), colorx)) {
    ferr_hilite_chip(b, addr(b.extra, std.F_box));
  }
k.k_leave(b);
}


//====================
//   track_ferr_ramp_chip
//====================
function track_ferr_ramp_chip(b, e, colorx) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    std.path_setv(_M, 4596, addr(g, F_palette_ferrari_selx), colorx);
    color_ctl_setv(addr(g, F_palette_targ_ptr, std.FOL), getn(FERRARI, colorx));
  return Y;
  }
  return N;
}

//====================
//   ferrari_palette_draw
//====================
function ferrari_palette_draw(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  chip_h = std.round_down(std.div(b.bounds.width, CHIPS_PER_ROW), {});
  let used = std.mul(chip_h, CHIPS_PER_ROW);
  k.div_add(b, U, 0, used, std.px, d_ferrari_grid_F, 0);
  k.div_spa(b, 0, 10, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   graphics_add_buts
//====================
function graphics_add_buts(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 8, std.al);
  k.div_add(b, U, 0, 40, std.al, draw_oneshot_F, 0, ["Add", do_block_add_F, {}]);
  k.div_spa(b, 0, 8, std.al);
  k.div_add(b, U, 0, 40, std.al, draw_oneshot_F, 0, ["Dup", do_block_add_F, {}]);
  k.div_spa(b, 0, 8, std.al);
  k.div_add(b, U, 0, 40, std.al, draw_oneshot_F, 0, ["Del", do_block_add_F, {}]);
  k.div_spa(b, 0, 8, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   html_color_chip
//====================
function html_color_chip(b, myslot) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  hilite = std.and4(std.ne4(std.get_ptr(g, F_palette_targ_ptr), U), std.eq4(gets(myslot, F_name), gets(g, F_palette_targ_ptr, std.FOL, F_color_ss)));
  k.div_add(b, U, 0, 50, std.al, html_color_chip_4796_F, 0, [myslot]);
  if (std.eq2(getn(gsc, F_sizing), FULL_SIZE)) {
    k.div_add(b, U, 0, 140, std.al, html_color_chip_4806_F, 0, [myslot]);
  }
k.div_end(b);
k.k_leave(b);
}


//====================
//   html_palette_draw
//====================
function html_palette_draw(b) {
k.k_enter(b);
k.div_begin(b, true, true, false, false);
  k.div_spa(b, 0, 10, std.al);
  var loop1414 = new std.a_loop({ limit:NCOLS });
  while (loop1414.next()) {
  var col = loop1414.count;
    if ((std.gt2(col, 1) && std.eq2(getn(gsc, F_sizing), FULL_SIZE))) {
      k.div_spa(b, 0, 10, std.al);
    }
    k.div_add(b, U, 0, 250, std.al, html_palette_draw_cell_F, 0);
  }
  k.div_spa(b, 0, 10, std.al);
  k.div_spa(b, 1, 3, std.pt);
  var loop1415 = new std.a_loop({ limit:NROWS });
  while (loop1415.next()) {
  var row = loop1415.count;
    if ((std.gt2(row, 1) && std.eq2(getn(gsc, F_sizing), FULL_SIZE))) {
      k.div_spa(b, 1, 5, std.al);
    }
    k.div_add(b, U, 1, 80, std.al, html_palette_draw_cell_F, 0);
  }
  k.div_spa(b, 1, 3, std.pt);
  k.div_end(b);
  k.draw_grid(b);
k.k_leave(b);
}


//====================
//   html_palette_draw_cell
//====================
function html_palette_draw_cell(b) {
  k.k_enter(b);
  if (std.le2(getn(b.extra, std.F_cell_seq), NCELLS)) {
    let slotx = getn(b.extra, std.F_cell_seq);
    html_color_chip(b, addr(slotlist, slotx, std.FOL));
  }
  k.k_leave(b);
}

//====================
//   track_html_palette_draw
//====================
function track_html_palette_draw(b, e) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    if ((getn(b.extra, std.F_cell_seq) === U || std.gt2(getn(b.extra, std.F_cell_seq), NCELLS))) {
      std.sound_play(BEEP, {});
    } else {
      std.sound_play(CLICK, {});
      let ix = getn(b.extra, std.F_cell_seq);
      std.log(std.cat("selected ", str.to_str(ix, {show_u:Y}), ", name=", gets(slotlist, ix, std.FOL, F_name), ", color=", str.color_to_hex(getn(slotlist, ix, std.FOL, F_color))
      ));
      color_ctl_setss(addr(g, F_palette_targ_ptr, std.FOL), gets(slotlist, ix, std.FOL, F_name), getn(slotlist, ix, std.FOL, F_color));
    }
  return Y;
  } else 
  //---------------
  //   on EV_HOVER
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_HOVER) {
    if (std.le2(getn(b.extra, std.F_cell_seq), NCELLS)) {
      std.cursor_set(std.CURS_FINGER);
    } else {
      std.cursor_set(std.CURS_ARROW);
    }
  return Y;
  }
  return N;
}

//====================
//   html_palette_resize
//====================
function html_palette_resize(b) {
  BARV = 0;
  let h_pts = std.dots_to_pt(b, b.bounds.width);
  let v_pts = std.dots_to_pt(b, std.sub(b.bounds.height, BARV));
  let area = std.mul(h_pts, v_pts);
  if (std.ge2(area, AREA_THRESHOLD)) {
    std.path_setv(_M, 4706, addr(gsc, F_sizing), FULL_SIZE);
    NCOLS = std.round_down(std.div(h_pts, TARG_WIDTH), {});
  } else {
    std.path_setv(_M, 4710, addr(gsc, F_sizing), COMPACT_SIZE);
    let cell_area = std.round_down(std.div(area, NCELLS), {});
    let cell_height = std.sqrt(std.div(cell_area, 3));
    let cell_width = std.div(cell_area, cell_height);
    NCOLS = std.round(std.div(h_pts, cell_width), {});
  }
  NROWS = std.round_up(std.div(NCELLS, NCOLS), {});
}


//====================
//   icon_image
//====================
function icon_image(b, cell) {
k.k_enter(b);
  const r = new std.a_tree("builder","r"); std.merge_tree(_M, 1739, std.solve_rect({ basis:cell, pin:5, width:std.mul(getn(cell, std.F_width), 0.7), height:std.mul(getn(cell
  , std.F_height), 0.7) }), addr(r));
  const color = std.eq2(getn(g, F_draw_tools, F_selx), DRAWT_IMAGE) ? BUTT_HI_TEXT : BUTT_LO_TEXT;
  std.draw_image(b, addr(r), ICON_IMAGE, {});
k.k_leave(b);
}


//====================
//   icon_line
//====================
function icon_line(b, cell) {
k.k_enter(b);
  const r = new std.a_tree("builder","r"); std.merge_tree(_M, 1731, std.solve_rect({ basis:cell, pin:5, width:std.mul(getn(cell, std.F_width), 0.4), height:std.mul(getn(cell
  , std.F_height), 0.5) }), addr(r));
  const color = std.eq2(getn(g, F_draw_tools, F_selx), DRAWT_LINE) ? BUTT_HI_TEXT : BUTT_LO_TEXT;
  std.draw_line(b, { x1:getn(r, std.F_left), y1:std.add(getn(r, std.F_top), getn(r, std.F_height)), x2:std.add(getn(r, std.F_left), getn(r, std.F_width)), y2:getn(r, std.F_top
  ), color:color, thick:std.pt_to_dots(b, 3) });
k.k_leave(b);
}


//====================
//   icon_oval
//====================
function icon_oval(b, cell) {
k.k_enter(b);
  const r = new std.a_tree("builder","r"); std.merge_tree(_M, 1712, std.solve_rect({ basis:cell, pin:5, width:std.mul(getn(cell, std.F_width), 0.5), height:std.mul(getn(cell
  , std.F_height), 0.6) }), addr(r));
  const fill = std.eq2(getn(g, F_draw_tools, F_selx), DRAWT_OVAL) ? BUTT_HI_FILL : BUTT_LO_TEXT;
  std.draw_oval(b, addr(r), { fill:fill, thick:2, color:std.BLACK });
k.k_leave(b);
}


//====================
//   icon_poly
//====================
function icon_poly(b, cell) {
k.k_enter(b);
  const r = new std.a_tree("builder","r"); std.merge_tree(_M, 1720, std.solve_rect({ basis:cell, pin:5, width:std.mul(getn(cell, std.F_width), 0.5), height:std.mul(getn(cell
  , std.F_height), 0.6) }), addr(r));
  const fill = std.eq2(getn(g, F_draw_tools, F_selx), DRAWT_POLY) ? BUTT_HI_FILL : BUTT_LO_TEXT;
  const points = new std.a_tree("builder","points"); std.merge_lit(_M, 1722, points, 1, std.F_x, VAL, getn(r, std.F_left), std.F_y, VAL, std.add(getn(r, std.F_top), getn(r, 
    std.F_height)), POP, 2, std.F_x, VAL, std.add(getn(r, std.F_left), std.div(getn(r, std.F_width), 2)), std.F_y, VAL, getn(r, std.F_top), POP, 3, std.F_x, VAL, std.add(getn(
    r, std.F_left), getn(r, std.F_width)), std.F_y, VAL, std.add(getn(r, std.F_top), getn(r, std.F_height)), POP);
  std.draw_polygon(b, addr(points), { fill:fill, thick:2, color:std.BLACK });
k.k_leave(b);
}


//====================
//   icon_rect
//====================
function icon_rect(b, cell) {
k.k_enter(b);
  const r = new std.a_tree("builder","r"); std.merge_tree(_M, 1704, std.solve_rect({ basis:cell, pin:5, width:std.mul(getn(cell, std.F_width), 0.5), height:std.mul(getn(cell
  , std.F_height), 0.6) }), addr(r));
  const fill = std.eq2(getn(g, F_draw_tools, F_selx), DRAWT_RECT) ? BUTT_HI_FILL : BUTT_LO_TEXT;
  std.draw_rect(b, addr(r), { fill:fill, thick:2, color:std.BLACK });
k.k_leave(b);
}


//====================
//   icon_text
//====================
function icon_text(b, cell) {
k.k_enter(b);
  const color = std.eq2(getn(g, F_draw_tools, F_selx), DRAWT_TEXT) ? BUTT_HI_TEXT : BUTT_LO_TEXT;
  std.draw_str(b, cell, "Text", { size:0.6, color:color, font:"_serif" });
k.k_leave(b);
}


//====================
//   main_draw
//====================
export function main_draw(b) {
k.k_root2(b);
k.k_enter(b);
  let TOTH = std.dots_to_pt(b, b.bounds.width);
  let TOTV = std.dots_to_pt(b, b.bounds.height);
  TOOLBARH = std.interpolate(TOTH, 900, 1100, 200, 260, { round:Y, clamp:Y });
  std.log(std.cat("-- main_draw, screen ", str.to_str(b.bounds.width, {show_u:Y}), " x ", str.to_str(b.bounds.height, {show_u:Y}), " px, ", str.to_str(TOTH, {show_u:Y}), " x "
  , str.to_str(TOTV, {show_u:Y}), " pt, TOOL=", str.to_str(TOOLBARH, {show_u:Y})));
  main_draw_layer(b);
  if (getn(g, F_is_modal_dtype) === Y) {
    var b34=k.k_layer(b, d_modal_dtype_picker_F, { area:addr(b.extra, std.F_box) });
    d_modal_dtype_picker(b34);
  }
k.k_leave(b);
}


//====================
//   main_draw2
//====================
export function main_draw2(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_add(b, U, 1, 100, std.al, main_draw3_F, 0);
  if (getn(g, F_is_bar_visible) === Y) {
    const BARV = std.min(std.mul(b.bounds.height, 0.3), std.pt_to_dots(b, 120));
    k.div_add(b, U, 1, BARV, std.px, d_botbar_F, 0);
  }
k.div_end(b);
k.k_leave(b);
}


//====================
//   main_draw3
//====================
export function main_draw3(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 2, std.pt);
  k.div_add(b, U, 0, TOOLBARH, std.pt, section2_F, 0);
  k.div_spa(b, 0, 2, std.pt);
  k.div_add(b, U, 0, GUTTER, std.pt, d_gutter_F, 0);
  k.div_add(b, U, 0, 10, std.al, section3_F, 0);
  k.div_add(b, U, 0, GUTTER, std.pt, d_gutter_F, 0);
k.div_end(b);
k.k_leave(b);
}


//====================
//   main_draw_layer
//====================
export function main_draw_layer(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:DEAD_COLOR });
  if (getn(doc, F_is_doc_open) === Y) {
    var case1416 = getn(g, F_mode_tabs, F_selx);
    if (case1416 === MODE_PROJECT || case1416 === MODE_CODE || case1416 === MODE_BUILD) {
      k.div_spa(b, 0, 2, std.pt);
      k.div_add(b, U, 0, TOOLBARH, std.pt, toolbar_F, 0);
      k.div_spa(b, 0, 2, std.pt);
      k.div_add(b, U, 0, GUTTER, std.pt, d_gutter_F, 0);
      k.div_add(b, U, 0, 100, std.al, main_draw2_F, 0);
    } else if (case1416 === MODE_DATA) {
      k.div_spa(b, 0, 2, std.pt);
      k.div_add(b, U, 0, TOOLBARH, std.pt, toolbar_F, 0);
      k.div_spa(b, 0, 2, std.pt);
      k.div_add(b, U, 0, GUTTER, std.pt, d_gutter_F, 0);
      k.div_spa(b, 0, 2, std.pt);
      k.div_add(b, U, 0, 100, std.al, d_data_editarea_F, 0);
      k.div_spa(b, 0, 2, std.pt);
      k.div_add(b, U, 0, GUTTER, std.pt, d_gutter_F, 0);
      k.div_spa(b, 0, 2, std.pt);
      k.div_add(b, U, 0, TOOLBARH, std.pt, d_data_recpick_F, 0);
    }
  } else {
    k.div_add(b, U, 0, 100, std.al, opening_menu_F, 0);
  }
k.div_end(b);
k.k_leave(b);
}


//====================
//   main_modal_layer
//====================
export function main_modal_layer(b) {
k.k_enter(b);
  if (getn(g, F_is_modal_dtype) === Y) {
    k.k_isolate(b, b.bounds, "d_modal_dtype_picker", d_modal_dtype_picker_F, []);
  }
k.k_leave(b);
}


//====================
//   not_yet
//====================
function not_yet(b) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), "Not yet implemented...", { size:std.pt_to_dots(b, 24), color:std.WHITE });
k.k_leave(b);
}


//====================
//   open_butts
//====================
function open_butts(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 8, std.al);
  k.div_add(b, U, 0, 60, std.al, d_oneshot_F, 0, ["Open...", do_open_F]);
  k.div_spa(b, 0, 100, std.al);
  k.div_add(b, U, 0, 60, std.al, d_oneshot_F, 0, ["English", do_lang_F]);
  k.div_spa(b, 0, 100, std.al);
  k.div_add(b, U, 0, 60, std.al, d_oneshot_F, 0, ["Quit", do_quit_F]);
  k.div_spa(b, 0, 8, std.al);
k.div_end(b);
k.k_leave(b);
}


//====================
//   open_header
//====================
function open_header(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 0, 16, std.pt);
  k.div_add(b, U, 0, 200, std.pt, open_header_1796_F, 0);
  k.div_add(b, U, 0, 100, std.al, draw_tabs_F, 0, [addr(g, F_proj_tabs), 10]);
  k.div_spa(b, 0, 208, std.pt);
k.div_end(b);
k.k_leave(b);
}


//====================
//   opening_menu
//====================
function opening_menu(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 1, 6, std.pt);
  k.div_add(b, U, 1, TABV, std.pt, open_header_F, 0);
  k.div_spa(b, 1, 6, std.pt);
  k.div_add(b, U, 1, 100, std.al, d_recent_F, 0);
  k.div_spa(b, 1, 12, std.pt);
  k.div_add(b, U, 1, 40, std.pt, open_butts_F, 0);
  k.div_spa(b, 1, 12, std.pt);
k.div_end(b);
k.k_leave(b);
}


//====================
//   pick_dtype
//====================
function pick_dtype(b, choices) {
k.k_enter(b);
k.div_begin(b, true, true, false, false);
  const DGAP = 6;
  k.div_spa(b, 0, 2, std.pt);
  k.div_spa(b, 0, DGAP, std.pt);
  var loop1417 = new std.a_loop({ limit:4 });
  while (loop1417.next()) {
    k.div_add(b, U, 0, 12, std.al, pick_dtype_cell_F, 0);
    k.div_spa(b, 0, DGAP, std.pt);
  }
  k.div_spa(b, 0, 2, std.pt);
  k.div_spa(b, 1, DGAP, std.pt);
  var loop1418 = new std.a_loop({ limit:7 });
  while (loop1418.next()) {
    k.div_add(b, U, 1, 12, std.al, pick_dtype_cell_F, 0);
    k.div_spa(b, 1, DGAP, std.pt);
  }
  k.div_end(b);
  k.draw_grid(b, choices);
k.k_leave(b);
}


//====================
//   pick_dtype_cell
//====================
function pick_dtype_cell(b, choices) {
  k.k_enter(b);
  if (std.le2(getn(b.extra, std.F_cell_seq), std.tree_count(choices))) {
    std.draw_rect(b, addr(b.extra, std.F_box), { fill:0x42667C, corner:std.pt_to_dots(b, 4) });
    std.draw_str(b, addr(b.extra, std.F_box), gets(choices, getn(b.extra, std.F_cell_seq), F_name), { just:std.LEFT, indent:std.pt_to_dots(b, 30), size:0.6, color:BUTT_LO_TEXT
     });
  }
  k.k_leave(b);
}

//====================
//   track_pick_dtype
//====================
function track_pick_dtype(b, e, choices) {
  //---------------
  //   on EV_TAP
  //---------------
  if (std.getn(e, std.F_evkind) == std.EV_TAP) {
    if (std.le2(getn(b.extra, std.F_cell_seq), std.tree_count(choices))) {
      let new_dtype = getn(choices, getn(b.extra, std.F_cell_seq), F_type);
      if (std.eq2(getn(g, F_dtype_set_tabs, F_selx), 2)) {
        new_dtype = std.TYPE_MEAS;
      } else if (new_dtype === U) {
        new_dtype = std.TYPE_RECORD;
      }
      let new_dtype_ss = gets(choices, getn(b.extra, std.F_cell_seq), F_name);
      std.log(std.cat("  storing dtype of ", str.to_str(new_dtype, {show_u:Y}), ", ss=", new_dtype_ss));
      let slotx = getn(g, F_dtype_slot);
      std.path_setv(_M, 1118, addr(g, F_work_var, F_dtype, slotx), new_dtype);
      if (is_indirect_type(new_dtype) === Y) {
        slotx = std.add(slotx, 1);
        std.path_setv(_M, 1124, addr(g, F_work_var, F_dtype, slotx), std.TYPE_NUM);
      } else if (std.eq2(new_dtype, std.TYPE_RECORD)) {
        std.path_setv(_M, 1127, addr(g, F_work_var, F_subrec), std.get_ptr(choices, getn(b.extra, std.F_cell_seq), F_symp));
      }
      clear_dtype_slots(std.add(slotx, 1));
      do_modal_cancel();
    }
    return Y;
  return Y;
  }
  return N;
}

//====================
//   section2
//====================
function section2(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, false);
  k.div_spa(b, 1, 20, std.pt);
  var case1419 = getn(g, F_work_nk);
  if (case1419 === std.NK_COLOR) {
    k.div_add(b, U, 1, CHOICE_V, std.pt, d_name_entry_F, 0, [addr(g, F_work_name_in)]);
    k.div_spa(b, 1, std.mul(ITEM_DV, 2), std.pt);
    k.div_add(b, U, 1, ENTRY_V, std.pt, add_tool_color_F, 0, ["color", addr(g, F_work_color_ctl)]);
    k.div_spa(b, 1, std.mul(ITEM_DV, 5), std.pt);
    k.div_add(b, U, 1, CHOICE_V, std.pt, butt_work_cancel_F, 0);
    k.div_spa(b, 1, 4, std.pt);
  } else if (case1419 === std.NK_ENUM) {
    k.div_add(b, U, 1, CHOICE_V, std.pt, d_name_entry_F, 0, [addr(g, F_work_name_in)]);
    k.div_spa(b, 1, std.mul(ITEM_DV, 5), std.pt);
    k.div_add(b, U, 1, CHOICE_V, std.pt, butt_work_cancel_F, 0);
    k.div_spa(b, 1, 4, std.pt);
  } else if (case1419 === std.NK_GRAD) {
    k.div_add(b, U, 1, CHOICE_V, std.pt, d_name_entry_F, 0, [addr(g, F_work_name_in)]);
    k.div_spa(b, 1, ITEM_DV, std.pt);
    k.div_add(b, U, 1, 56, std.pt, d_gradient_bar_F, 0);
    k.div_add(b, U, 1, CHOICE_V, std.pt, butt_grad_stop_F, 0);
    k.div_spa(b, 1, ITEM_DV, std.pt);
    if (getn(g, F_work_grad_stopx) !== U) {
      k.div_add(b, U, 1, ENTRY_V, std.pt, add_tool_color_F, 0, ["color", addr(g, F_work_color_ctl)]);
      k.div_spa(b, 1, ITEM_DV, std.pt);
      k.div_add(b, U, 1, ENTRY_V, std.pt, add_tool_slider_F, 0, [addr(SLIDER_GRAD_POS)]);
      k.div_spa(b, 1, ITEM_DV, std.pt);
      k.div_add(b, U, 1, ENTRY_V, std.pt, add_tool_slider_F, 0, [addr(SLIDER_GRAD_OPACITY)]);
    } else {
      k.div_spa(b, 1, ENTRY_V, std.pt);
      k.div_spa(b, 1, ITEM_DV, std.pt);
      k.div_spa(b, 1, ENTRY_V, std.pt);
      k.div_spa(b, 1, ITEM_DV, std.pt);
      k.div_spa(b, 1, ENTRY_V, std.pt);
    }
    k.div_spa(b, 1, ITEM_DV, std.pt);
    k.div_add(b, U, 1, 40, std.pt, d_gradient_sample_F, 0);
    k.div_spa(b, 1, ITEM_DV, std.pt);
    k.div_add(b, U, 1, CHOICE_V, std.pt, d_gradient_kind_assy_F, 0);
    k.div_spa(b, 1, ITEM_DV, std.pt);
    if (std.eq2(getn(g, F_work_grad_shape, F_selx), 1)) {
      k.div_add(b, U, 1, ENTRY_V, std.pt, add_tool_slider_F, 0, [addr(SLIDER_GRAD_ANGLE)]);
      k.div_spa(b, 1, std.mul(std.add(ENTRY_V, ITEM_DV), 5), std.pt);
    } else {
      k.div_add(b, U, 1, ENTRY_V, std.pt, add_tool_slider_F, 0, [addr(SLIDER_GRAD_INNER)]);
      k.div_spa(b, 1, ITEM_DV, std.pt);
      k.div_add(b, U, 1, ENTRY_V, std.pt, add_tool_slider_F, 0, [addr(SLIDER_GRAD_OUTER)]);
      k.div_spa(b, 1, ITEM_DV, std.pt);
      k.div_add(b, U, 1, ENTRY_V, std.pt, add_tool_slider_F, 0, [addr(SLIDER_GRAD_CENTERX)]);
      k.div_spa(b, 1, ITEM_DV, std.pt);
      k.div_add(b, U, 1, ENTRY_V, std.pt, add_tool_slider_F, 0, [addr(SLIDER_GRAD_CENTERY)]);
      k.div_spa(b, 1, ITEM_DV, std.pt);
      k.div_add(b, U, 1, ENTRY_V, std.pt, add_tool_slider_F, 0, [addr(SLIDER_GRAD_FOCUSX)]);
      k.div_spa(b, 1, ITEM_DV, std.pt);
      k.div_add(b, U, 1, ENTRY_V, std.pt, add_tool_slider_F, 0, [addr(SLIDER_GRAD_FOCUSY)]);
    }
    k.div_spa(b, 1, std.mul(ITEM_DV, 5), std.pt);
    k.div_add(b, U, 1, CHOICE_V, std.pt, butt_work_cancel_F, 0);
    k.div_spa(b, 1, 4, std.pt);
  } else {
  }
  k.div_spa(b, 1, 5, std.al);
  if (getn(g, F_is_bar_visible) === Y) {
    if (getn(g, F_bar_tabx) === U) {
      k.div_spa(b, 1, ENTRY_V, std.pt);
    } else {
      let indent = std.eq2(getn(g, F_bar_tabx), PICKER_FONT_TABS) ? 33 : 0;
      k.div_add(b, U, 1, ENTRY_V, std.pt, draw_tabs_F, 0, [addr(g, F_bar_tabs, getn(g, F_bar_tabx)), indent]);
    }
  }
k.div_end(b);
k.k_leave(b);
}


//====================
//   section3
//====================
function section3(b) {
k.k_enter(b);
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:std.GRAY6 });
  var case1420 = getn(g, F_mode_tabs, F_selx);
  if (case1420 === MODE_BUILD) {
    gen_code();
    std.draw_str(b, addr(b.extra, std.F_box), g_code, { size:std.pt_to_dots(b, 11), leading:std.pt_to_dots(b, 13), font:"Iosevka Aile", vert:0, just:std.LEFT, wrap:Y, indent:std.pt_to_dots(
    b, 5), shrink:N, color:C_TOOL_LABEL });
  }
k.k_leave(b);
}


//====================
//   toolbar
//====================
function toolbar(b) {
k.k_enter(b);
k.div_begin(b, false, false, false, true);
  const SECT_GAP = 5;
  k.div_spa(b, 1, 4, std.pt);
  k.div_add(b, U, 1, TABV, std.pt, draw_tabs_F, 0, [addr(g, F_mode_tabs), 0]);
  k.div_add(b, U, 1, TAB_UND, std.pt, toolbar_1935_F, 0);
  k.div_spa(b, 1, ITEM_DV, std.pt);
  var case1421 = getn(g, F_mode_tabs, F_selx);
  if (case1421 === MODE_PROJECT) {
    k.div_add(b, U, 1, CHOICE_V, std.pt, d_name_close_F, 0);
    k.div_spa(b, 1, ITEM_DV, std.pt);
    k.div_add(b, U, 1, CHOICE_V, std.pt, d_name_entry_F, 0, [addr(g, F_prog_title_in)]);
    k.div_spa(b, 1, ITEM_DV, std.pt);
    k.div_add(b, U, 1, CHOICE_V, std.pt, draw_choice_grid_F, 0, [addr(g, F_prog_kind_choices), 0.6]);
    k.div_spa(b, 1, ITEM_DV, std.pt);
    k.div_add(b, U, 1, CHOICE_V, std.pt, d_prog_version_F, 0);
    if (std.ne2(getn(doc, F_prog_kind), 1)) {
      k.div_spa(b, 1, ITEM_DV, std.pt);
      k.div_add(b, U, 1, ENTRY_V, std.pt, draw_1_toggle_F, 0, ["Export all symbols", addr(doc, F_prog_export_all)]);
    }
    k.div_spa(b, 1, SECT_GAP, std.pt);
    k.div_add(b, U, 1, SECTION_V, std.pt, d_sectdiv_F, 0, [addr(g, F_div_imports)]);
    if (getn(g, F_div_imports, F_is_expanded) === Y) {
    }
    k.div_spa(b, 1, SECT_GAP, std.pt);
    k.div_add(b, U, 1, SECTION_V, std.pt, d_sectdiv_F, 0, [addr(g, F_div_assets)]);
    if (getn(g, F_div_assets, F_is_expanded) === Y) {
      var loop1422 = new std.a_loop({ across:addr(doc, F_syms, std.NK_ASSET) });
      while (loop1422.next()) {
      var sym = loop1422.path.clone();
        k.div_spa(b, 1, 3, std.pt);
        k.div_add(b, U, 1, 14, std.pt, d_asset_path_F, 0, [std.cat("", gets(sym, F_asset_spec, F_local), "    ", gets(sym, F_asset_spec, F_remote))]);
        var loop1423 = new std.a_loop({ across:addr(sym, F_asset_spec, F_assets2) });
        while (loop1423.next()) {
        var p2 = loop1423.path.clone();
          k.div_spa(b, 1, 1, std.pt);
          k.div_add(b, U, 1, 16, std.pt, d_asset_spec_F, 0, [gets(sym, F_asset_spec, F_local), p2]);
        }
      }
    }
    k.div_spa(b, 1, SECT_GAP, std.pt);
    k.div_add(b, U, 1, SECTION_V, std.pt, d_sectdiv_F, 0, [addr(g, F_div_enums)]);
    if (getn(g, F_div_enums, F_is_expanded) === Y) {
      var loop1424 = new std.a_loop({ across:addr(doc, F_syms, std.NK_ENUM), sort_mode:4, sort_field:F_name });
      while (loop1424.next()) {
      var sym = loop1424.path.clone();
        k.div_spa(b, 1, 1, std.pt);
        k.div_add(b, U, 1, 16, std.pt, d_enum_spec_F, 0, [sym]);
      }
    }
    k.div_spa(b, 1, SECT_GAP, std.pt);
    k.div_add(b, U, 1, SECTION_V, std.pt, d_sectdiv_F, 0, [addr(g, F_div_colors)]);
    if (getn(g, F_div_colors, F_is_expanded) === Y) {
      var loop1425 = new std.a_loop({ across:addr(doc, F_syms, std.NK_COLOR), sort_mode:4, sort_field:F_name });
      while (loop1425.next()) {
      var sym = loop1425.path.clone();
        k.div_spa(b, 1, 1, std.pt);
        k.div_add(b, U, 1, 16, std.pt, d_color_spec_F, 0, [sym]);
      }
    }
    k.div_spa(b, 1, SECT_GAP, std.pt);
    k.div_add(b, U, 1, SECTION_V, std.pt, d_sectdiv_F, 0, [addr(g, F_div_gradients)]);
    if (getn(g, F_div_gradients, F_is_expanded) === Y) {
      var loop1426 = new std.a_loop({ across:addr(doc, F_syms, std.NK_GRAD), sort_mode:4, sort_field:F_name });
      while (loop1426.next()) {
      var sym = loop1426.path.clone();
        k.div_spa(b, 1, 1, std.pt);
        k.div_add(b, U, 1, 16, std.pt, d_gradient_spec_F, 0, [sym]);
      }
    }
    k.div_spa(b, 1, SECT_GAP, std.pt);
    k.div_add(b, U, 1, SECTION_V, std.pt, d_sectdiv_F, 0, [addr(g, F_div_patterns)]);
    if (getn(g, F_div_patterns, F_is_expanded) === Y) {
    }
    k.div_spa(b, 1, SECT_GAP, std.pt);
    k.div_add(b, U, 1, SECTION_V, std.pt, d_sectdiv_F, 0, [addr(g, F_div_fonts)]);
    if (getn(g, F_div_fonts, F_is_expanded) === Y) {
    }
    k.div_spa(b, 1, SECT_GAP, std.pt);
    k.div_add(b, U, 1, SECTION_V, std.pt, d_sectdiv_F, 0, [addr(g, F_div_units)]);
    if (getn(g, F_div_units, F_is_expanded) === Y) {
    }
    k.div_spa(b, 1, 2, std.pt);
  } else if (case1421 === MODE_DATA) {
    let nlev = U;
    k.div_spa(b, 1, 2, std.pt);
    k.div_add(b, U, 1, SECTION_V, std.pt, d_sectdiv_F, 0, [addr(g, F_div_const)]);
    if (getn(g, F_div_const, F_is_expanded) === Y) {
      nlev = 1;
      k.div_spa(b, 1, 1, std.pt);
      var loop1427 = new std.a_loop({ across:addr(doc, F_syms, std.NK_CONST), sort_mode:4, sort_field:F_name });
      while (loop1427.next()) {
      var sym1 = loop1427.path.clone();
        k.div_add(b, U, 1, TOOL_ROWV, std.pt, d_var_summary_F, 0, [sym1]);
      }
    }
    k.div_spa(b, 1, 2, std.pt);
    k.div_add(b, U, 1, SECTION_V, std.pt, d_sectdiv_F, 0, [addr(g, F_div_vars)]);
    if (getn(g, F_div_vars, F_is_expanded) === Y) {
      nlev = 1;
      k.div_spa(b, 1, 1, std.pt);
      var loop1428 = new std.a_loop({ across:addr(doc, F_syms, std.NK_VAR), sort_mode:4, sort_field:F_name });
      while (loop1428.next()) {
      var sym2 = loop1428.path.clone();
        k.div_add(b, U, 1, TOOL_ROWV, std.pt, d_var_summary_F, 0, [sym2]);
      }
    }
  } else if (case1421 === MODE_CODE) {
  } else if (case1421 === MODE_BUILD) {
  }
k.div_end(b);
k.k_leave(b);
}


//====================
//   angle_to_graddir
//====================
function angle_to_graddir(ctl) {
  var case1429 = getn(g, F_work_grad, std.F_grad_angle);
  if (case1429 === 0) {
    std.path_setv(_M, 1601, addr(g, F_work_grad_dir, F_selx), 1);
  } else if (case1429 === 90) {
    std.path_setv(_M, 1603, addr(g, F_work_grad_dir, F_selx), 2);
  } else if (case1429 === 180) {
    std.path_setv(_M, 1605, addr(g, F_work_grad_dir, F_selx), 3);
  } else if (case1429 === 270) {
    std.path_setv(_M, 1607, addr(g, F_work_grad_dir, F_selx), 4);
  } else {
    std.path_setv(_M, 1609, addr(g, F_work_grad_dir, F_selx), U);
  }
}


//====================
//   apn
//====================
function apn(ss) {
  app(ss, { add_nl:Y });
}


//====================
//   app
//====================
function app(ss, _o=null) {
var add_nl = N; if ((_o != null) && _o.hasOwnProperty("add_nl")) add_nl = _o.add_nl;
  if (fresh === Y) {
    fresh = N;
    var loop1430 = new std.a_loop({ limit:indent });
    while (loop1430.next()) {
      g_code = std.cat(g_code, TAB);
    }
  }
  g_code = std.cat(g_code, ss);
  if (add_nl === Y) {
    g_code = std.cat(g_code, "\n");
    fresh = Y;
  }
}


//====================
//   app_strlit
//====================
function app_strlit(ss) {
  app("\"", {});
  var loop1431 = new std.a_loop({ from:1, to_:str.str_len(ss) });
  while (loop1431.next()) {
  var ix = loop1431.index;
    let cc = str.subset(ss, { from:ix, len:1 });
    std.log(std.cat("index ", str.to_str(ix, {show_u:Y}), ", cc=", cc));
    var case1432 = cc;
    if (case1432 === "\"") {
      app("\\\"", {});
    } else if (case1432 === "\\") {
      app("\\\\", {});
    } else {
      app(cc, {});
    }
  }
  app("\"", {});
}


//====================
//   blank
//====================
function blank() {
  app("", { add_nl:Y });
}


//====================
//   build_namelist
//====================
function build_namelist() {
  let kind = getn(g, F_work_nk);
  if (kind === U) {
    return;
  }
  std.trunc_tree(_M, 2652, addr(sorted_syms));
  var loop1433 = new std.a_loop({ across:addr(doc, F_syms, kind), sort_mode:4, sort_field:F_name });
  while (loop1433.next()) {
  var cx = loop1433.count;
  var sym = loop1433.path.clone();
    std.append_val(_M, 2654, sym, addr(sorted_syms));
  }
}


//====================
//   calc_ball_x
//====================
function calc_ball_x(ctl) {
  let val = slider_getv(ctl);
  let ballx = std.interpolate(val, getn(ctl, F_minval), getn(ctl, F_maxval), 0, std.sub(getn(ctl, F_rack_h), getn(ctl, F_ball_d)), { clamp:Y, round:Y });
  return ballx;
}


//====================
//   choice_get_selx
//====================
function choice_get_selx(c) {
  if (std.get_ptr(c, F_selx_ptr) !== null) {
    return getn(c, F_selx_ptr, std.FOL);
  } else {
    return getn(c, F_selx);
  }
}


//====================
//   choice_set_selx
//====================
function choice_set_selx(c, newval) {
  if (std.get_ptr(c, F_selx_ptr) !== null) {
    std.path_setv(_M, 3891, addr(c, F_selx_ptr, std.FOL), newval);
  } else {
    std.path_setv(_M, 3894, addr(c, F_selx), newval);
  }
}


//====================
//   clear_band_selection
//====================
function clear_band_selection() {
  std.path_setv(_M, 2640, addr(g, F_work_grad_stopx), U);
  std.path_setv(_M, 2641, addr(g, F_palette_ferrari_selx), U);
}


//====================
//   clear_dtype_slots
//====================
function clear_dtype_slots(slotx) {
  var loop1434 = new std.a_loop({  });
  while (loop1434.next()) {
    if (getn(g, F_work_var, F_dtype, slotx) === U) {
      break;
    }
    std.path_setv(_M, 1158, addr(g, F_work_var, F_dtype, slotx), U);
    slotx = std.add(slotx, 1);
  }
}


//====================
//   clear_work_name
//====================
function clear_work_name() {
  std.log("clear_work_name");
  std.input_set_value(_M, 2784, addr(g, F_work_name_in), "");
  std.path_setv(_M, 2785, addr(g, F_work_sym), U);
}


//====================
//   color_ctl_getv
//====================
function color_ctl_getv(ctl) {
  if (std.get_ptr(ctl, F_color_ptr) !== null) {
    return getn(ctl, F_color_ptr, std.FOL);
  } else {
    return getn(ctl, F_color_val);
  }
}


//====================
//   color_ctl_setss
//====================
function color_ctl_setss(ctl, name, val) {
  std.path_setv(_M, 2605, addr(ctl, F_ss_driven), U);
  std.path_setv(_M, 2606, addr(ctl, F_color_ss), name);
  if (std.get_ptr(ctl, F_color_ptr) !== null) {
    std.path_setv(_M, 2611, addr(ctl, F_color_ptr, std.FOL), val);
  } else {
    std.path_setv(_M, 2614, addr(ctl, F_color_val), val);
  }
}


//====================
//   color_ctl_setv
//====================
function color_ctl_setv(ctl, val) {
  std.path_setv(_M, 2589, addr(ctl, F_ss_driven), U);
  std.path_setv(_M, 2590, addr(ctl, F_color_ss), str.color_to_hex(val));
  if (std.get_ptr(ctl, F_color_ptr) !== null) {
    std.path_setv(_M, 2595, addr(ctl, F_color_ptr, std.FOL), val);
  } else {
    std.path_setv(_M, 2598, addr(ctl, F_color_val), val);
  }
}


//====================
//   compare_slots
//====================
function compare_slots(a, b) {
  if (std.lt2(getn(a, F_key1), getn(b, F_key1))) {
    return -1;
  } else if (std.gt2(getn(a, F_key1), getn(b, F_key1))) {
    return 1;
  }
  if (std.lt2(getn(a, F_key2), getn(b, F_key2))) {
    return -1;
  } else if (std.gt2(getn(a, F_key2), getn(b, F_key2))) {
    return 1;
  }
  if (std.lt2(getn(a, F_key3), getn(b, F_key3))) {
    return -1;
  } else if (std.gt2(getn(a, F_key3), getn(b, F_key3))) {
    return 1;
  }
  return 0;
}


//====================
//   default_linear_ctl
//====================
function default_linear_ctl() {
  slider_reset(addr(SLIDER_GRAD_ANGLE));
}


//====================
//   default_radial_ctl
//====================
function default_radial_ctl() {
  slider_reset(addr(SLIDER_GRAD_CENTERX));
  slider_reset(addr(SLIDER_GRAD_CENTERY));
  slider_reset(addr(SLIDER_GRAD_INNER));
  slider_reset(addr(SLIDER_GRAD_OUTER));
  slider_reset(addr(SLIDER_GRAD_FOCUSX));
  slider_reset(addr(SLIDER_GRAD_FOCUSY));
}


//====================
//   delta_const_choices
//====================
function delta_const_choices() {
  std.log(std.cat("delta_const_choices, selx=", str.to_str(getn(g, F_const_choices, F_selx), {show_u:Y})));
  var case1435 = getn(g, F_const_choices, F_selx);
  if (case1435 === 3) {
    set_namelist_kind(std.NK_GRAD);
  } else {
    set_namelist_kind(std.NK_CONST);
  }
}


//====================
//   delta_grad_pos
//====================
function delta_grad_pos(ctl) {
  let oldpos = getn(ctl, F_old_val);
  let newpos = slider_getv(ctl);
  fix_band_pos(std.gt4(newpos, oldpos));
}


//====================
//   do_block_add
//====================
function do_block_add() {
  std.log("do_block_add");
}


//====================
//   do_block_del
//====================
function do_block_del() {
  std.log("do_block_del");
}


//====================
//   do_block_dup
//====================
function do_block_dup() {
  std.log("do_block_dup");
}


//====================
//   do_block_skip
//====================
function do_block_skip() {
  std.log("do_block_skip");
}


//====================
//   do_close_doc
//====================
function do_close_doc() {
  std.path_setv(_M, 2739, addr(doc, F_is_doc_open), N);
}


//====================
//   do_color_add
//====================
function do_color_add() {
  std.path_setv(_M, 998, addr(g, F_work_state), WORK_NEW);
  std.path_setv(_M, 999, addr(g, F_work_sym), U);
  std.path_setv(_M, 1003, addr(g, F_work_name_in, std.F_in_value), "my_color");
  std.path_setv(_M, 1004, addr(g, F_work_color), std.WHITE);
  do_color_work_init();
}


//====================
//   do_color_edit
//====================
function do_color_edit(sym) {
  std.log(std.cat("edit color ", gets(sym, F_name)));
  std.path_setv(_M, 1013, addr(g, F_work_state), WORK_EDITING);
  std.path_setv(_M, 1014, addr(g, F_work_sym), sym);
  std.path_setv(_M, 1015, addr(g, F_work_name_in, std.F_in_value), gets(sym, F_name));
  std.path_setv(_M, 1016, addr(g, F_work_color), getn(sym, F_color));
  do_color_work_init();
}


//====================
//   do_color_work_init
//====================
function do_color_work_init() {
  std.path_setv(_M, 981, addr(g, F_work_color_ctl, F_color_ptr), addr(g, F_work_color));
  std.path_setv(_M, 982, addr(g, F_work_color_ctl, F_color_ss), str.color_to_hex(getn(g, F_work_color)));
  std.path_setv(_M, 984, addr(g, F_work_nk), std.NK_COLOR);
  std.path_setv(_M, 987, addr(g, F_is_bar_visible), Y);
  std.path_setv(_M, 988, addr(g, F_bar_tabx), PICKER_COLOR_TABS);
  std.path_setv(_M, 991, addr(g, F_palette_targ_ptr), addr(g, F_work_color_ctl));
  sync_palette(addr(g, F_work_color_ctl));
}


//====================
//   do_const_add
//====================
function do_const_add() {
  std.path_setv(_M, 1317, addr(g, F_work_nk), std.NK_CONST);
  var_add_init();
}


//====================
//   do_const_edit
//====================
function do_const_edit(sym) {
  std.path_setv(_M, 1329, addr(g, F_work_nk), std.NK_CONST);
  var_edit_init(sym);
}


//====================
//   do_enum_add
//====================
function do_enum_add() {
  std.path_setv(_M, 1024, addr(g, F_work_state), WORK_NEW);
  std.path_setv(_M, 1025, addr(g, F_work_sym), U);
  std.path_setv(_M, 1029, addr(g, F_work_name_in, std.F_in_value), "my_enum");
  std.path_setv(_M, 1030, addr(g, F_is_bar_visible), N);
  std.path_setv(_M, 1031, addr(g, F_work_nk), std.NK_ENUM);
}


//====================
//   do_enum_edit
//====================
function do_enum_edit(sym) {
  std.log(std.cat("edit enum ", gets(sym, F_name)));
  std.path_setv(_M, 1039, addr(g, F_work_state), WORK_EDITING);
  std.path_setv(_M, 1040, addr(g, F_work_sym), sym);
  std.path_setv(_M, 1041, addr(g, F_work_name_in, std.F_in_value), gets(sym, F_name));
  std.path_setv(_M, 1042, addr(g, F_is_bar_visible), N);
  std.path_setv(_M, 1043, addr(g, F_work_nk), std.NK_ENUM);
}


//====================
//   do_gradient_add
//====================
function do_gradient_add() {
  grad_work_init();
  std.path_setv(_M, 1397, addr(g, F_work_state), WORK_NEW);
  std.path_setv(_M, 1398, addr(g, F_work_sym), U);
  std.copy_tree(_M, 1401, addr(DEFAULT_GRADIENT), addr(g, F_work_grad));
  std.path_setv(_M, 1406, addr(g, F_work_name_in, std.F_in_value), "Untitled");
  intf_load_band(1);
}


//====================
//   do_gradient_edit
//====================
function do_gradient_edit(sym) {
  std.log(std.cat("edit gradient ", gets(sym, F_name)));
  grad_work_init();
  std.path_setv(_M, 1421, addr(g, F_work_state), WORK_EDITING);
  std.path_setv(_M, 1422, addr(g, F_work_sym), sym);
  std.path_setv(_M, 1423, addr(g, F_work_name_in, std.F_in_value), gets(sym, F_name));
  std.copy_tree(_M, 1426, addr(sym, F_grad), addr(g, F_work_grad));
  slider_load(addr(SLIDER_GRAD_ANGLE));
  slider_load(addr(SLIDER_GRAD_CENTERX));
  slider_load(addr(SLIDER_GRAD_CENTERY));
  slider_load(addr(SLIDER_GRAD_INNER));
  slider_load(addr(SLIDER_GRAD_OUTER));
  slider_load(addr(SLIDER_GRAD_FOCUSX));
  slider_load(addr(SLIDER_GRAD_FOCUSY));
  std.path_setv(_M, 1438, addr(g, F_work_grad_shape, F_selx), std.eq2(getn(g, F_work_grad, std.F_grad_shape), std.LINEAR_GRADIENT) ? 1 : 2);
  angle_to_graddir(addr(SLIDER_GRAD_ANGLE));
  std.path_setv(_M, 1444, addr(g, F_bar_tabx), PICKER_COLOR_TABS);
  intf_load_band(1);
}


//====================
//   do_lang
//====================
function do_lang() {
  std.log("language switch");
  std.alert("not yet");
}


//====================
//   do_modal_cancel
//====================
function do_modal_cancel() {
  std.path_setv(_M, 1164, addr(g, F_is_modal_dtype), N);
}


//====================
//   do_name_update
//====================
function do_name_update() {
  std.log("name update NOT YET");
}


//====================
//   do_namelist_add
//====================
function do_namelist_add() {
  std.log("do_namelist_add");
  std.path_setv(_M, 2756, addr(g, F_work_state), WORK_NEW);
  clear_work_name();
  var case1436 = getn(g, F_work_nk);
  if (case1436 === std.NK_GRAD) {
    std.copy_tree(_M, 2763, addr(DEFAULT_GRADIENT), addr(g, F_work_grad));
  }
}


//====================
//   do_namelist_del
//====================
function do_namelist_del() {
  std.log(std.cat("del enum name=", gets(g, F_work_sym, std.FOL, F_name)));
  std.clear_tree(_M, 2803, addr(g, F_work_sym, std.FOL));
  std.path_setv(_M, 2804, addr(g, F_work_sym), U);
  std.path_setv(_M, 2805, addr(g, F_work_state), WORK_CLOSED);
}


//====================
//   do_namelist_dup
//====================
function do_namelist_dup() {
  std.log(std.cat("dup enum name=", gets(g, F_work_sym, std.FOL, F_name)));
  std.path_setv(_M, 2790, addr(g, F_work_state), WORK_EDITING);
  std.input_set_value(_M, 2791, addr(g, F_work_name_in), std.cat(gets(g, F_work_sym, std.FOL, F_name), "_copy"));
  var case1437 = getn(g, F_work_nk);
  if (case1437 === std.NK_GRAD) {
    std.copy_tree(_M, 2797, addr(g, F_work_sym, std.FOL, F_grad), addr(g, F_work_grad));
  }
}


//====================
//   do_open
//====================
function do_open() {
  std.log("open");
  std.alert("not yet");
}


//====================
//   do_quit
//====================
function do_quit() {
  std.quit(0);
}


//====================
//   do_slider_minus
//====================
function do_slider_minus(ctl, shift) {
  std.path_setv(_M, 3200, addr(ctl, F_old_val), slider_getv(ctl));
  let step = getn(ctl, F_step);
  if ((shift === Y && std.gt2(step, 1))) {
    step = 1;
  }
  let m = std.round_multiple(getn(ctl, F_old_val), step);
  if (std.ge2(m, getn(ctl, F_old_val))) {
    m = std.sub(m, step);
  }
  let val = std.max(getn(ctl, F_minval), std.sub(getn(ctl, F_old_val), step), m);
  slider_setv(ctl, val);
  if (std.eq2(slider_getv(ctl), getn(ctl, F_old_val))) {
    std.sound_play(THUD, {});
  } else {
    std.sound_play(CLICK, {});
    if (std.get_func(ctl, F_action) !== null) {
      std.get_func(ctl, F_action).code(ctl);
    }
  }
}


//====================
//   do_slider_plus
//====================
function do_slider_plus(ctl, shift) {
  std.path_setv(_M, 3229, addr(ctl, F_old_val), slider_getv(ctl));
  let step = getn(ctl, F_step);
  if ((shift === Y && std.gt2(step, 1))) {
    step = 1;
  }
  let m = std.round_multiple(getn(ctl, F_old_val), step);
  if (std.le2(m, getn(ctl, F_old_val))) {
    m = std.add(m, step);
  }
  let val = std.min(getn(ctl, F_maxval), std.add(getn(ctl, F_old_val), step), m);
  slider_setv(ctl, val);
  if (std.eq2(slider_getv(ctl), getn(ctl, F_old_val))) {
    std.sound_play(THUD, {});
  } else {
    std.sound_play(CLICK, {});
    if (std.get_func(ctl, F_action) !== null) {
      std.get_func(ctl, F_action).code(ctl);
    }
  }
}


//====================
//   do_stop_add
//====================
function do_stop_add() {
  var ix = std.append_tree(_M, 2628, std.tree_lit(_M, 2628, std.F_stop_pos, VAL, 75, std.F_stop_color, VAL, std.MAGENTA), addr(g, F_work_grad, std.F_grad_stops));
  intf_load_band(ix);
  fix_band_pos(N);
}


//====================
//   do_stop_del
//====================
function do_stop_del() {
  std.clear_tree(_M, 2636, addr(g, F_work_grad, std.F_grad_stops, getn(g, F_work_grad_stopx)));
  clear_band_selection();
}


//====================
//   do_var_add
//====================
function do_var_add() {
  std.path_setv(_M, 1322, addr(g, F_work_nk), std.NK_VAR);
  var_add_init();
}


//====================
//   do_var_edit
//====================
function do_var_edit(sym) {
  std.path_setv(_M, 1336, addr(g, F_work_nk), std.NK_VAR);
  var_edit_init(sym);
}


//====================
//   do_work_cancel
//====================
function do_work_cancel() {
  std.log("  do_work_cancel");
  std.path_setv(_M, 1463, addr(g, F_work_state), WORK_CLOSED);
  std.path_setv(_M, 1464, addr(g, F_is_bar_visible), N);
  std.path_setv(_M, 1467, addr(g, F_work_nk), U);
  std.path_setv(_M, 1468, addr(g, F_work_sym), U);
}


//====================
//   do_work_ok
//====================
function do_work_ok() {
  std.path_setv(_M, 1476, addr(g, F_intf_namelist_mru), gets(g, F_work_name_in, std.F_in_value));
  let next_active = N;
  var case1438 = getn(g, F_work_state);
  if (case1438 === WORK_NEW) {
    let newx = std.tree_next_hi(addr(doc, F_syms, getn(g, F_work_nk)));
    std.path_setv(_M, 1486, addr(g, F_work_sym), addr(doc, F_syms, getn(g, F_work_nk), newx));
    std.log(std.cat("do_work_ok new record, storing at ", str.to_str(std.get_ptr(g, F_work_sym), {show_u:Y})));
    std.path_setv(_M, 1489, addr(g, F_work_sym, std.FOL, F_nk), getn(g, F_work_nk));
  } else if (case1438 === WORK_EDITING) {
    std.log(std.cat("do_work_ok updating ", gets(g, F_work_sym, std.FOL, F_name)));
  }
  std.path_setv(_M, 1495, addr(g, F_work_sym, std.FOL, F_name), gets(g, F_work_name_in, std.F_in_value));
  var case1439 = getn(g, F_work_nk);
  if (case1439 === std.NK_ENUM) {
    if (std.eq2(getn(g, F_work_state), WORK_NEW)) {
      std.log(std.cat("adding enum [", gets(g, F_work_name_in, std.F_in_value), "]"));
      std.input_set_value(_M, 1506, addr(g, F_work_name_in), "");
      next_active = Y;
    }
  } else if (case1439 === std.NK_ASSET) {
  } else if (case1439 === std.NK_COLOR) {
    std.copy_tree(_M, 1518, addr(g, F_work_color), addr(g, F_work_sym, std.FOL, F_color));
  } else if (case1439 === std.NK_CONST) {
  } else if (case1439 === std.NK_FUNC) {
  } else if (case1439 === std.NK_GRAD) {
    std.copy_tree(_M, 1534, addr(g, F_work_grad), addr(g, F_work_sym, std.FOL, F_grad));
  } else if (case1439 === std.NK_RECORD) {
  } else if (case1439 === std.NK_TIMER) {
  } else if (case1439 === std.NK_UNIT) {
  } else if (case1439 === std.NK_VAR) {
  } else {
    std.halt("ERROR: missing case");
  }
  if (next_active === N) {
    do_work_cancel();
  }
}


//====================
//   do_worksym_del
//====================
function do_worksym_del() {
  std.log(std.cat("delete symbol ", gets(g, F_work_sym, std.FOL, F_name)));
  std.clear_tree(_M, 1456, addr(g, F_work_sym, std.FOL));
  std.path_setv(_M, 1457, addr(g, F_work_sym), U);
  std.path_setv(_M, 1458, addr(g, F_work_state), WORK_CLOSED);
}


//====================
//   dtype_ss
//====================
function dtype_ss(dtype) {
  let ss = "";
  var loop1440 = new std.a_loop({ across:dtype });
  while (loop1440.next()) {
  var t = loop1440.val;
    ss = std.cat(ss, type_of_ss(t));
  }
  return ss;
}


//====================
//   emit_func
//====================
function emit_func(sym) {
  func_header();
  emit_func_kind(sym);
  app(symname(sym), {});
  if (gets(sym, F_comment) !== null) {
    app("  --- ", {});
    app(gets(sym, F_comment), {});
  }
  apn("");
  indent = std.add(indent, 1);
  apn("nop");
  indent = std.sub(indent, 1);
}


//====================
//   emit_func_kind
//====================
function emit_func_kind(sym) {
  var case1441 = getn(sym, F_func_spec, F_func_kind);
  if (case1441 === FUNC_CALC) {
    app("calc ", {});
  } else if (case1441 === FUNC_DRAW) {
    app("draw ", {});
  } else if (case1441 === FUNC_SLICE) {
    if (getn(sym, F_func_spec, F_func_is_horz) === Y) {
      app("horz slice ", {});
    } else {
      app("vert slice ", {});
    }
  } else if (case1441 === FUNC_SCROLL) {
    if (getn(sym, F_func_spec, F_func_is_horz) === Y) {
      app("horz scroll ", {});
    } else {
      app("vert scroll ", {});
    }
  } else if (case1441 === FUNC_GRID) {
    app("grid ", {});
  } else if (case1441 === FUNC_REPORT) {
    app("report ", {});
  } else {
    app(std.cat("???:", str.to_str(getn(sym, F_func_spec, F_func_kind), {show_u:Y}), " "), {});
  }
}


//====================
//   exec_action
//====================
function exec_action(label, action) {
  if (action === null) {
    std.alert(std.cat("NOT YET IMPLEMENTED action for ", label));
  } else {
    action.code();
  }
}


//====================
//   ferr_closest_chip
//====================
function ferr_closest_chip(targcolor) {
  let targ_r = std.color_r(targcolor);
  let targ_g = std.color_g(targcolor);
  let targ_b = std.color_b(targcolor);
  let dx = U;
  let badness = U;
  let lowest = U;
  let lowestx = U;
  let testcolor = U;
  lowest = std.INFINITY;
  var loop1442 = new std.a_loop({ across:addr(FERRARI) });
  while (loop1442.next()) {
  var ix = loop1442.index;
  testcolor = loop1442.val;
    dx = std.sub(targ_r, std.color_r(testcolor));
    badness = std.mul(dx, dx);
    dx = std.sub(targ_g, std.color_g(testcolor));
    badness = std.add(badness, std.mul(dx, dx));
    dx = std.sub(targ_b, std.color_b(testcolor));
    badness = std.add(badness, std.mul(dx, dx));
    if (std.eq2(badness, 0)) {
      return ix;
    }
    if (std.lt2(badness, lowest)) {
      lowest = badness;
      lowest = ix;
    }
  }
  return lowestx;
}


//====================
//   fix_band_pos
//====================
function fix_band_pos(is_rightwards) {
  let slot = getn(g, F_work_grad_stopx);
  let moved = N;
  if (TRACE_STOPS === Y) {
    std.log("--- before shuffle, bands");
    var loop1443 = new std.a_loop({ across:addr(g, F_work_grad, std.F_grad_stops) });
    while (loop1443.next()) {
    var ix = loop1443.index;
    var stopp = loop1443.path.clone();
      std.log(std.cat("  [", str.to_str(ix, {show_u:Y}), "]: pos=", str.to_str(getn(stopp, std.F_stop_pos), {show_u:Y}), ", color=", str.color_to_hex(getn(stopp, std.F_stop_color
      ))));
    }
  }
  if (is_rightwards === Y) {
    var loop1444 = new std.a_loop({  });
    while (loop1444.next()) {
      if (std.gt4(getn(g, F_work_grad, std.F_grad_stops, slot, std.F_stop_pos), getn(g, F_work_grad, std.F_grad_stops, std.add(slot, 1), std.F_stop_pos)) !== Y)
        break;
      std.swap_tree(_M, 1639, addr(g, F_work_grad, std.F_grad_stops, slot), addr(g, F_work_grad, std.F_grad_stops, std.add(slot, 1)));
      slot = std.add(slot, 1);
      moved = Y;
    }
  } else {
    var loop1445 = new std.a_loop({  });
    while (loop1445.next()) {
      if (std.lt4(getn(g, F_work_grad, std.F_grad_stops, slot, std.F_stop_pos), getn(g, F_work_grad, std.F_grad_stops, std.sub(slot, 1), std.F_stop_pos)) !== Y)
        break;
      std.swap_tree(_M, 1645, addr(g, F_work_grad, std.F_grad_stops, slot), addr(g, F_work_grad, std.F_grad_stops, std.sub(slot, 1)));
      slot = std.sub(slot, 1);
      moved = Y;
    }
  }
  if (moved === Y) {
    if (TRACE_STOPS === Y) {
      std.log("--- after shuffle, bands");
      var loop1446 = new std.a_loop({ across:addr(g, F_work_grad, std.F_grad_stops) });
      while (loop1446.next()) {
      var ix = loop1446.index;
      var stopp = loop1446.path.clone();
        std.log(std.cat("  [", str.to_str(ix, {show_u:Y}), "]: pos=", str.to_str(getn(stopp, std.F_stop_pos), {show_u:Y}), ", color=", str.color_to_hex(getn(stopp, std.F_stop_color
        ))));
      }
    }
    intf_load_band(slot);
  }
}


//====================
//   func_header
//====================
function func_header() {
  indent = 0;
  if (fresh === N) {
    g_code = std.cat(g_code, "\n");
  }
  fresh = Y;
  apn(FUNC_DIVIDER);
}


//====================
//   gen_code
//====================
function gen_code() {
  let first = U;
  g_code = std.cat("beads level 1 ", gets(g, F_prog_kind_choices, F_label_list, getn(doc, F_prog_kind)), " ", gets(g, F_prog_name_in, std.F_in_value));
  if (std.ne2(gets(g, F_prog_ver1_in, std.F_in_value), "")) {
    app(std.cat(" ver [", gets(g, F_prog_ver1_in, std.F_in_value)), {});
    if (std.ne2(gets(g, F_prog_ver2_in, std.F_in_value), "")) {
      app(std.cat(" ", gets(g, F_prog_ver2_in, std.F_in_value)), {});
      if (std.ne2(gets(g, F_prog_ver3_in, std.F_in_value), "")) {
        app(std.cat(" ", gets(g, F_prog_ver3_in, std.F_in_value)), {});
      }
    }
    app("]", {});
  }
  if (std.ne2(gets(g, F_prog_title_in, std.F_in_value), "")) {
    app(" title ", {});
    app_strlit(gets(g, F_prog_title_in, std.F_in_value));
  }
  if (getn(doc, F_prog_export_all) === Y) {
    app(" export_all", {});
  }
  apn("");
  apn("");
  var loop1447 = new std.a_loop({ across:addr(doc, F_syms, std.NK_ASSET) });
  while (loop1447.next()) {
  var sym = loop1447.path.clone();
    apn(std.cat("asset ", gets(sym, F_name)));
  }
  first = Y;
  var loop1448 = new std.a_loop({ across:addr(doc, F_syms, std.NK_ENUM), sort_mode:4, sort_field:F_name });
  while (loop1448.next()) {
  var sym = loop1448.path.clone();
    if (first === Y) {
      apn("");
      apn("enum");
      first = N;
      indent = std.add(indent, 1);
    }
    apn(symname(sym));
  }
  indent = 0;
  apn("");
  var loop1449 = new std.a_loop({ across:addr(doc, F_syms, std.NK_GRAD), sort_mode:4, sort_field:F_name });
  while (loop1449.next()) {
  var sym = loop1449.path.clone();
    app(std.cat("const ", symname(sym), " :a_gradient = { grad_shape:"), {});
    var case1450 = getn(sym, F_grad, std.F_grad_shape);
    if (case1450 === std.LINEAR_GRADIENT) {
      app("LINEAR_GRADIENT, grad_angle:", {});
      var case1451 = getn(sym, F_grad, std.F_grad_angle);
      if (case1451 === 0) {
        app("GRAD_TO_RIGHT", {});
      } else if (case1451 === 90) {
        app("GRAD_TO_BOTTOM", {});
      } else if (case1451 === 180) {
        app("GRAD_TO_LEFT", {});
      } else if (case1451 === 270) {
        app("GRAD_TO_TOP", {});
      } else {
        apn(std.cat("", str.to_str(getn(sym, F_grad, std.F_grad_angle), {show_u:Y}), ", "));
      }
    } else {
      apn("RADIAL_GRADIENT, ");
    }
    apn(",");
    indent = std.add(indent, 1);
    app("grad_stops:[ ", {});
    var loop1452 = new std.a_loop({ across:addr(sym, F_grad, std.F_grad_stops) });
    while (loop1452.next()) {
    var stop = loop1452.path.clone();
      app(std.cat("{ stop_pos:", str.to_str(getn(stop, std.F_stop_pos), {show_u:Y}), ", stop_color:", str.color_to_hex(getn(stop, std.F_stop_color))), {});
      if ((getn(stop, std.F_opacity) !== U && std.ne2(getn(stop, std.F_opacity), 1))) {
        app(std.cat(", opacity:", str.to_str(getn(stop, std.F_opacity), { digits:3 })), {});
      }
      apn(" },");
    }
    apn(" ] }");
    indent = std.sub(indent, 1);
  }
  apn("");
  var loop1453 = new std.a_loop({ across:addr(doc, F_syms, std.NK_TIMER), sort_mode:4, sort_field:F_name });
  while (loop1453.next()) {
  var sym = loop1453.path.clone();
    apn(std.cat("__timer__ ", symname(sym)));
  }
  apn("");
  var loop1454 = new std.a_loop({ across:addr(doc, F_syms, std.NK_UNIT), sort_mode:4, sort_field:F_name });
  while (loop1454.next()) {
  var sym = loop1454.path.clone();
    apn(std.cat("unit ", symname(sym)));
  }
  var loop1455 = new std.a_loop({ across:addr(doc, F_syms, std.NK_RECORD), sort_mode:4, sort_field:F_name });
  while (loop1455.next()) {
  var sym = loop1455.path.clone();
    apn("");
    apn(std.cat("record ", symname(sym)));
    indent = std.add(indent, 1);
    var loop1456 = new std.a_loop({ across:addr(sym, F_rec_spec, F_fields) });
    while (loop1456.next()) {
    var field = loop1456.path.clone();
      apn(std.cat("", gets(field, F_name), " : ", dtype_ss(addr(field, F_dtype))));
    }
    indent = std.sub(indent, 1);
  }
  apn("");
  var loop1457 = new std.a_loop({ across:addr(doc, F_syms, std.NK_CONST) });
  while (loop1457.next()) {
  var sym = loop1457.path.clone();
    apn(std.cat("const ", symname(sym)));
  }
  apn("");
  var loop1458 = new std.a_loop({ across:addr(doc, F_syms, std.NK_VAR), sort_mode:4, sort_field:F_name });
  while (loop1458.next()) {
  var sym = loop1458.path.clone();
    apn(std.cat("var ", symname(sym)));
  }
  var loop1459 = new std.a_loop({ across:addr(doc, F_syms, std.NK_FUNC), sort_mode:4, sort_field:F_name });
  while (loop1459.next()) {
  var sym = loop1459.path.clone();
    emit_func(sym);
  }
}


//====================
//   grad_work_init
//====================
function grad_work_init() {
  std.path_setv(_M, 1380, addr(g, F_bar_tabx), PICKER_COLOR_TABS);
  std.path_setv(_M, 1383, addr(g, F_palette_targ_ptr), addr(g, F_work_color_ctl));
  std.path_setv(_M, 1385, addr(g, F_is_bar_visible), Y);
  std.path_setv(_M, 1386, addr(g, F_work_nk), std.NK_GRAD);
  default_linear_ctl();
  default_radial_ctl();
}


//====================
//   html_palette_init
//====================
function html_palette_init() {
  if (NCELLS !== U) {
    return;
  }
  let hsv = new std.a_tree("builder","hsv");
  var loop1460 = new std.a_loop({ across:addr(SET1) });
  while (loop1460.next()) {
  var ix = loop1460.index;
  var p = loop1460.path.clone();
    std.copy_tree(_M, 4654, std.color_to_hsv(getn(p, F_color)), addr(hsv));
    let hue2 = std.rem(std.add(getn(hsv, std.F_hue), hue_fudge), 360, {});
    if (std.le2(getn(hsv, std.F_saturation), 10)) {
      std.path_setv(_M, 4662, addr(p, F_key1), 90);
      std.path_setv(_M, 4663, addr(p, F_key2), hue2);
      std.path_setv(_M, 4664, addr(p, F_key3), getn(hsv, std.F_value));
    } else if (std.ge2(getn(hsv, std.F_saturation), 90)) {
      std.path_setv(_M, 4666, addr(p, F_key1), 10);
      std.path_setv(_M, 4667, addr(p, F_key2), hue2);
      std.path_setv(_M, 4668, addr(p, F_key3), getn(hsv, std.F_value));
    } else {
      std.path_setv(_M, 4671, addr(p, F_key1), 50);
      std.path_setv(_M, 4672, addr(p, F_key2), hue2);
      std.path_setv(_M, 4673, addr(p, F_key3), getn(hsv, std.F_saturation));
    }
  }
  var loop1461 = new std.a_loop({ across:addr(SET1), sort_mode:5, sort_func:compare_slots });
  while (loop1461.next()) {
  var cx = loop1461.count;
  var ix = loop1461.index;
  var p = loop1461.path.clone();
    std.append_val(_M, 4680, p, addr(slotlist));
  }
  var loop1462 = new std.a_loop({ across:addr(SET2) });
  while (loop1462.next()) {
  var p = loop1462.path.clone();
    std.append_val(_M, 4685, p, addr(slotlist));
  }
  if (TRACE_COLORS === Y) {
    std.log("----- after sort ------");
    var loop1463 = new std.a_loop({ across:addr(slotlist) });
    while (loop1463.next()) {
    var ix = loop1463.index;
    var p = loop1463.val;
      std.log(std.cat("", str.to_str(ix, {show_u:Y}), ": ", gets(p, F_name), ", keys=[", str.to_str(getn(p, F_key1), {show_u:Y}), ",", str.to_str(getn(p, F_key2), {show_u:Y}), ","
      , str.to_str(getn(p, F_key3), {show_u:Y}), "], color=", str.color_to_hex(getn(p, F_color))));
    }
  }
  std.path_setv(_M, 4692, addr(gsc, F_format), FORMAT_BEADS);
  NCELLS = std.tree_count(addr(slotlist));
}


//====================
//   html_slot_str
//====================
function html_slot_str(slot) {
  return gets(slot, F_name);
}


//====================
//   intf_load_band
//====================
function intf_load_band(bandx) {
  std.path_setv(_M, 2566, addr(g, F_work_grad_stopx), bandx);
  std.path_setv(_M, 2569, addr(g, F_work_color_ctl, F_color_ptr), addr(g, F_work_grad, std.F_grad_stops, bandx, std.F_stop_color));
  std.path_setv(_M, 2570, addr(g, F_work_color_ctl, F_color_ss), str.color_to_hex(getn(g, F_work_grad, std.F_grad_stops, bandx, std.F_stop_color)));
  std.path_setv(_M, 2573, addr(SLIDER_GRAD_POS, F_val_ptr), addr(g, F_work_grad, std.F_grad_stops, bandx, std.F_stop_pos));
  std.path_setv(_M, 2574, addr(SLIDER_GRAD_OPACITY, F_val_ptr), addr(g, F_work_grad, std.F_grad_stops, bandx, std.F_opacity));
  slider_load(addr(SLIDER_GRAD_POS));
  slider_load(addr(SLIDER_GRAD_OPACITY));
  sync_palette(addr(g, F_work_color_ctl));
}


//====================
//   is_indirect_type
//====================
function is_indirect_type(type) {
  var case1464 = type;
  if (case1464 === std.TYPE_PTR || case1464 === std.TYPE_ARRAY || case1464 === std.TYPE_ARRAY2 || case1464 === std.TYPE_ARRAY3 || case1464 === std.TYPE_ARRAY4) {
    return Y;
  }
  return N;
}


//====================
//   main_init
//====================
export function main_init() {
  std.copy_tree(_M, 580, std.tree_lit(_M, 580, F_font_exp, VAL, "_sans", F_font_net, VAL, "_sans"), addr(g, F_intf_font));
  std.path_setv(_M, 581, addr(g, F_intf_bbox), "b.box");
  std.path_setv(_M, 584, addr(g, F_intf_text_html), N);
  std.path_setv(_M, 585, addr(g, F_intf_text_bold), N);
  std.path_setv(_M, 586, addr(g, F_intf_text_italic), N);
  std.path_setv(_M, 587, addr(g, F_intf_text_wrap), N);
  std.path_setv(_M, 588, addr(g, F_intf_text_hideu), N);
  std.path_setv(_M, 589, addr(g, F_intf_text_shrink), Y);
  std.path_setv(_M, 590, addr(g, F_intf_image_shrink), Y);
  std.path_setv(_M, 591, addr(g, F_intf_image_grow), Y);
  std.path_setv(_M, 592, addr(g, F_intf_image_aspect), Y);
  std.path_setv(_M, 594, addr(g, F_mode_tabs, F_selx), MODE_DATA);
  std.copy_tree(_M, 595, std.tree_lit(_M, 595, 1, VAL, "Project", 2, VAL, "Data", 3, VAL, "Code", 4, VAL, "Build"), addr(g, F_mode_tabs, F_label_list));
  std.path_setv(_M, 596, addr(g, F_mode_tabs, F_action), do_work_cancel_F);
  std.path_setv(_M, 598, addr(g, F_bar_tabs, PICKER_COLOR_TABS, F_selx), 3);
  std.copy_tree(_M, 599, std.tree_lit(_M, 599, 1, VAL, "Constants", 2, VAL, "HTML colors", 3, VAL, "Swatches"), addr(g, F_bar_tabs, PICKER_COLOR_TABS, F_label_list));
  std.path_setv(_M, 601, addr(g, F_bar_tabs, PICKER_FONT_TABS, F_selx), 1);
  std.copy_tree(_M, 602, std.tree_lit(_M, 602, 1, VAL, "Fonts"), addr(g, F_bar_tabs, PICKER_FONT_TABS, F_label_list));
  std.copy_tree(_M, 605, std.tree_lit(_M, 605, 1, VAL, "Basic", 2, VAL, "Units", 3, VAL, "Project", 4, VAL, "Library"), addr(g, F_dtype_set_tabs, F_label_list));
  std.path_setv(_M, 607, addr(g, F_block_kind_grid, F_selx), BKIND_PLAIN);
  std.copy_tree(_M, 608, std.tree_lit(_M, 608, 1, VAL, "Plain", 2, VAL, "Horz", 3, VAL, "Vert", 4, VAL, "Subset", 5, VAL, "Grid", 6, VAL, "Report"), addr(g, F_block_kind_grid
  , F_label_list));
  std.copy_tree(_M, 609, std.tree_lit(_M, 609, 1, VAL, 1, 2, VAL, 2, 3, VAL, 3, 4, VAL, 4, 5, VAL, 5, 6, VAL, 6), addr(g, F_block_kind_grid, F_val_list));
  std.path_setv(_M, 611, addr(g, F_const_choices, F_selx), 1);
  std.path_setv(_M, 612, addr(g, F_const_choices, F_nrows), 2);
  std.copy_tree(_M, 613, std.tree_lit(_M, 613, 1, VAL, "num", 2, VAL, "yesno", 3, VAL, "gradient", 4, VAL, "tree", 5, VAL, "str", 6, VAL, "color", 7, VAL, "meas", 8, VAL, "any"
  ), addr(g, F_const_choices, F_label_list));
  std.copy_tree(_M, 615, std.tree_lit(_M, 615, 1, VAL, 1, 2, VAL, 2, 3, VAL, 3, 4, VAL, 4, 5, VAL, 5, 6, VAL, 6, 7, VAL, 7, 8, VAL, 8), addr(g, F_const_choices, F_val_list));
  std.path_setv(_M, 616, addr(g, F_const_choices, F_choice_func), delta_const_choices_F);
  std.path_setv(_M, 619, addr(doc, F_prog_kind), 1);
  std.path_setv(_M, 620, addr(g, F_prog_kind_choices, F_selx_ptr), addr(doc, F_prog_kind));
  std.path_setv(_M, 621, addr(g, F_prog_kind_choices, F_nrows), 1);
  std.copy_tree(_M, 622, std.tree_lit(_M, 622, 1, VAL, "program", 2, VAL, "library", 3, VAL, "monitor", 4, VAL, "server"), addr(g, F_prog_kind_choices, F_label_list));
  std.copy_tree(_M, 625, std.table_litP(F_name, F_type, VAL, "array", std.TYPE_ARRAY, VAL, "array^2", std.TYPE_ARRAY2, VAL, "array^3", std.TYPE_ARRAY3, VAL, "array^4", std.TYPE_ARRAY4
    , VAL, "bits", std.TYPE_BITS, VAL, "bytes", std.TYPE_BYTES, VAL, "color", std.TYPE_COLOR, VAL, "enum", std.TYPE_ENUM, VAL, "func", std.TYPE_FUNC, VAL, "image", std.TYPE_IMAGE
    , VAL, "meas", std.TYPE_MEAS, VAL, "num", std.TYPE_NUM, VAL, "pattern", std.TYPE_PATTERN, VAL, "ptr", std.TYPE_PTR, VAL, "sound", std.TYPE_SOUND, VAL, "str", std.TYPE_STR, VAL
    , "tree", std.TYPE_TREE, VAL, "video", std.TYPE_VIDEO, VAL, "yesno", std.TYPE_YESNO), addr(g, F_dtype_choices, 1));
  std.copy_tree(_M, 648, std.table_litP(F_name, VAL, "Angle", VAL, "Area", VAL, "Energy", VAL, "Force", VAL, "Frequency", VAL, "Length", VAL, "Mass", VAL, "Power", VAL, "Pressure"
    , VAL, "Speed", VAL, "Temperature", VAL, "Time", VAL, "Volume"), addr(g, F_dtype_choices, 2));
  std.path_setv(_M, 664, addr(g, F_proj_tabs, F_selx), 1);
  std.copy_tree(_M, 665, std.tree_lit(_M, 665, 1, VAL, "My projects", 2, VAL, "Community Projects"), addr(g, F_proj_tabs, F_label_list));
  std.path_setv(_M, 667, addr(g, F_timer_how_timed, F_selx), 1);
  std.copy_tree(_M, 668, std.tree_lit(_M, 668, 1, VAL, "Interval", 2, VAL, "Rate"), addr(g, F_timer_how_timed, F_label_list));
  std.copy_tree(_M, 669, std.tree_lit(_M, 669, 1, VAL, 1, 2, VAL, 2), addr(g, F_timer_how_timed, F_val_list));
  std.path_setv(_M, 671, addr(g, F_timer_time_grid, F_selx), 1);
  std.copy_tree(_M, 672, std.tree_lit(_M, 672, 1, VAL, "sec", 2, VAL, "min", 3, VAL, "hour", 4, VAL, "day"), addr(g, F_timer_time_grid, F_label_list));
  std.copy_tree(_M, 673, std.tree_lit(_M, 673, 1, VAL, 1, 2, VAL, 2, 3, VAL, 3, 4, VAL, 4), addr(g, F_timer_time_grid, F_val_list));
  std.path_setv(_M, 675, addr(g, F_timer_nreps_grid, F_selx), 1);
  std.copy_tree(_M, 676, std.tree_lit(_M, 676, 1, VAL, "1", 2, VAL, "infinite"), addr(g, F_timer_nreps_grid, F_label_list));
  std.copy_tree(_M, 677, std.tree_lit(_M, 677, 1, VAL, 1, 2, VAL, 2), addr(g, F_timer_nreps_grid, F_val_list));
  std.path_setv(_M, 678, addr(g, F_timer_nreps_grid, F_choice_func), store_repetitions_F);
  std.path_setv(_M, 680, addr(g, F_work_state), WORK_CLOSED);
  std.path_setv(_M, 682, addr(g, F_work_grad_shape, F_selx), 1);
  std.copy_tree(_M, 683, std.tree_lit(_M, 683, 1, VAL, "Linear", 2, VAL, "Radial"), addr(g, F_work_grad_shape, F_label_list));
  std.copy_tree(_M, 684, std.tree_lit(_M, 684, 1, VAL, std.LINEAR_GRADIENT, 2, VAL, std.RADIAL_GRADIENT), addr(g, F_work_grad_shape, F_val_list));
  std.path_setv(_M, 685, addr(g, F_work_grad_shape, F_choice_func), store_gradshape_F);
  std.path_setv(_M, 687, addr(g, F_work_grad_dir, F_selx), 1);
  std.copy_tree(_M, 688, std.tree_lit(_M, 688, 1, VAL, "", 2, VAL, "", 3, VAL, "", 4, VAL, ""), addr(g, F_work_grad_dir, F_label_list));
  std.copy_tree(_M, 689, std.tree_lit(_M, 689, 1, VAL, 1, 2, VAL, 2, 3, VAL, 3, 4, VAL, 4), addr(g, F_work_grad_dir, F_val_list));
  std.path_setv(_M, 690, addr(g, F_work_grad_dir, F_choice_func), store_graddir_F);
  std.path_setv(_M, 692, addr(g, F_block_slice_grid, F_selx), BKINDSL_SLICE);
  std.copy_tree(_M, 693, std.tree_lit(_M, 693, 1, VAL, "Slice", 2, VAL, "Scroll"), addr(g, F_block_slice_grid, F_label_list));
  std.copy_tree(_M, 694, std.tree_lit(_M, 694, 1, VAL, 1, 2, VAL, 2), addr(g, F_block_slice_grid, F_val_list));
  std.path_setv(_M, 696, addr(g, F_block_add_unit_grid, F_selx), UNIT_AL);
  std.copy_tree(_M, 697, std.tree_lit(_M, 697, 1, VAL, "aliq", 2, VAL, "point", 3, VAL, "pixel"), addr(g, F_block_add_unit_grid, F_label_list));
  std.copy_tree(_M, 698, std.tree_lit(_M, 698, 1, VAL, 1, 2, VAL, 2, 3, VAL, 3), addr(g, F_block_add_unit_grid, F_val_list));
  std.path_setv(_M, 699, addr(g, F_add_expr), "12");
  std.path_setv(_M, 701, addr(g, F_draw_tools, F_selx), 1);
  std.copy_tree(_M, 702, std.tree_lit(_M, 702, 1, VAL, "Text", 2, VAL, "Rect", 3, VAL, "Oval", 4, VAL, "Polygon", 5, VAL, "Line", 6, VAL, "Image"), addr(g, F_draw_tools, F_label_list
  ));
  std.copy_tree(_M, 703, std.tree_lit(_M, 703, 1, VAL, icon_text_F, 2, VAL, icon_rect_F, 3, VAL, icon_oval_F, 4, VAL, icon_poly_F, 5, VAL, icon_line_F, 6, VAL, icon_image_F)
  , addr(g, F_draw_tools, F_label_func));
  std.copy_tree(_M, 704, std.tree_lit(_M, 704, 1, VAL, 1, 2, VAL, 2, 3, VAL, 3, 4, VAL, 4, 5, VAL, 5, 6, VAL, 6), addr(g, F_draw_tools, F_val_list));
  std.path_setv(_M, 706, addr(g, F_ncorner_grid, F_selx), 1);
  std.copy_tree(_M, 707, std.tree_lit(_M, 707, 1, VAL, "1", 2, VAL, "4"), addr(g, F_ncorner_grid, F_label_list));
  std.copy_tree(_M, 708, std.tree_lit(_M, 708, 1, VAL, 1, 2, VAL, 4), addr(g, F_ncorner_grid, F_val_list));
  std.path_setv(_M, 710, addr(g, F_text_size_grid, F_selx), 1);
  std.copy_tree(_M, 711, std.tree_lit(_M, 711, 1, VAL, "pts", 2, VAL, "%"), addr(g, F_text_size_grid, F_label_list));
  std.copy_tree(_M, 712, std.tree_lit(_M, 712, 1, VAL, 1, 2, VAL, 2), addr(g, F_text_size_grid, F_val_list));
  std.path_setv(_M, 714, addr(g, F_text_just_grid, F_selx), 2);
  std.copy_tree(_M, 715, std.tree_lit(_M, 715, 1, VAL, "Left", 2, VAL, "Center", 3, VAL, "Right", 4, VAL, "Flush"), addr(g, F_text_just_grid, F_label_list));
  std.copy_tree(_M, 716, std.tree_lit(_M, 716, 1, VAL, std.LEFT, 2, VAL, std.CENTER, 3, VAL, std.RIGHT, 4, VAL, std.FLUSH), addr(g, F_text_just_grid, F_val_list));
  std.path_setv(_M, 718, addr(g, F_fill_choices, F_selx), 1);
  std.copy_tree(_M, 719, std.tree_lit(_M, 719, 1, VAL, "Color", 2, VAL, "Gradient", 3, VAL, "Tiled"), addr(g, F_fill_choices, F_label_list));
  std.copy_tree(_M, 720, std.tree_lit(_M, 720, 1, VAL, 1, 2, VAL, 2, 3, VAL, 3), addr(g, F_fill_choices, F_val_list));
  std.path_setv(_M, 722, addr(g, F_line_cap_grid, F_selx), 1);
  std.copy_tree(_M, 723, std.tree_lit(_M, 723, 1, VAL, "Butt", 2, VAL, "Round", 3, VAL, "Square"), addr(g, F_line_cap_grid, F_label_list));
  std.copy_tree(_M, 724, std.tree_lit(_M, 724, 1, VAL, 1, 2, VAL, 2, 3, VAL, 3), addr(g, F_line_cap_grid, F_val_list));
  std.path_setv(_M, 726, addr(g, F_line_joint_grid, F_selx), 1);
  std.copy_tree(_M, 727, std.tree_lit(_M, 727, 1, VAL, "Round", 2, VAL, "Miter", 3, VAL, "Bevel"), addr(g, F_line_joint_grid, F_label_list));
  std.copy_tree(_M, 728, std.tree_lit(_M, 728, 1, VAL, 1, 2, VAL, 2, 3, VAL, 3), addr(g, F_line_joint_grid, F_val_list));
  std.path_setv(_M, 730, addr(g, F_add_expr), "12");
  std.copy_tree(_M, 732, addr(g, F_block_add_unit_grid), addr(g, F_block_skip_unit_grid));
  std.path_setv(_M, 733, addr(g, F_skip_expr), "4");
  std.copy_tree(_M, 737, std.tree_lit(_M, 737, F_color_ss, VAL, ""), addr(g, F_intf_fill_color));
  std.copy_tree(_M, 738, std.tree_lit(_M, 738, F_color_ss, VAL, "BLACK", F_color_val, VAL, std.BLACK), addr(g, F_intf_text_color));
  std.copy_tree(_M, 739, std.tree_lit(_M, 739, F_color_ss, VAL, "BLACK", F_color_val, VAL, std.BLACK), addr(g, F_intf_stroke_color));
  std.path_setv(_M, 742, addr(g, F_work_name_in, std.F_in_label), "work_name_in");
  std.path_setv(_M, 743, addr(g, F_work_name_in, std.F_in_name), "name");
  std.path_setv(_M, 744, addr(g, F_work_name_in, std.F_in_value), "");
  std.path_setv(_M, 745, addr(g, F_work_name_in, std.F_in_ok), Y);
  std.path_setv(_M, 746, addr(g, F_work_name_in, std.F_in_validator), validate_varname_F);
  std.path_setv(_M, 748, addr(g, F_work_name_in, std.F_in_minlen), 1);
  std.path_setv(_M, 749, addr(g, F_work_name_in, std.F_in_required), Y);
  std.path_setv(_M, 752, addr(g, F_prog_name_in, std.F_in_label), "prog_name_in");
  std.path_setv(_M, 753, addr(g, F_prog_name_in, std.F_in_name), "name");
  std.path_setv(_M, 754, addr(g, F_prog_name_in, std.F_in_value), "my_program");
  std.path_setv(_M, 755, addr(g, F_prog_name_in, std.F_in_ok), Y);
  std.path_setv(_M, 756, addr(g, F_prog_name_in, std.F_in_validator), validate_varname_F);
  std.path_setv(_M, 758, addr(g, F_prog_name_in, std.F_in_minlen), 1);
  std.path_setv(_M, 759, addr(g, F_prog_name_in, std.F_in_required), Y);
  std.path_setv(_M, 762, addr(g, F_prog_title_in, std.F_in_label), "prog_title_in");
  std.path_setv(_M, 763, addr(g, F_prog_title_in, std.F_in_name), "title");
  std.path_setv(_M, 764, addr(g, F_prog_title_in, std.F_in_value), "");
  std.path_setv(_M, 765, addr(g, F_prog_title_in, std.F_in_ok), Y);
  std.path_setv(_M, 768, addr(g, F_prog_ver1_in, std.F_in_label), "prog_ver1");
  std.path_setv(_M, 769, addr(g, F_prog_ver1_in, std.F_in_name), "Version");
  std.path_setv(_M, 770, addr(g, F_prog_ver1_in, std.F_in_value), "1");
  std.path_setv(_M, 771, addr(g, F_prog_ver1_in, std.F_in_ok), Y);
  std.path_setv(_M, 772, addr(g, F_prog_ver1_in, std.F_in_pattern), PATT_CARDINAL);
  std.path_setv(_M, 774, addr(g, F_prog_ver2_in, std.F_in_label), "prog_ver2");
  std.path_setv(_M, 775, addr(g, F_prog_ver2_in, std.F_in_name), "");
  std.path_setv(_M, 776, addr(g, F_prog_ver2_in, std.F_in_value), "0");
  std.path_setv(_M, 777, addr(g, F_prog_ver2_in, std.F_in_ok), Y);
  std.path_setv(_M, 778, addr(g, F_prog_ver2_in, std.F_in_pattern), PATT_CARDINAL);
  std.path_setv(_M, 780, addr(g, F_prog_ver3_in, std.F_in_label), "prog_ver3");
  std.path_setv(_M, 781, addr(g, F_prog_ver3_in, std.F_in_name), "");
  std.path_setv(_M, 782, addr(g, F_prog_ver3_in, std.F_in_value), "0");
  std.path_setv(_M, 783, addr(g, F_prog_ver3_in, std.F_in_ok), Y);
  std.path_setv(_M, 784, addr(g, F_prog_ver3_in, std.F_in_pattern), PATT_CARDINAL);
  std.path_setv(_M, 786, addr(g, F_timer_func_in, std.F_in_label), "timer_func_in");
  std.path_setv(_M, 787, addr(g, F_timer_func_in, std.F_in_name), "do function");
  std.path_setv(_M, 788, addr(g, F_timer_func_in, std.F_in_value), "");
  std.path_setv(_M, 789, addr(g, F_timer_func_in, std.F_in_ok), Y);
  std.path_setv(_M, 790, addr(g, F_timer_func_in, std.F_in_minlen), 1);
  std.path_setv(_M, 791, addr(g, F_timer_func_in, std.F_in_required), Y);
  std.path_setv(_M, 793, addr(g, F_timer_start_in, std.F_in_label), "timer_start_in");
  std.path_setv(_M, 794, addr(g, F_timer_start_in, std.F_in_name), "start time");
  std.path_setv(_M, 795, addr(g, F_timer_start_in, std.F_in_value), "");
  std.path_setv(_M, 796, addr(g, F_timer_start_in, std.F_in_ok), Y);
  std.path_setv(_M, 798, addr(g, F_timer_group_in, std.F_in_label), "timer_group_in");
  std.path_setv(_M, 799, addr(g, F_timer_group_in, std.F_in_name), "group");
  std.path_setv(_M, 800, addr(g, F_timer_group_in, std.F_in_value), "");
  std.path_setv(_M, 801, addr(g, F_timer_group_in, std.F_in_ok), Y);
  std.path_setv(_M, 803, addr(g, F_timer_prereq_in, std.F_in_label), "timer_prereq_in");
  std.path_setv(_M, 804, addr(g, F_timer_prereq_in, std.F_in_name), "prerequisite");
  std.path_setv(_M, 805, addr(g, F_timer_prereq_in, std.F_in_value), "");
  std.path_setv(_M, 806, addr(g, F_timer_prereq_in, std.F_in_ok), Y);
  std.path_setv(_M, 808, addr(g, F_timer_nreps_in, std.F_in_label), "timer_nreps_in");
  std.path_setv(_M, 809, addr(g, F_timer_nreps_in, std.F_in_name), "");
  std.path_setv(_M, 810, addr(g, F_timer_nreps_in, std.F_in_value), "");
  std.path_setv(_M, 811, addr(g, F_timer_nreps_in, std.F_in_ok), Y);
  std.path_setv(_M, 812, addr(g, F_timer_nreps_in, std.F_in_pattern), PATT_CARDINAL);
  std.path_setv(_M, 814, addr(g, F_div_imports, F_prompt), "Imports");
  std.path_setv(_M, 815, addr(g, F_div_imports, F_nk), NK_IMPORT);
  std.path_setv(_M, 817, addr(g, F_div_assets, F_prompt), "Art Assets");
  std.path_setv(_M, 818, addr(g, F_div_assets, F_nk), std.NK_ASSET);
  std.path_setv(_M, 820, addr(g, F_div_enums, F_prompt), "Enums");
  std.path_setv(_M, 821, addr(g, F_div_enums, F_nk), std.NK_ENUM);
  std.path_setv(_M, 822, addr(g, F_div_enums, F_action_add), do_enum_add_F);
  std.path_setv(_M, 823, addr(g, F_div_enums, F_action_del), do_worksym_del_F);
  std.path_setv(_M, 825, addr(g, F_div_colors, F_prompt), "Colors");
  std.path_setv(_M, 826, addr(g, F_div_colors, F_nk), std.NK_COLOR);
  std.path_setv(_M, 827, addr(g, F_div_colors, F_action_add), do_color_add_F);
  std.path_setv(_M, 828, addr(g, F_div_colors, F_action_del), do_worksym_del_F);
  std.path_setv(_M, 830, addr(g, F_div_gradients, F_prompt), "Gradients");
  std.path_setv(_M, 831, addr(g, F_div_gradients, F_nk), std.NK_GRAD);
  std.path_setv(_M, 832, addr(g, F_div_gradients, F_action_add), do_gradient_add_F);
  std.path_setv(_M, 833, addr(g, F_div_gradients, F_action_del), do_worksym_del_F);
  std.path_setv(_M, 835, addr(g, F_div_patterns, F_prompt), "Patterns");
  std.path_setv(_M, 836, addr(g, F_div_patterns, F_nk), NK_PATTERN);
  std.path_setv(_M, 838, addr(g, F_div_fonts, F_prompt), "Fonts");
  std.path_setv(_M, 839, addr(g, F_div_fonts, F_nk), NK_FONT);
  std.path_setv(_M, 841, addr(g, F_div_units, F_prompt), "Units");
  std.path_setv(_M, 842, addr(g, F_div_units, F_nk), std.NK_UNIT);
  std.path_setv(_M, 844, addr(g, F_div_recs, F_prompt), "Records");
  std.path_setv(_M, 845, addr(g, F_div_recs, F_nk), std.NK_RECORD);
  std.path_setv(_M, 846, addr(g, F_div_recs, F_is_expanded), Y);
  std.path_setv(_M, 848, addr(g, F_div_recs2, F_prompt), "System");
  std.path_setv(_M, 849, addr(g, F_div_recs2, F_nk), std.NK_RECORD);
  std.path_setv(_M, 850, addr(g, F_div_recs2, F_is_readonly), Y);
  std.path_setv(_M, 851, addr(g, F_div_recs2, F_is_expanded), Y);
  std.path_setv(_M, 853, addr(g, F_div_const, F_prompt), "Constants");
  std.path_setv(_M, 854, addr(g, F_div_const, F_nk), std.NK_CONST);
  std.path_setv(_M, 855, addr(g, F_div_const, F_is_expanded), Y);
  std.path_setv(_M, 856, addr(g, F_div_const, F_action_add), do_const_add_F);
  std.path_setv(_M, 857, addr(g, F_div_const, F_action_del), do_worksym_del_F);
  std.path_setv(_M, 859, addr(g, F_div_vars, F_prompt), "Variables");
  std.path_setv(_M, 860, addr(g, F_div_vars, F_nk), std.NK_VAR);
  std.path_setv(_M, 861, addr(g, F_div_vars, F_is_expanded), Y);
  std.path_setv(_M, 862, addr(g, F_div_vars, F_action_add), do_var_add_F);
  std.path_setv(_M, 863, addr(g, F_div_vars, F_action_del), do_worksym_del_F);
  std.append_tree(_M, 868, std.tree_lit(_M, 868, F_nk, VAL, std.NK_RECORD, F_name, VAL, "a_date", F_is_expanded, VAL, Y, F_is_stdlib, VAL, Y, F_rec_spec, F_is_expanded, VAL, 
  Y, F_fields, 1, F_name, VAL, "left", F_dtype, 1, VAL, std.TYPE_NUM, POP, POP, 2, F_name, VAL, "top", F_dtype, 1, VAL, std.TYPE_NUM, POP, POP, 3, F_name, VAL, "width", F_dtype
  , 1, VAL, std.TYPE_NUM, POP, POP, 4, F_name, VAL, "height", F_dtype, 1, VAL, std.TYPE_NUM, POP, POP, POP, POP), addr(lib_syms, std.NK_RECORD));
  std.append_tree(_M, 874, std.tree_lit(_M, 874, F_nk, VAL, std.NK_RECORD, F_name, VAL, "a_rect", F_is_expanded, VAL, Y, F_is_stdlib, VAL, Y, F_rec_spec, F_is_expanded, VAL, 
  Y, F_fields, 1, F_name, VAL, "left", F_dtype, 1, VAL, std.TYPE_NUM, POP, POP, 2, F_name, VAL, "top", F_dtype, 1, VAL, std.TYPE_NUM, POP, POP, 3, F_name, VAL, "width", F_dtype
  , 1, VAL, std.TYPE_NUM, POP, POP, 4, F_name, VAL, "height", F_dtype, 1, VAL, std.TYPE_NUM, POP, POP, POP, POP), addr(lib_syms, std.NK_RECORD));
  std.append_tree(_M, 880, std.tree_lit(_M, 880, F_nk, VAL, std.NK_RECORD, F_name, VAL, "a_xy", F_is_expanded, VAL, Y, F_is_stdlib, VAL, Y, F_rec_spec, F_is_expanded, VAL, Y
  , F_fields, 1, F_name, VAL, "x", F_dtype, 1, VAL, std.TYPE_NUM, POP, POP, 2, F_name, VAL, "y", F_dtype, 1, VAL, std.TYPE_NUM, POP, POP, POP, POP), addr(lib_syms, std.NK_RECORD
  ));
  std.append_tree(_M, 885, std.tree_lit(_M, 885, F_nk, VAL, std.NK_RECORD, F_name, VAL, "a_xyz", F_is_expanded, VAL, Y, F_is_stdlib, VAL, Y, F_rec_spec, F_is_expanded, VAL, 
  Y, F_fields, 1, F_name, VAL, "x", F_dtype, 1, VAL, std.TYPE_NUM, POP, POP, 2, F_name, VAL, "y", F_dtype, 1, VAL, std.TYPE_NUM, POP, POP, 3, F_name, VAL, "z", F_dtype, 1, VAL, 
  std.TYPE_NUM, POP, POP, POP, POP), addr(lib_syms, std.NK_RECORD));
  if (SCAFFOLDING === Y) {
    std.path_setv(_M, 892, addr(doc, F_is_doc_open), Y);
    std.path_setv(_M, 897, addr(g, F_div_colors, F_is_expanded), Y);
    std.append_tree(_M, 899, std.tree_lit(_M, 899, F_nk, VAL, std.NK_COLOR, F_name, VAL, "MYCOLOR1", F_color, VAL, std.RED), addr(doc, F_syms, std.NK_COLOR));
    std.append_tree(_M, 900, std.tree_lit(_M, 900, F_nk, VAL, std.NK_COLOR, F_name, VAL, "BORDER", F_color, VAL, std.DODGER_BLUE), addr(doc, F_syms, std.NK_COLOR));
    std.append_tree(_M, 901, std.tree_lit(_M, 901, F_nk, VAL, std.NK_COLOR, F_name, VAL, "MYCOLOR2", F_color, VAL, std.ORANGE), addr(doc, F_syms, std.NK_COLOR));
    std.path_setv(_M, 906, addr(g, F_div_enums, F_is_expanded), Y);
    std.append_tree(_M, 907, std.tree_lit(_M, 907, F_nk, VAL, std.NK_ENUM, F_name, VAL, "DONKEY_MODE"), addr(doc, F_syms, std.NK_ENUM));
    std.append_tree(_M, 908, std.tree_lit(_M, 908, F_nk, VAL, std.NK_ENUM, F_name, VAL, "AARDVARK_CONVENTION"), addr(doc, F_syms, std.NK_ENUM));
    std.append_tree(_M, 909, std.tree_lit(_M, 909, F_nk, VAL, std.NK_ENUM, F_name, VAL, "TOTALITY"), addr(doc, F_syms, std.NK_ENUM));
    std.append_tree(_M, 914, std.tree_lit(_M, 914, F_nk, VAL, std.NK_FUNC, F_name, VAL, "main_init", F_func_spec, F_func_kind, VAL, FUNC_CALC, POP, F_comment, VAL, "one time initialization"
    ), addr(doc, F_syms, std.NK_FUNC));
    std.append_tree(_M, 915, std.tree_lit(_M, 915, F_nk, VAL, std.NK_FUNC, F_name, VAL, "main_draw", F_func_spec, F_func_kind, VAL, FUNC_DRAW, POP, F_comment, VAL, "main drawing entry point"
    ), addr(doc, F_syms, std.NK_FUNC));
    std.path_setv(_M, 920, addr(g, F_div_gradients, F_is_expanded), Y);
    std.append_tree(_M, 921, std.tree_lit(_M, 921, F_nk, VAL, std.NK_GRAD, F_name, VAL, "GRAD1", F_grad, VAL, GRAD1), addr(doc, F_syms, std.NK_GRAD));
    std.append_tree(_M, 922, std.tree_lit(_M, 922, F_nk, VAL, std.NK_GRAD, F_name, VAL, "GRAD2", F_grad, VAL, GRAD2), addr(doc, F_syms, std.NK_GRAD));
    std.path_setv(_M, 927, addr(g, F_div_assets, F_is_expanded), Y);
    std.append_tree(_M, 929, std.tree_lit(_M, 929, F_nk, VAL, std.NK_ASSET, F_name, VAL, "A1", F_asset_spec, F_local, VAL, "art/", F_assets2, 1, F_fpath, VAL, "icon_image.png"
    , F_name, VAL, "ICON_IMAGE", POP, 2, F_fpath, VAL, "checkerboard8.png", F_name, VAL, "CHECKERBOARD", std.F_width, VAL, 544, std.F_height, VAL, 16, POP, POP, POP), addr(doc
    , F_syms, std.NK_ASSET));
    std.append_tree(_M, 933, std.tree_lit(_M, 933, F_nk, VAL, std.NK_ASSET, F_name, VAL, "A2", F_asset_spec, F_local, VAL, "art/", F_remote, VAL, "http://beadslang.com/beads/projects/color_picker/art/"
    , F_assets2, 1, F_fpath, VAL, "click.mp3", F_name, VAL, "CLICK", POP, 2, F_fpath, VAL, "beep.mp3", F_name, VAL, "BEEP", POP, 3, F_fpath, VAL, "thud.mp3", F_name, VAL, "THUD"
    , POP, POP, POP), addr(doc, F_syms, std.NK_ASSET));
    std.append_tree(_M, 941, std.tree_lit(_M, 941, F_nk, VAL, std.NK_RECORD, F_name, VAL, "my_record", F_is_expanded, VAL, Y, F_rec_spec, F_is_expanded, VAL, Y, F_fields, 1, F_name
    , VAL, "field1", F_dtype, 1, VAL, std.TYPE_NUM, POP, POP, 2, F_name, VAL, "field2", F_dtype, 1, VAL, std.TYPE_STR, POP, POP, POP, POP), addr(doc, F_syms, std.NK_RECORD));
    std.append_tree(_M, 949, std.tree_lit(_M, 949, F_nk, VAL, std.NK_CONST, F_name, VAL, "my_const1", F_var_spec, F_name, VAL, "my_const1", F_dtype, 1, VAL, std.TYPE_ARRAY, 2, VAL, 
    std.TYPE_NUM, POP, F_initval, 1, VAL, 11, 2, VAL, 12, 3, VAL, 13, POP, POP), addr(doc, F_syms, std.NK_CONST));
    std.append_tree(_M, 952, std.tree_lit(_M, 952, F_nk, VAL, std.NK_CONST, F_name, VAL, "my_const2", F_var_spec, F_name, VAL, "my_const1", F_dtype, 1, VAL, std.TYPE_NUM, POP, 
    F_initval, VAL, 33, POP), addr(doc, F_syms, std.NK_CONST));
    std.append_tree(_M, 958, std.tree_lit(_M, 958, F_nk, VAL, std.NK_VAR, F_name, VAL, "my_var1", F_var_spec, F_dtype, 1, VAL, std.TYPE_NUM, POP, F_initval, VAL, 22, POP), addr(
    doc, F_syms, std.NK_VAR));
    std.append_tree(_M, 961, std.tree_lit(_M, 961, F_nk, VAL, std.NK_VAR, F_name, VAL, "my_var2", F_var_spec, F_dtype, 1, VAL, std.TYPE_STR, POP, F_initval, VAL, "dog", POP), 
    addr(doc, F_syms, std.NK_VAR));
  }
}


//====================
//   set_namelist_kind
//====================
function set_namelist_kind(kind) {
  if (std.eq2(getn(g, F_work_nk), kind)) {
    return;
  }
  std.path_setv(_M, 1667, addr(g, F_work_nk), kind);
  std.path_setv(_M, 1668, addr(g, F_intf_namelist_mru), U);
  std.log(std.cat("set_namelist_kind, kind=", str.to_str(kind, {show_u:Y})));
}


//====================
//   slider_getss
//====================
function slider_getss(ctl) {
  if (getn(ctl, F_ss_driven) === Y) {
    return gets(ctl, F_val_ss);
  } else if (std.get_ptr(ctl, F_val_ptr) !== null) {
    let val = getn(ctl, F_val_ptr, std.FOL);
    if (std.eq2(getn(ctl, F_sunit), SUNIT_PERCENT)) {
      val = std.mul(val, 100);
    }
    let ss = str.to_str(val, { digits:getn(ctl, F_digits) });
    return ss;
  } else {
    return str.to_str(getn(ctl, F_old_val), {});
  }
}


//====================
//   slider_getv
//====================
function slider_getv(ctl) {
  if (getn(ctl, F_ss_driven) === Y) {
    std.halt("not yet");
  } else if (std.get_ptr(ctl, F_val_ptr) !== null) {
    return getn(ctl, F_val_ptr, std.FOL);
  } else {
    return getn(ctl, F_old_val);
  }
}


//====================
//   slider_load
//====================
function slider_load(ctl) {
  let currval = getn(ctl, F_val_ptr, std.FOL);
  if (currval === U) {
    std.path_setv(_M, 3032, addr(ctl, F_val_ptr, std.FOL), getn(ctl, F_default_));
  }
}


//====================
//   slider_reset
//====================
function slider_reset(ctl) {
  slider_setv(ctl, getn(ctl, F_default_));
}


//====================
//   slider_setv
//====================
function slider_setv(ctl, newval) {
  std.path_setv(_M, 3046, addr(ctl, F_ss_driven), U);
  if (std.get_ptr(ctl, F_val_ptr) !== null) {
    std.path_setv(_M, 3048, addr(ctl, F_val_ptr, std.FOL), newval);
  } else {
    std.halt("--warning slider not bound to value");
  }
}


//====================
//   store_graddir
//====================
function store_graddir() {
  let angle = std.mul(std.sub(getn(g, F_work_grad_dir, F_selx), 1), 90);
  slider_setv(addr(SLIDER_GRAD_ANGLE), angle);
}


//====================
//   store_gradshape
//====================
function store_gradshape() {
  let selx = getn(g, F_work_grad_shape, F_selx);
  std.path_setv(_M, 1576, addr(g, F_work_grad, std.F_grad_shape), getn(g, F_work_grad_shape, F_val_list, selx));
  var case1465 = getn(g, F_work_grad, std.F_grad_shape);
  if (case1465 === std.LINEAR_GRADIENT) {
    default_linear_ctl();
  } else if (case1465 === std.RADIAL_GRADIENT) {
    default_radial_ctl();
  }
}


//====================
//   store_repetitions
//====================
function store_repetitions() {
  std.input_set_value(_M, 2427, addr(g, F_timer_nreps_in), "");
}


//====================
//   str_suffix
//====================
function str_suffix(ss) {
  let periods = new std.a_tree("builder","periods");
  let result = null;
  str.str_find(_M, 2208, ss, ".", addr(periods), { reps:std.INFINITY });
  let last = std.tree_count(addr(periods));
  if (std.eq2(last, 0)) {
    result = "";
  } else {
    result = str.subset(ss, { from:getn(periods, last, str.F_find_start) });
  }
  return result;
}


//====================
//   symname
//====================
function symname(sym) {
  let ss = gets(sym, F_name);
  if (getn(doc, F_prog_export_all) === Y) {
    if (getn(sym, F_exportf) === N) {
      ss = std.cat(ss, "**");
    }
  } else if (getn(sym, F_exportf) === Y) {
    ss = std.cat(ss, "*");
  }
  return ss;
}


//====================
//   sync_palette
//====================
function sync_palette(targ) {
  std.path_setv(_M, 3820, addr(g, F_palette_ferrari_selx), ferr_closest_chip(color_ctl_getv(targ)));
}


//====================
//   type_of_ss
//====================
function type_of_ss(type) {
  var case1466 = type;
  if (case1466 === std.TYPE_PTR) {
    return "ptr to ";
  } else if (case1466 === std.TYPE_ARRAY) {
    return "array of ";
  } else if (case1466 === std.TYPE_ARRAY2) {
    return "array^2 of ";
  } else if (case1466 === std.TYPE_ARRAY3) {
    return "array^3 of ";
  } else if (case1466 === std.TYPE_ARRAY4) {
    return "array^4 of ";
  } else {
    return gets(TYPE_TO_STR, type);
  }
}


//====================
//   val_summary
//====================
function val_summary(spec) {
  let ss = null;
  let strval = null;
  var case1467 = getn(spec, F_dtype, 1);
  if (case1467 === std.TYPE_NUM || case1467 === std.TYPE_MEAS) {
    ss = str.to_str(std.get_generic(spec, F_initval), {});
  } else if (case1467 === std.TYPE_STR) {
    ss = std.cat("\"", gets(spec, F_initval), "\"");
  } else if (case1467 === std.TYPE_ARRAY) {
    ss = "[";
    var case1468 = getn(spec, F_dtype, 2);
    if (case1468 === std.TYPE_NUM) {
      var loop1469 = new std.a_loop({ across:addr(spec, F_initval), limit:5 });
      while (loop1469.next()) {
      var numval = loop1469.val;
        ss = std.cat(ss, " ", str.to_str(numval, {}));
      }
    } else if (case1468 === std.TYPE_STR) {
      var loop1470 = new std.a_loop({ across:addr(spec, F_initval), limit:5 });
      while (loop1470.next()) {
      strval = loop1470.val;
        ss = std.cat(ss, " ", strval);
      }
    } else {
      ss = std.cat(ss, " ??? ");
    }
    ss = std.cat(ss, " ]");
  } else if (case1467 === std.TYPE_ARRAY2) {
    ss = "[[...]]";
  } else {
    ss = "<???>";
  }
  return ss;
}


//====================
//   validate_varname
//====================
function validate_varname(input) {
  let first = str.subset(gets(input, std.F_in_value), { from:1, len:1 });
  if (std.eq2(first, "")) {
    return Y;
  }
  if ((std.ge2(first, "0") && std.le2(first, "9"))) {
    return N;
  }
  if (str.str_pos(gets(input, std.F_in_value), " ", {}) !== U) {
    return N;
  }
  return Y;
}


//====================
//   var_add_init
//====================
function var_add_init() {
  std.path_setv(_M, 1344, addr(g, F_work_state), WORK_NEW);
  std.path_setv(_M, 1345, addr(g, F_work_sym), U);
  std.trunc_tree(_M, 1347, addr(g, F_work_var));
  std.path_setv(_M, 1351, addr(g, F_work_var, F_name_in, std.F_in_label), "work_var_name_in");
  std.path_setv(_M, 1353, addr(g, F_work_var, F_name_in, std.F_in_value), "");
  std.path_setv(_M, 1354, addr(g, F_work_var, F_name_in, std.F_in_ok), Y);
  std.path_setv(_M, 1355, addr(g, F_work_var, F_name_in, std.F_in_validator), validate_varname_F);
  std.path_setv(_M, 1356, addr(g, F_work_var, F_name_in, std.F_in_minlen), 1);
  std.path_setv(_M, 1357, addr(g, F_work_var, F_name_in, std.F_in_required), Y);
  std.path_setv(_M, 1359, addr(g, F_work_var, F_initval_in, std.F_in_label), "work_var_initv_in");
  std.path_setv(_M, 1361, addr(g, F_work_var, F_initval_in, std.F_in_value), "");
  std.path_setv(_M, 1362, addr(g, F_work_var, F_initval_in, std.F_in_ok), Y);
  std.path_setv(_M, 1364, addr(g, F_work_var, F_dtype, 1), std.TYPE_NUM);
}


//====================
//   var_edit_init
//====================
function var_edit_init(sym) {
  std.path_setv(_M, 1370, addr(g, F_work_state), WORK_EDITING);
  std.path_setv(_M, 1371, addr(g, F_work_sym), sym);
  std.path_setv(_M, 1372, addr(g, F_work_name_in, std.F_in_value), gets(sym, F_name));
}


//====================
//   add_textsize_slider_2985
//====================
function add_textsize_slider_2985(b, ctl) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), gets(ctl, F_prompt), { just:std.RIGHT, indent:std.pt_to_dots(b, 5), size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   add_tool_bbox_2875
//====================
function add_tool_bbox_2875(b) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), "box", { just:std.RIGHT, indent:std.pt_to_dots(b, 5), size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   add_tool_color_2911
//====================
function add_tool_color_2911(b, label, ctl) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), label, { just:std.RIGHT, indent:std.pt_to_dots(b, 5), size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   add_tool_corner_2956
//====================
function add_tool_corner_2956(b) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), "corner", { just:std.RIGHT, indent:std.pt_to_dots(b, 5), size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   add_tool_fill_2899
//====================
function add_tool_fill_2899(b) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), "background fill", { just:std.RIGHT, indent:std.pt_to_dots(b, 5), size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   add_tool_font_2919
//====================
function add_tool_font_2919(b) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), "font", { just:std.RIGHT, size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   add_tool_image_2883
//====================
function add_tool_image_2883(b) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), "image", { just:std.RIGHT, indent:std.pt_to_dots(b, 5), size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   add_tool_just_2833
//====================
function add_tool_just_2833(b) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), "justification", { just:std.RIGHT, indent:std.pt_to_dots(b, 5), size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   add_tool_linecap_2815
//====================
function add_tool_linecap_2815(b) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), "line cap", { just:std.RIGHT, indent:std.pt_to_dots(b, 5), size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   add_tool_num_2932
//====================
function add_tool_num_2932(b, prompt, data, _o=null) {
var min = U; if ((_o != null) && _o.hasOwnProperty("min")) min = _o.min;
var max = U; if ((_o != null) && _o.hasOwnProperty("max")) max = _o.max;
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), prompt, { just:std.RIGHT, indent:std.pt_to_dots(b, 5), size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   add_tool_point_3267
//====================
function add_tool_point_3267(b, prompt) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), prompt, { just:std.RIGHT, indent:std.pt_to_dots(b, 5), size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   add_tool_slider_2942
//====================
function add_tool_slider_2942(b, ctl) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), gets(ctl, F_prompt), { just:std.RIGHT, indent:std.pt_to_dots(b, 5), size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   add_tool_str_2891
//====================
function add_tool_str_2891(b) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), "text string", { just:std.RIGHT, indent:std.pt_to_dots(b, 5), size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   d_asset_spec_2177
//====================
function d_asset_spec_2177(b, localfolder, item) {
k.k_enter(b);
  let symbol = null;
  var case1471 = str_suffix(gets(item, F_fpath));
  if (case1471 === ".jpg" || case1471 === ".jpeg" || case1471 === ".gif" || case1471 === ".png" || case1471 === ".svg") {
    symbol = "";
    std.draw_str(b, addr(b.extra, std.F_box), symbol, { size:0.7, color:C_TOOL_LABEL });
  } else if (case1471 === ".mp3" || case1471 === ".aac" || case1471 === ".wav") {
    symbol = "";
    let r = new std.a_tree("builder","r"); std.merge_tree(_M, 2184, std.solve_rect({ basis:addr(b.extra, std.F_box), pin:5, aspect:1 }), addr(r));
    std.draw_oval(b, addr(r), { fill:std.GRAY2 });
    std.draw_str(b, addr(b.extra, std.F_box), symbol, { size:0.5, color:C_TOOL_LABEL });
  } else {
    symbol = "?";
    std.draw_str(b, addr(b.extra, std.F_box), symbol, { size:0.7, color:C_TOOL_LABEL });
  }
k.k_leave(b);
}


//====================
//   d_asset_spec_2191
//====================
function d_asset_spec_2191(b, localfolder, item) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), gets(item, F_name), { size:0.7, just:std.LEFT, indent:std.pt_to_dots(b, 2), color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   d_asset_spec_2194
//====================
function d_asset_spec_2194(b, localfolder, item) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), std.cat("", str.to_str(getn(item, std.F_width), {show_u:Y}), " x ", str.to_str(getn(item, std.F_height), {show_u:Y})), { size:0.7
  , just:std.LEFT, indent:std.pt_to_dots(b, 4), color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   d_color_sample_3410
//====================
function d_color_sample_3410(b) {
k.k_enter(b);
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:getn(g, F_work_color), thick:std.pt_to_dots(b, 2), color:std.GRAY6, corner:std.pt_to_dots(b, 10) });
k.k_leave(b);
}


//====================
//   d_color_spec_2233
//====================
function d_color_spec_2233(b, sym) {
k.k_enter(b);
  if (std.eq2(sym, std.get_ptr(g, F_work_sym))) {
    std.draw_rect(b, addr(b.extra, std.F_box), { fill:C_TOOL_LABEL_SEL_BACK, corner_tl:std.pt_to_dots(b, 4), corner_bl:std.pt_to_dots(b, 4) });
  }
  std.draw_str(b, addr(b.extra, std.F_box), gets(sym, F_name), { size:0.7, just:std.LEFT, indent:std.pt_to_dots(b, 6), color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   d_color_spec_2237
//====================
function d_color_spec_2237(b, sym) {
k.k_enter(b);
  let r = new std.a_tree("builder","r"); std.merge_tree(_M, 2237, std.solve_rect({ basis:addr(b.extra, std.F_box), pin:5, inset_y:std.pt_to_dots(b, 1) }), addr(r));
  std.draw_rect(b, addr(r), { fill:getn(sym, F_color), color:ENTRY_LO_BORD, thick:std.pt_to_dots(b, BUTT_THICK) });
k.k_leave(b);
}


//====================
//   d_data_editarea_1178
//====================
function d_data_editarea_1178(b) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), "Data structure designer", { size:0.75, color:BUTT_LO_TEXT });
k.k_leave(b);
}


//====================
//   d_dtype_picker_1070
//====================
function d_dtype_picker_1070(b) {
k.k_enter(b);
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:BUTT_LO_BORD });
k.k_leave(b);
}


//====================
//   d_enum_spec_2222
//====================
function d_enum_spec_2222(b, sym) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), gets(sym, F_name), { size:0.7, just:std.LEFT, indent:std.pt_to_dots(b, 6), color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   d_font_example_4239
//====================
function d_font_example_4239(b, fontname) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), fontname, { size:0.6, just:std.LEFT, font:fontname, color:c_text });
k.k_leave(b);
}


//====================
//   d_font_example_4242
//====================
function d_font_example_4242(b, fontname) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), "The five boxing wizards jump quickly", { size:0.6, just:std.LEFT, font:fontname, color:c_text });
k.k_leave(b);
}


//====================
//   d_gradient_spec_2250
//====================
function d_gradient_spec_2250(b, sym) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), gets(sym, F_name), { size:0.7, just:std.LEFT, indent:std.pt_to_dots(b, 6), color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   d_gradient_spec_2252
//====================
function d_gradient_spec_2252(b, sym) {
k.k_enter(b);
  let r = new std.a_tree("builder","r"); std.merge_tree(_M, 2252, std.solve_rect({ basis:addr(b.extra, std.F_box), pin:5, inset_y:std.pt_to_dots(b, 1) }), addr(r));
  std.draw_rect(b, addr(r), { grad:addr(sym, F_grad), color:ENTRY_LO_BORD, thick:std.pt_to_dots(b, BUTT_THICK) });
k.k_leave(b);
}


//====================
//   d_name_close_2731
//====================
function d_name_close_2731(b) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), gets(g, F_prog_name_in, std.F_in_name), { just:std.RIGHT, indent:std.pt_to_dots(b, 5), size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   d_name_close_2733
//====================
function d_name_close_2733(b) {
k.k_enter(b);
  std.draw_input(b, addr(b.extra, std.F_box), addr(g, F_prog_name_in), { size:0.65, indent:std.pt_to_dots(b, 2), color:ENTRY_LO_TEXT, border:std.pt_to_dots(b, 2), border_color
  :ENTRY_LO_BORD, fill:ENTRY_LO_BACK });
k.k_leave(b);
}


//====================
//   d_name_entry_2748
//====================
function d_name_entry_2748(b, field) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), gets(field, std.F_in_name), { just:std.RIGHT, indent:std.pt_to_dots(b, 5), size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   d_name_entry_2750
//====================
function d_name_entry_2750(b, field) {
k.k_enter(b);
  std.draw_input(b, addr(b.extra, std.F_box), field, { size:0.65, indent:std.pt_to_dots(b, 2), color:ENTRY_LO_TEXT, border:std.pt_to_dots(b, 2), border_color:ENTRY_LO_BORD, 
  fill:ENTRY_LO_BACK });
k.k_leave(b);
}


//====================
//   d_prog_version_2713
//====================
function d_prog_version_2713(b) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), "version", { just:std.RIGHT, size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   d_prog_version_2716
//====================
function d_prog_version_2716(b) {
k.k_enter(b);
  std.draw_input(b, addr(b.extra, std.F_box), addr(g, F_prog_ver1_in), { size:0.65, indent:std.pt_to_dots(b, 2), color:ENTRY_LO_TEXT, border:std.pt_to_dots(b, 2), border_color
  :ENTRY_LO_BORD, fill:ENTRY_LO_BACK });
k.k_leave(b);
}


//====================
//   d_prog_version_2718
//====================
function d_prog_version_2718(b) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), ".", { size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   d_prog_version_2720
//====================
function d_prog_version_2720(b) {
k.k_enter(b);
  std.draw_input(b, addr(b.extra, std.F_box), addr(g, F_prog_ver2_in), { size:0.65, indent:std.pt_to_dots(b, 2), color:ENTRY_LO_TEXT, border:std.pt_to_dots(b, 2), border_color
  :ENTRY_LO_BORD, fill:ENTRY_LO_BACK });
k.k_leave(b);
}


//====================
//   d_prog_version_2722
//====================
function d_prog_version_2722(b) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), ".", { size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   d_prog_version_2724
//====================
function d_prog_version_2724(b) {
k.k_enter(b);
  std.draw_input(b, addr(b.extra, std.F_box), addr(g, F_prog_ver3_in), { size:0.65, indent:std.pt_to_dots(b, 2), color:ENTRY_LO_TEXT, border:std.pt_to_dots(b, 2), border_color
  :ENTRY_LO_BORD, fill:ENTRY_LO_BACK });
k.k_leave(b);
}


//====================
//   d_pulldown_1252
//====================
function d_pulldown_1252(b, slotx, label) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), label, { size:0.6, color:BUTT_LO_TEXT });
k.k_leave(b);
}


//====================
//   d_timer_interval_2433
//====================
function d_timer_interval_2433(b) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), "every", { just:std.RIGHT, indent:std.pt_to_dots(b, 5), size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   d_timer_rep_2418
//====================
function d_timer_rep_2418(b) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), "repetitions", { just:std.RIGHT, indent:std.pt_to_dots(b, 5), size:TOOL_TSIZE, color:C_TOOL_LABEL });
k.k_leave(b);
}


//====================
//   d_timer_rep_2422
//====================
function d_timer_rep_2422(b) {
k.k_enter(b);
  std.draw_input(b, addr(b.extra, std.F_box), addr(g, F_timer_nreps_in), { size:0.65, indent:std.pt_to_dots(b, 2), color:ENTRY_LO_TEXT, border:std.pt_to_dots(b, 2), border_color
  :ENTRY_LO_BORD, fill:ENTRY_LO_BACK });
k.k_leave(b);
}


//====================
//   d_work_var_1210
//====================
function d_work_var_1210(b, spec) {
k.k_enter(b);
  std.draw_input(b, addr(b.extra, std.F_box), addr(spec, F_name_in), { size:0.6, indent:std.pt_to_dots(b, 2), color:ENTRY_LO_TEXT, border:std.pt_to_dots(b, 2), border_color:
  ENTRY_LO_BORD, fill:ENTRY_LO_BACK });
k.k_leave(b);
}


//====================
//   d_work_var_1212
//====================
function d_work_var_1212(b, spec) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), ":", { size:0.7, color:BUTT_LO_TEXT });
k.k_leave(b);
}


//====================
//   d_work_var_1216
//====================
function d_work_var_1216(b, spec) {
k.k_enter(b);
  d_work_dtype(b, spec);
k.k_leave(b);
}


//====================
//   d_work_var_1218
//====================
function d_work_var_1218(b, spec) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), "=", { size:0.7, color:BUTT_LO_TEXT });
k.k_leave(b);
}


//====================
//   d_work_var_1220
//====================
function d_work_var_1220(b, spec) {
k.k_enter(b);
  std.draw_input(b, addr(b.extra, std.F_box), addr(spec, F_initval_in), { size:0.6, indent:std.pt_to_dots(b, 2), color:ENTRY_LO_TEXT, border:std.pt_to_dots(b, 2), border_color
  :ENTRY_LO_BORD, fill:ENTRY_LO_BACK });
k.k_leave(b);
}


//====================
//   d_work_var_hdr_1193
//====================
function d_work_var_hdr_1193(b, spec) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), "Name", { just:std.LEFT, indent:std.pt_to_dots(b, 4), size:0.6, color:BUTT_LO_TEXT });
k.k_leave(b);
}


//====================
//   d_work_var_hdr_1199
//====================
function d_work_var_hdr_1199(b, spec) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), "Data type", { size:0.6, color:BUTT_LO_TEXT });
k.k_leave(b);
}


//====================
//   d_work_var_hdr_1202
//====================
function d_work_var_hdr_1202(b, spec) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), "Initial value", { just:std.LEFT, vert:0, indent:std.pt_to_dots(b, 8), size:0.6, color:BUTT_LO_TEXT });
k.k_leave(b);
}


//====================
//   ferr_first_ramp_4574
//====================
function ferr_first_ramp_4574(b) {
k.k_enter(b);
  k.k_isolate(b, b.bounds, "ferr_ramp_chip", ferr_ramp_chip_F, [1]);
k.k_leave(b);
}


//====================
//   ferr_first_ramp_4576
//====================
function ferr_first_ramp_4576(b) {
k.k_enter(b);
  k.k_isolate(b, b.bounds, "ferr_ramp_chip", ferr_ramp_chip_F, [2]);
k.k_leave(b);
}


//====================
//   html_color_chip_4796
//====================
function html_color_chip_4796(b, myslot) {
k.k_enter(b);
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:getn(myslot, F_color), corner:std.pt_to_dots(b, 3) });
  if (hilite === Y) {
    std.draw_rect(b, addr(b.extra, std.F_box), { color:std.FIREBRICK, thick:std.pt_to_dots(b, 4), corner:std.pt_to_dots(b, 3) });
  } else {
    std.draw_rect(b, addr(b.extra, std.F_box), { color:std.BLACK, thick:std.pt_to_dots(b, 1), corner:std.pt_to_dots(b, 3) });
  }
k.k_leave(b);
}


//====================
//   html_color_chip_4806
//====================
function html_color_chip_4806(b, myslot) {
k.k_enter(b);
  let tcolor = U;
  if (hilite === Y) {
    let radius = std.div(b.bounds.height, 6);
    std.draw_rect(b, addr(b.extra, std.F_box), { fill:std.PEACH_PUFF, corner_tr:radius, corner_br:radius });
    tcolor = std.BLACK;
  } else {
    tcolor = C_PALTEXT;
  }
  let ss = html_slot_str(myslot);
  var case1472 = getn(gsc, F_format);
  if (case1472 === FORMAT_BEADS || case1472 === FORMAT_HTML) {
    std.draw_str(b, addr(b.extra, std.F_box), ss, { just:std.LEFT, indent:std.pt_to_dots(b, 4), size:std.div(b.bounds.width, 11), color:tcolor });
  } else if (case1472 === FORMAT_HEX) {
    std.draw_str(b, addr(b.extra, std.F_box), ss, { just:std.LEFT, indent:std.pt_to_dots(b, 4), size:std.div(b.bounds.width, 8), color:tcolor, font:"_typewriter" });
  }
k.k_leave(b);
}


//====================
//   open_header_1796
//====================
function open_header_1796(b) {
k.k_enter(b);
  std.draw_str(b, addr(b.extra, std.F_box), std.cat("Beads builder tool v", gets(std.runtime, std.F_app_version)), { just:std.LEFT, size:0.6, color:BUTT_LO_TEXT, shrink:N })
  ;
k.k_leave(b);
}


//====================
//   toolbar_1935
//====================
function toolbar_1935(b) {
k.k_enter(b);
  std.draw_rect(b, addr(b.extra, std.F_box), { fill:C_TAB_UND });
k.k_leave(b);
}

main_init();
k.rebuild_all();

</script>
</body>
</html>
